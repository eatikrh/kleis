// ============================================
// Kleis Standard Library - Symbolic Differentiation
// ============================================
//
// Computational differentiation using the Expression AST.
// D : Expression → String → Expression
//
// This operates on Expression values (code as data), not opaque lambdas.
// Consistent with kleis_in_kleis.kleis meta-programming approach.
//
// Grammar: v0.98
// Version: 1.0.0
// ============================================

// ============================================
// Expression AST (from kleis_in_kleis.kleis)
// ============================================

data Expression =
    ENumber(value : ℝ)
  | EVariable(name : String)
  | EOperation(name : String, args : List(Expression))

// Note: Full Expression in kleis_in_kleis.kleis also has ELambda, ELet, etc.
// For differentiation, we only need the above three.

// ============================================
// Constructor Helpers (for cleaner code)
// ============================================
// Note: We prefix with 'e_' to avoid conflict with Kleis builtins
// (e.g., 'pow' would be interpreted as built-in power)

define num(n) = ENumber(n)
define var(x) = EVariable(x)
define e_op(name, args) = EOperation(name, args)

// Binary operations (e_ prefix for Expression constructors)
define e_add(a, b) = e_op("plus", Cons(a, Cons(b, Nil)))
define e_sub(a, b) = e_op("minus", Cons(a, Cons(b, Nil)))
define e_mul(a, b) = e_op("times", Cons(a, Cons(b, Nil)))
define e_div(a, b) = e_op("divide", Cons(a, Cons(b, Nil)))
define e_pow(a, b) = e_op("power", Cons(a, Cons(b, Nil)))

// Unary operations
define e_neg(a) = e_op("negate", Cons(a, Nil))
define e_sin(a) = e_op("sin", Cons(a, Nil))
define e_cos(a) = e_op("cos", Cons(a, Nil))
define e_tan(a) = e_op("tan", Cons(a, Nil))
define e_exp(a) = e_op("exp", Cons(a, Nil))
define e_ln(a) = e_op("ln", Cons(a, Nil))
define e_sqrt(a) = e_op("sqrt", Cons(a, Nil))

// ============================================
// Symbolic Differentiation: D(e, x)
// ============================================
//
// diff : Expression → String → Expression
//
// Computes the derivative of expression e with respect to variable x.
// Returns a new Expression representing the derivative.
//
// Note: We use lowercase 'diff' because uppercase names in Kleis
// are reserved for data constructors.
//

define diff(e, var_name) = match e {
    // Constant rule: d/dx(c) = 0
    ENumber(_) => num(0)
    
    // Variable rule: d/dx(x) = 1, d/dx(y) = 0 if y ≠ x
    // Note: We use str_eq() for concrete string comparison
    EVariable(name) => if str_eq(name, var_name) then num(1) else num(0)
    
    // Operation rules
    EOperation(op_name, args) => diff_op(op_name, args, var_name)
}

// Differentiate operations by name
define diff_op(op_name, args, var_name) = match op_name {
    // Unary operations
    "negate" => match args { Cons(f, Nil) => e_neg(diff(f, var_name)) | _ => num(0) }
    
    "sin" => match args { 
        Cons(f, Nil) => e_mul(e_cos(f), diff(f, var_name))  // Chain rule
        | _ => num(0) 
    }
    
    "cos" => match args { 
        Cons(f, Nil) => e_neg(e_mul(e_sin(f), diff(f, var_name)))
        | _ => num(0) 
    }
    
    "tan" => match args {
        Cons(f, Nil) => e_mul(e_div(num(1), e_pow(e_cos(f), num(2))), diff(f, var_name))
        | _ => num(0)
    }
    
    "exp" => match args { 
        Cons(f, Nil) => e_mul(e_exp(f), diff(f, var_name))
        | _ => num(0) 
    }
    
    "ln" => match args { 
        Cons(f, Nil) => e_mul(e_div(num(1), f), diff(f, var_name))
        | _ => num(0) 
    }
    
    "sqrt" => match args {
        Cons(f, Nil) => e_div(diff(f, var_name), e_mul(num(2), e_sqrt(f)))
        | _ => num(0)
    }
    
    // Binary operations
    "plus" => match args {
        Cons(f, Cons(g, Nil)) => e_add(diff(f, var_name), diff(g, var_name))
        | _ => num(0)
    }
    
    "minus" => match args {
        Cons(f, Cons(g, Nil)) => e_sub(diff(f, var_name), diff(g, var_name))
        | _ => num(0)
    }
    
    "times" => match args {
        // Product rule: d/dx(f * g) = f' * g + f * g'
        Cons(f, Cons(g, Nil)) => e_add(e_mul(diff(f, var_name), g), e_mul(f, diff(g, var_name)))
        | _ => num(0)
    }
    
    "divide" => match args {
        // Quotient rule: d/dx(f / g) = (f' * g - f * g') / g²
        Cons(f, Cons(g, Nil)) => e_div(e_sub(e_mul(diff(f, var_name), g), e_mul(f, diff(g, var_name))), e_pow(g, num(2)))
        | _ => num(0)
    }
    
    "power" => match args {
        // Power rule with constant exponent
        Cons(f, Cons(ENumber(n), Nil)) => 
            e_mul(e_mul(num(n), e_pow(f, num(n - 1))), diff(f, var_name))
        // General power rule: d/dx(f^g) = f^g * (g' * ln(f) + g * f'/f)
        Cons(f, Cons(g, Nil)) =>
            e_mul(e_pow(f, g), e_add(e_mul(diff(g, var_name), e_ln(f)), e_mul(g, e_div(diff(f, var_name), f))))
        | _ => num(0)
    }
    
    // Unknown operation - treat as constant
    _ => num(0)
}

// ============================================
// Coordinate-Specific Derivatives
// ============================================
//
// For Cartan geometry with coordinates (t, r, θ, φ)
//

define diff_t(e) = diff(e, "t")
define diff_r(e) = diff(e, "r")
define diff_theta(e) = diff(e, "theta")
define diff_phi(e) = diff(e, "phi")

// ============================================
// Expression Simplification
// ============================================

define simplify(e) = simplify_once(simplify_children(e))

define simplify_children(e) = match e {
    ENumber(v) => ENumber(v)
    EVariable(n) => EVariable(n)
    EOperation(name, args) => EOperation(name, map_simplify(args))
}

define map_simplify(args) = match args {
    Nil => Nil
    Cons(x, xs) => Cons(simplify(x), map_simplify(xs))
}

define simplify_once(e) = match e {
    // Addition rules
    EOperation("plus", Cons(ENumber(0), Cons(f, Nil))) => f
    EOperation("plus", Cons(f, Cons(ENumber(0), Nil))) => f
    EOperation("plus", Cons(ENumber(a), Cons(ENumber(b), Nil))) => num(a + b)
    
    // Subtraction rules
    EOperation("minus", Cons(f, Cons(ENumber(0), Nil))) => f
    EOperation("minus", Cons(ENumber(0), Cons(f, Nil))) => e_neg(f)
    EOperation("minus", Cons(ENumber(a), Cons(ENumber(b), Nil))) => num(a - b)
    
    // Multiplication rules
    EOperation("times", Cons(ENumber(0), Cons(_, Nil))) => num(0)
    EOperation("times", Cons(_, Cons(ENumber(0), Nil))) => num(0)
    EOperation("times", Cons(ENumber(1), Cons(f, Nil))) => f
    EOperation("times", Cons(f, Cons(ENumber(1), Nil))) => f
    EOperation("times", Cons(ENumber(a), Cons(ENumber(b), Nil))) => num(a * b)
    
    // Division rules
    EOperation("divide", Cons(ENumber(0), Cons(_, Nil))) => num(0)
    EOperation("divide", Cons(f, Cons(ENumber(1), Nil))) => f
    EOperation("divide", Cons(ENumber(a), Cons(ENumber(b), Nil))) => num(a / b)
    
    // Power rules
    EOperation("power", Cons(_, Cons(ENumber(0), Nil))) => num(1)
    EOperation("power", Cons(f, Cons(ENumber(1), Nil))) => f
    EOperation("power", Cons(ENumber(0), Cons(_, Nil))) => num(0)
    EOperation("power", Cons(ENumber(1), Cons(_, Nil))) => num(1)
    
    // Negation rules
    EOperation("negate", Cons(ENumber(0), Nil)) => num(0)
    EOperation("negate", Cons(EOperation("negate", Cons(f, Nil)), Nil)) => f
    EOperation("negate", Cons(ENumber(a), Nil)) => num(0 - a)
    
    // Trig at 0
    EOperation("sin", Cons(ENumber(0), Nil)) => num(0)
    EOperation("cos", Cons(ENumber(0), Nil)) => num(1)
    
    // Exp/Ln identities
    EOperation("exp", Cons(ENumber(0), Nil)) => num(1)
    EOperation("ln", Cons(ENumber(1), Nil)) => num(0)
    EOperation("exp", Cons(EOperation("ln", Cons(f, Nil)), Nil)) => f
    EOperation("ln", Cons(EOperation("exp", Cons(f, Nil)), Nil)) => f
    
    // Sqrt identities
    EOperation("sqrt", Cons(ENumber(0), Nil)) => num(0)
    EOperation("sqrt", Cons(ENumber(1), Nil)) => num(1)
    
    // No rule matched
    _ => e
}

// Convenience: differentiate and simplify
define diffs(e, x) = simplify(diff(e, x))

// ============================================
// Variable Substitution
// ============================================

define subst(e, target_var, val) = match e {
    ENumber(v) => ENumber(v)
    EVariable(name) => if str_eq(name, target_var) then val else EVariable(name)
    EOperation(op_name, args) => EOperation(op_name, map_subst(args, target_var, val))
}

define map_subst(args, target_var, val) = match args {
    Nil => Nil
    Cons(x, xs) => Cons(subst(x, target_var, val), map_subst(xs, target_var, val))
}

// ============================================
// Example Expressions
// ============================================

// x²
define x_squared = e_pow(var("x"), num(2))

// sin(x)
define sin_x = e_sin(var("x"))

// e^x
define exp_x = e_exp(var("x"))

// √(1 - 2M/r) - Schwarzschild metric factor
define schw_f(M) = e_sqrt(e_sub(num(1), e_div(e_mul(num(2), M), var("r"))))

// ============================================
// Summary
// ============================================
//
// diff : Expression → String → Expression
//
// Computes symbolic derivatives by pattern matching on Expression AST.
// Uses the same Expression type as kleis_in_kleis.kleis.
//
// Note: We use lowercase 'diff' because uppercase names in Kleis
// are reserved for data constructors.
//
// For axiomatic verification, see calculus_hof.kleis which defines
// axioms for Z3 verification (not computation).
//
// This module is for COMPUTATION.
//
// ============================================
