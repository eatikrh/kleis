// Symbolic Differentiation in Pure Kleis
// =======================================
//
// This module implements computational symbolic differentiation using
// pattern matching on expression trees. Unlike the axiomatic D(f,x) in
// calculus.kleis (which declares properties for Z3 verification), this
// module COMPUTES actual derivatives.
//
// Usage:
//   let expr = Mul(Var("x"), Var("x")) in  // x²
//   diff(expr, "x")                         // → Add(Mul(Const(1), Var("x")), Mul(Var("x"), Const(1)))
//                                           //   which simplifies to 2x
//
// See also: stdlib/calculus.kleis for D(f,x) axioms used in Z3 verification

// =============================================================================
// Expression AST
// =============================================================================

data Expr = 
    Const(value : ℝ)
  | Var(name : String)
  | Add(left : Expr, right : Expr)
  | Sub(left : Expr, right : Expr)
  | Mul(left : Expr, right : Expr)
  | Div(numer : Expr, denom : Expr)
  | Pow(base : Expr, exp : Expr)
  | Neg(arg : Expr)
  | Sin(arg : Expr)
  | Cos(arg : Expr)
  | Tan(arg : Expr)
  | Exp(arg : Expr)
  | Ln(arg : Expr)
  | Sqrt(arg : Expr)

// =============================================================================
// Symbolic Differentiation
// =============================================================================

// diff(e, x) - Compute the derivative of expression e with respect to variable x
//
// Implements standard derivative rules:
//   - Constant rule: d/dx(c) = 0
//   - Variable rule: d/dx(x) = 1, d/dx(y) = 0 if y ≠ x
//   - Sum rule: d/dx(f + g) = f' + g'
//   - Difference rule: d/dx(f - g) = f' - g'
//   - Product rule: d/dx(f · g) = f' · g + f · g'
//   - Quotient rule: d/dx(f / g) = (f' · g - f · g') / g²
//   - Power rule: d/dx(f^n) = n · f^(n-1) · f'
//   - Chain rule: d/dx(sin(f)) = cos(f) · f', etc.

// Coordinate-specific derivative helpers
// These avoid conditionals by knowing which variable they're differentiating
define diff_wrt_t(e) = diff_core(e, "t", is_t)
define diff_wrt_r(e) = diff_core(e, "r", is_r)
define diff_wrt_theta(e) = diff_core(e, "theta", is_theta)
define diff_wrt_phi(e) = diff_core(e, "phi", is_phi)

// Check if a variable name matches a coordinate (returns Expr: Const(1) or Const(0))
define is_t(name) = match name { "t" => Const(1) | _ => Const(0) }
define is_r(name) = match name { "r" => Const(1) | _ => Const(0) }
define is_theta(name) = match name { "theta" => Const(1) | _ => Const(0) }
define is_phi(name) = match name { "phi" => Const(1) | _ => Const(0) }

// Generic variable checker (fallback - may create conditionals)
define is_var(name, x) = if name = x then Const(1) else Const(0)

// Core diff with variable checker function
define diff_core(e, x, var_check) =
    match e {
        Const(_) => Const(0)
        Var(name) => var_check(name)
        Neg(f) => Neg(diff_core(f, x, var_check))
        Add(f, g) => Add(diff_core(f, x, var_check), diff_core(g, x, var_check))
        Sub(f, g) => Sub(diff_core(f, x, var_check), diff_core(g, x, var_check))
        Mul(f, g) => Add(Mul(diff_core(f, x, var_check), g), Mul(f, diff_core(g, x, var_check)))
        Div(f, g) => Div(Sub(Mul(diff_core(f, x, var_check), g), Mul(f, diff_core(g, x, var_check))), Pow(g, Const(2)))
        Pow(f, Const(n)) => Mul(Mul(Const(n), Pow(f, Const(n - 1))), diff_core(f, x, var_check))
        Pow(f, g) => Mul(Pow(f, g), Add(Mul(diff_core(g, x, var_check), Ln(f)), Mul(g, Div(diff_core(f, x, var_check), f))))
        Sin(f) => Mul(Cos(f), diff_core(f, x, var_check))
        Cos(f) => Mul(Neg(Sin(f)), diff_core(f, x, var_check))
        Tan(f) => Mul(Div(Const(1), Pow(Cos(f), Const(2))), diff_core(f, x, var_check))
        Exp(f) => Mul(Exp(f), diff_core(f, x, var_check))
        Ln(f) => Mul(Div(Const(1), f), diff_core(f, x, var_check))
        Sqrt(f) => Div(diff_core(f, x, var_check), Mul(Const(2), Sqrt(f)))
        _ => Const(0)
    }

// Original diff function (may create conditionals for arbitrary variable names)
define diff(e, x) =
    match e {
        // Constants have zero derivative
        Const(_) => Const(0)
        
        // Variable: 1 if same as x, 0 otherwise
        // Note: This creates a conditional for non-standard variables
        Var(name) => is_var(name, x)
        
        // Negation: d/dx(-f) = -f'
        Neg(f) => Neg(diff(f, x))
        
        // Sum rule: d/dx(f + g) = f' + g'
        Add(f, g) => Add(diff(f, x), diff(g, x))
        
        // Difference rule: d/dx(f - g) = f' - g'
        Sub(f, g) => Sub(diff(f, x), diff(g, x))
        
        // Product rule: d/dx(f · g) = f' · g + f · g'
        Mul(f, g) => 
            Add(Mul(diff(f, x), g), Mul(f, diff(g, x)))
        
        // Quotient rule: d/dx(f/g) = (f'g - fg') / g²
        Div(f, g) =>
            Div(
                Sub(Mul(diff(f, x), g), Mul(f, diff(g, x))),
                Pow(g, Const(2))
            )
        
        // Power rule: d/dx(f^n) = n · f^(n-1) · f'
        // Note: This handles f^(constant) case
        Pow(f, Const(n)) =>
            Mul(
                Mul(Const(n), Pow(f, Const(n - 1))),
                diff(f, x)
            )
        
        // General power rule: d/dx(f^g) = f^g · (g' · ln(f) + g · f'/f)
        // For non-constant exponents
        Pow(f, g) =>
            Mul(
                Pow(f, g),
                Add(
                    Mul(diff(g, x), Ln(f)),
                    Mul(g, Div(diff(f, x), f))
                )
            )
        
        // Trigonometric derivatives (chain rule applied)
        Sin(f) => Mul(Cos(f), diff(f, x))
        Cos(f) => Mul(Neg(Sin(f)), diff(f, x))
        Tan(f) => Mul(Div(Const(1), Pow(Cos(f), Const(2))), diff(f, x))
        
        // Exponential and logarithm
        Exp(f) => Mul(Exp(f), diff(f, x))
        Ln(f) => Mul(Div(Const(1), f), diff(f, x))
        
        // Square root: √f = f^(1/2), so d/dx(√f) = (1/2) * f^(-1/2) * f' = f'/(2√f)
        // This is a special case of the power rule, but we keep it for clarity
        // and because Sqrt is a separate constructor in our AST.
        // If you represent √x as Pow(x, Const(0.5)), the power rule handles it.
        Sqrt(f) => Div(diff(f, x), Mul(Const(2), Sqrt(f)))
        
        // Fallback for unhandled cases
        _ => Const(0)
    }

// =============================================================================
// Expression Simplification (pattern-matching only, no conditionals)
// =============================================================================

// simplify(e) - Apply algebraic simplifications using ONLY pattern matching
//
// IMPORTANT: We avoid `if a = b then ...` conditionals because Kleis evaluates
// them symbolically, creating conditional expressions instead of simplifying!
// Pattern matching works structurally and correctly reduces expressions.

// Helper: simplify once, then check if more simplification is possible
define simplify(e) = simplify_once(simplify_children(e))

// First, recursively simplify children
define simplify_children(e) =
    match e {
        Const(v) => Const(v)
        Var(n) => Var(n)
        Add(f, g) => Add(simplify(f), simplify(g))
        Sub(f, g) => Sub(simplify(f), simplify(g))
        Mul(f, g) => Mul(simplify(f), simplify(g))
        Div(f, g) => Div(simplify(f), simplify(g))
        Pow(f, g) => Pow(simplify(f), simplify(g))
        Neg(f) => Neg(simplify(f))
        Sin(f) => Sin(simplify(f))
        Cos(f) => Cos(simplify(f))
        Tan(f) => Tan(simplify(f))
        Exp(f) => Exp(simplify(f))
        Ln(f) => Ln(simplify(f))
        Sqrt(f) => Sqrt(simplify(f))
        _ => e
    }

// Then apply simplification rules at the top level
define simplify_once(e) =
    match e {
        // ===== Addition rules =====
        Add(Const(0), f) => f
        Add(f, Const(0)) => f
        Add(Const(a), Const(b)) => Const(a + b)
        // x + (-y) = x - y
        Add(f, Neg(g)) => Sub(f, g)
        // (-x) + y = y - x  
        Add(Neg(f), g) => Sub(g, f)
        // x + x = 2x
        // Add(f, g) if f = g => Mul(Const(2), f)  -- can't use guards with =
        
        // ===== Subtraction rules =====
        Sub(f, Const(0)) => f
        Sub(Const(0), f) => Neg(f)
        Sub(Const(a), Const(b)) => Const(a - b)
        // x - (-y) = x + y
        Sub(f, Neg(g)) => Add(f, g)
        // x - x = 0 (can't check equality, skip)
        
        // ===== Multiplication rules =====
        Mul(Const(0), _) => Const(0)
        Mul(_, Const(0)) => Const(0)
        Mul(Const(1), f) => f
        Mul(f, Const(1)) => f
        // Note: Const(-1) pattern doesn't parse; handle via Neg(Const(1)) instead
        Mul(Neg(Const(1)), f) => Neg(f)
        Mul(f, Neg(Const(1))) => Neg(f)
        Mul(Const(a), Const(b)) => Const(a * b)
        // (-x) * y = -(x * y)
        Mul(Neg(f), g) => Neg(Mul(f, g))
        // x * (-y) = -(x * y)
        Mul(f, Neg(g)) => Neg(Mul(f, g))
        // x * x = x²
        // Mul(f, g) if f = g => Pow(f, Const(2))  -- can't use guards
        
        // ===== Division rules =====
        Div(Const(0), _) => Const(0)
        Div(f, Const(1)) => f
        Div(Const(a), Const(b)) => Const(a / b)
        // x / (-y) = -(x / y)
        Div(f, Neg(g)) => Neg(Div(f, g))
        // (-x) / y = -(x / y)
        Div(Neg(f), g) => Neg(Div(f, g))
        
        // ===== Power rules =====
        Pow(_, Const(0)) => Const(1)
        Pow(f, Const(1)) => f
        Pow(Const(0), _) => Const(0)
        Pow(Const(1), _) => Const(1)
        // √x² = x (for positive x, which we assume)
        Pow(Sqrt(f), Const(2)) => f
        // (x²)^(1/2) = x
        Sqrt(Pow(f, Const(2))) => f
        
        // ===== Negation rules =====
        Neg(Const(0)) => Const(0)
        Neg(Neg(f)) => f
        Neg(Const(a)) => Const(0 - a)
        
        // ===== Trig identities =====
        Sin(Const(0)) => Const(0)
        Cos(Const(0)) => Const(1)
        
        // ===== Exp/Log identities =====
        Exp(Const(0)) => Const(1)
        Ln(Const(1)) => Const(0)
        // e^(ln(x)) = x
        Exp(Ln(f)) => f
        // ln(e^x) = x
        Ln(Exp(f)) => f
        
        // ===== Sqrt identities =====
        Sqrt(Const(0)) => Const(0)
        Sqrt(Const(1)) => Const(1)
        // √(x²) = x (assuming positive)
        Sqrt(Pow(f, Const(2))) => f
        
        // No rule matched - return as-is
        _ => e
    }

// =============================================================================
// Convenience: differentiate and simplify
// =============================================================================

define D_simplified(e, x) = simplify(diff(e, x))

// =============================================================================
// Example Expressions
// =============================================================================

// x² 
define x_squared = Pow(Var("x"), Const(2))

// x³
define x_cubed = Pow(Var("x"), Const(3))

// sin(x)
define sin_x = Sin(Var("x"))

// e^x
define exp_x = Exp(Var("x"))

// x² + 2x + 1
define quadratic = Add(Add(Pow(Var("x"), Const(2)), Mul(Const(2), Var("x"))), Const(1))

// sin(x²)
define sin_x_squared = Sin(Pow(Var("x"), Const(2)))

// e^(x²)
define exp_x_squared = Exp(Pow(Var("x"), Const(2)))

// ln(x)
define ln_x = Ln(Var("x"))

// √x
define sqrt_x = Sqrt(Var("x"))

// x/y
define x_over_y = Div(Var("x"), Var("y"))

