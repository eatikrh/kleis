// ============================================
// Kleis Standard Library - Functional Tensors
// Tensor operations as pure Kleis functions
// ============================================
//
// This module represents tensors as nested lists and provides
// operations needed for differential geometry.
//
// ADR-026: Self-Hosted Differential Forms
// All operations are pure Kleis - no Rust builtins.
//
// Tensor Representation:
//   Rank-0 (scalar): just a number
//   Rank-1 (vector): [a, b, c]
//   Rank-2 (matrix): [[a, b], [c, d]]
//   Rank-n: n-deep nesting

import "stdlib/func_core.kleis"
import "stdlib/combinatorics.kleis"

// ============================================
// Tensor Access
// ============================================

// Get component at multi-index [i, j, k, ...]
define tensor_get(T, indices) = match indices {
    Nil => T
    | Cons(i, rest) => tensor_get(list_get(T, i), rest)
}

// Get dimension along axis
define tensor_dim(T, axis) = 
    if axis = 0 then length(T)
    else match T {
        Nil => 0
        | Cons(first, _) => tensor_dim(first, axis - 1)
    }

// Get all dimensions as a list
define tensor_shape(T) = tensor_shape_helper(T, 0)

define tensor_shape_helper(T, depth) = match T {
    Nil => Nil
    | Cons(first, _) => 
        if is_list(first) then Cons(length(T), tensor_shape_helper(first, depth + 1))
        else Cons(length(T), Nil)
}

// Check if value is a list (rough heuristic: try matching)
define is_list(x) = match x {
    Nil => True
    | Cons(_, _) => True
    | _ => False
}

// ============================================
// Tensor Construction
// ============================================

// Build tensor from shape and function: f(indices) → value
define tensor_build(shape, f) = match shape {
    Nil => f(Nil)
    | Cons(n, rest) => map(λ i . tensor_build(rest, λ js . f(Cons(i, js))), range(n))
}

// Zero tensor of given shape
define tensor_zeros(shape) = tensor_build(shape, λ _ . 0)

// ============================================
// Tensor Arithmetic
// ============================================

// Element-wise addition
define tensor_add(A, B) = match A {
    Nil => Nil
    | Cons(a, at) => match B {
        Nil => A
        | Cons(b, bt) => 
            if is_list(a) then Cons(tensor_add(a, b), tensor_add(at, bt))
            else Cons(a + b, tensor_add(at, bt))
    }
}

// Element-wise subtraction
define tensor_sub(A, B) = match A {
    Nil => Nil
    | Cons(a, at) => match B {
        Nil => A
        | Cons(b, bt) => 
            if is_list(a) then Cons(tensor_sub(a, b), tensor_sub(at, bt))
            else Cons(a - b, tensor_sub(at, bt))
    }
}

// Scalar multiplication
define tensor_scale(c, T) = match T {
    Nil => Nil
    | Cons(h, t) =>
        if is_list(h) then Cons(tensor_scale(c, h), tensor_scale(c, t))
        else Cons(c * h, tensor_scale(c, t))
}

// Sum of tensors in a list
define tensor_sum(tensors) = match tensors {
    Nil => Nil  // or tensor_zeros for proper typing
    | Cons(first, rest) => fold(tensor_add, first, rest)
}

// ============================================
// Tensor Product (Outer Product)
// ============================================

// Tensor product of two vectors: [a, b] ⊗ [x, y] = [[ax, ay], [bx, by]]
define tensor_product(A, B) = map(λ a . map(λ b . a * b, B), A)

// General tensor product for higher ranks (TODO: generalize)
// For now, works for rank-1 ⊗ rank-1 → rank-2

// ============================================
// Index Permutation
// ============================================

// Permute indices of a rank-2 tensor (transpose)
define transpose(M) = 
    let rows = length(M) in
    let cols = tensor_dim(M, 1) in
    tensor_build(Cons(cols, Cons(rows, Nil)), 
                 λ ij . tensor_get(M, Cons(list_get(ij, 1), Cons(list_get(ij, 0), Nil))))

// Permute indices of a general tensor according to permutation
// permute_indices(T, [1, 0]) transposes a matrix
// permute_indices(T, [2, 0, 1]) cycles indices of a rank-3 tensor
define permute_indices(T, perm) =
    let shape = tensor_shape(T) in
    let new_shape = perm_apply(perm_inverse(perm), shape) in
    tensor_build(new_shape, λ new_idx . tensor_get(T, perm_apply(perm, new_idx)))

// ============================================
// Antisymmetrization (Key for Wedge Product)
// ============================================

// Antisymmetrize a tensor over all indices
// A[i,j,...] = (1/n!) Σ_σ sign(σ) T[σ(i), σ(j), ...]
define antisymmetrize(T) =
    let n = length(tensor_shape(T)) in
    let perms = all_permutations(n) in
    let terms = map(λ σ . tensor_scale(perm_sign(σ), permute_indices(T, σ)), perms) in
    tensor_scale(1 / factorial(n), tensor_sum(terms))

// Symmetrize a tensor over all indices
// S[i,j,...] = (1/n!) Σ_σ T[σ(i), σ(j), ...]
define symmetrize(T) =
    let n = length(tensor_shape(T)) in
    let perms = all_permutations(n) in
    let terms = map(λ σ . permute_indices(T, σ), perms) in
    tensor_scale(1 / factorial(n), tensor_sum(terms))

// ============================================
// Wedge Product
// ============================================

// Wedge product of two 1-forms (vectors)
// α ∧ β = α ⊗ β - β ⊗ α (antisymmetrized tensor product)
define wedge(alpha, beta) = 
    antisymmetrize(tensor_product(alpha, beta))

// Explicit wedge for 1-forms (simpler formula)
define wedge_1_1(alpha, beta) =
    tensor_sub(tensor_product(alpha, beta), tensor_product(beta, alpha))

// ============================================
// Contraction (Trace-like operations)
// ============================================

// Contract indices i and j of a tensor
// For matrix: contract(M, 0, 1) = trace(M)
define contract(T, i, j) =
    let n = tensor_dim(T, i) in  // Assume dims are equal
    sum(map(λ k . contract_at(T, i, j, k), range(n)))

// Helper: sum T[..., k, ..., k, ...] with k at positions i and j
define contract_at(T, i, j, k) =
    // Simplified for rank-2: just M[k][k]
    tensor_get(T, Cons(k, Cons(k, Nil)))

// Trace of a matrix
define trace(M) = sum(map(λ i . tensor_get(M, Cons(i, Cons(i, Nil))), range(length(M))))

// ============================================
// Examples / Tests
// ============================================

// Test vector
define vec_a = Cons(1, Cons(2, Nil))
define vec_b = Cons(3, Cons(4, Nil))

// Test matrix
define mat_test = Cons(Cons(1, Cons(2, Nil)), Cons(Cons(3, Cons(4, Nil)), Nil))

example "tensor_get vector" {
    tensor_get(vec_a, Cons(1, Nil)) = 2
}

example "tensor_get matrix" {
    tensor_get(mat_test, Cons(1, Cons(0, Nil))) = 3
}

example "tensor_product" {
    tensor_product(Cons(1, Cons(2, Nil)), Cons(3, Cons(4, Nil))) = 
        Cons(Cons(3, Cons(4, Nil)), Cons(Cons(6, Cons(8, Nil)), Nil))
}

example "tensor_add" {
    tensor_add(vec_a, vec_b) = Cons(4, Cons(6, Nil))
}

example "tensor_scale" {
    tensor_scale(2, vec_a) = Cons(2, Cons(4, Nil))
}

example "trace" {
    trace(mat_test) = 5
}

example "transpose" {
    transpose(Cons(Cons(1, Cons(2, Nil)), Cons(Cons(3, Cons(4, Nil)), Nil))) = 
        Cons(Cons(1, Cons(3, Nil)), Cons(Cons(2, Cons(4, Nil)), Nil))
}

example "wedge antisymmetric" {
    // α ∧ β = -(β ∧ α) for 1-forms
    wedge_1_1(vec_a, vec_b) = tensor_scale(negate(1), wedge_1_1(vec_b, vec_a))
}

example "wedge self zero" {
    // α ∧ α = 0
    wedge_1_1(vec_a, vec_a) = Cons(Cons(0, Cons(0, Nil)), Cons(Cons(0, Cons(0, Nil)), Nil))
}

