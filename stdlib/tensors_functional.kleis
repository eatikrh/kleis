// ============================================
// Kleis Standard Library - Functional Tensors
// Tensor operations as pure Kleis functions
// ============================================
//
// This module represents tensors as nested lists and provides
// operations needed for differential geometry.
//
// ADR-026: Self-Hosted Differential Forms
// All operations are pure Kleis - no Rust builtins.
//
// Tensor Representation:
//   Rank-0 (scalar): just a number
//   Rank-1 (vector): [a, b, c]
//   Rank-2 (matrix): [[a, b], [c, d]]
//   Rank-n: n-deep nesting

import "stdlib/func_core.kleis"
import "stdlib/combinatorics.kleis"

// ============================================
// Tensor Access
// ============================================

// Get component at multi-index [i, j, k, ...]
define tensor_get(T, indices) = match indices {
    Nil => T
    | Cons(i, rest) => tensor_get(list_get(T, i), rest)
}

// Get dimension along axis
define tensor_dim(T, axis) = 
    if axis = 0 then length(T)
    else match T {
        Nil => 0
        | Cons(first, _) => tensor_dim(first, axis - 1)
    }

// Get all dimensions as a list
define tensor_shape(T) = tensor_shape_helper(T, 0)

define tensor_shape_helper(T, depth) = match T {
    Nil => Nil
    | Cons(first, _) => 
        if is_list(first) then Cons(length(T), tensor_shape_helper(first, depth + 1))
        else Cons(length(T), Nil)
}

// Check if value is a list (rough heuristic: try matching)
define is_list(x) = match x {
    Nil => True
    | Cons(_, _) => True
    | _ => False
}

// ============================================
// Tensor Construction
// ============================================

// Build tensor from shape and function: f(indices) → value
define tensor_build(shape, f) = match shape {
    Nil => f(Nil)
    | Cons(n, rest) => map(λ i . tensor_build(rest, λ js . f(Cons(i, js))), range(n))
}

// Zero tensor of given shape
define tensor_zeros(shape) = tensor_build(shape, λ _ . 0)

// ============================================
// Tensor Arithmetic
// ============================================

// Element-wise addition
define tensor_add(A, B) = match A {
    Nil => Nil
    | Cons(a, at) => match B {
        Nil => A
        | Cons(b, bt) => 
            if is_list(a) then Cons(tensor_add(a, b), tensor_add(at, bt))
            else Cons(a + b, tensor_add(at, bt))
    }
}

// Element-wise subtraction
define tensor_sub(A, B) = match A {
    Nil => Nil
    | Cons(a, at) => match B {
        Nil => A
        | Cons(b, bt) => 
            if is_list(a) then Cons(tensor_sub(a, b), tensor_sub(at, bt))
            else Cons(a - b, tensor_sub(at, bt))
    }
}

// Scalar multiplication
define tensor_scale(c, T) = match T {
    Nil => Nil
    | Cons(h, t) =>
        if is_list(h) then Cons(tensor_scale(c, h), tensor_scale(c, t))
        else Cons(c * h, tensor_scale(c, t))
}

// Sum of tensors in a list
define tensor_sum(tensors) = match tensors {
    Nil => Nil  // or tensor_zeros for proper typing
    | Cons(first, rest) => fold(tensor_add, first, rest)
}

// ============================================
// Tensor Product (Outer Product)
// ============================================

// Tensor product of two vectors: [a, b] ⊗ [x, y] = [[ax, ay], [bx, by]]
define tensor_product(A, B) = map(λ a . map(λ b . a * b, B), A)

// General tensor product for higher ranks (TODO: generalize)
// For now, works for rank-1 ⊗ rank-1 → rank-2

// ============================================
// Index Permutation
// ============================================

// Permute indices of a rank-2 tensor (transpose)
define transpose(M) = 
    let rows = length(M) in
    let cols = tensor_dim(M, 1) in
    tensor_build(Cons(cols, Cons(rows, Nil)), 
                 λ ij . tensor_get(M, Cons(list_get(ij, 1), Cons(list_get(ij, 0), Nil))))

// Permute indices of a general tensor according to permutation
// permute_indices(T, [1, 0]) transposes a matrix
// permute_indices(T, [2, 0, 1]) cycles indices of a rank-3 tensor
define permute_indices(T, perm) =
    let shape = tensor_shape(T) in
    let new_shape = perm_apply(perm_inverse(perm), shape) in
    tensor_build(new_shape, λ new_idx . tensor_get(T, perm_apply(perm, new_idx)))

// ============================================
// Antisymmetrization (Key for Wedge Product)
// ============================================

// Antisymmetrize a tensor over all indices
// A[i,j,...] = (1/n!) Σ_σ sign(σ) T[σ(i), σ(j), ...]
define antisymmetrize(T) =
    let n = length(tensor_shape(T)) in
    let perms = all_permutations(n) in
    let terms = map(λ σ . tensor_scale(perm_sign(σ), permute_indices(T, σ)), perms) in
    tensor_scale(1 / factorial(n), tensor_sum(terms))

// Symmetrize a tensor over all indices
// S[i,j,...] = (1/n!) Σ_σ T[σ(i), σ(j), ...]
define symmetrize(T) =
    let n = length(tensor_shape(T)) in
    let perms = all_permutations(n) in
    let terms = map(λ σ . permute_indices(T, σ), perms) in
    tensor_scale(1 / factorial(n), tensor_sum(terms))

// ============================================
// Wedge Product
// ============================================

// Wedge product of two 1-forms (vectors)
// α ∧ β = α ⊗ β - β ⊗ α (antisymmetrized tensor product)
define wedge(alpha, beta) = 
    antisymmetrize(tensor_product(alpha, beta))

// Explicit wedge for 1-forms (simpler formula)
define wedge_1_1(alpha, beta) =
    tensor_sub(tensor_product(alpha, beta), tensor_product(beta, alpha))

// ============================================
// Contraction (Trace-like operations)
// ============================================

// Contract indices i and j of a tensor
// For matrix: contract(M, 0, 1) = trace(M)
define contract(T, i, j) =
    let n = tensor_dim(T, i) in  // Assume dims are equal
    sum(map(λ k . contract_at(T, i, j, k), range(n)))

// Helper: sum T[..., k, ..., k, ...] with k at positions i and j
define contract_at(T, i, j, k) =
    // Simplified for rank-2: just M[k][k]
    tensor_get(T, Cons(k, Cons(k, Nil)))

// Trace of a matrix
define trace(M) = sum(map(λ i . tensor_get(M, Cons(i, Cons(i, Nil))), range(length(M))))

// ============================================
// Examples / Tests
// ============================================

// Test vector
define vec_a = [1, 2]
define vec_b = [3, 4]

// Test matrix
define mat_test = [[1, 2], [3, 4]]

example "tensor_get vector" {
    tensor_get(vec_a, [1]) = 2
}

example "tensor_get matrix" {
    tensor_get(mat_test, [1, 0]) = 3
}

example "tensor_product" {
    tensor_product([1, 2], [3, 4]) = [[3, 4], [6, 8]]
}

example "tensor_add" {
    tensor_add(vec_a, vec_b) = [4, 6]
}

example "tensor_scale" {
    tensor_scale(2, vec_a) = [2, 4]
}

example "trace" {
    trace(mat_test) = 5
}

example "transpose" {
    transpose([[1, 2], [3, 4]]) = [[1, 3], [2, 4]]
}

example "wedge antisymmetric" {
    // α ∧ β = -(β ∧ α) for 1-forms
    wedge_1_1(vec_a, vec_b) = tensor_scale(negate(1), wedge_1_1(vec_b, vec_a))
}

example "wedge self zero" {
    // α ∧ α = 0
    wedge_1_1(vec_a, vec_a) = [[0, 0], [0, 0]]
}

// ============================================
// NUMERICAL EXAMPLE: Parallelogram Area
// ============================================
// From linear algebra / differential geometry textbooks:
//
// The wedge product of two vectors gives the SIGNED AREA
// of the parallelogram they span.
//
// For u = [a, b] and v = [c, d]:
//   u ∧ v = [[0, ad-bc], [bc-ad, 0]]
//   Area = |ad - bc| = determinant!

define u_para = [3, 1]
define v_para = [1, 4]

example "parallelogram area = determinant" {
    // u = [3,1], v = [1,4]
    // Area = 3*4 - 1*1 = 11
    tensor_get(wedge_1_1(u_para, v_para), [0, 1]) = 11
}

example "unit square area = 1" {
    tensor_get(wedge_1_1([1, 0], [0, 1]), [0, 1]) = 1
}

example "rectangle area 3x2 = 6" {
    tensor_get(wedge_1_1([3, 0], [0, 2]), [0, 1]) = 6
}

// ============================================
// PHYSICS EXAMPLE: Electromagnetic Field Tensor
// ============================================
// From Jackson's "Classical Electrodynamics"
//
// F is a 4x4 antisymmetric tensor:
//   F_μν = |  0   -E_x  -E_y  -E_z |
//          | E_x   0   -B_z   B_y |
//          | E_y  B_z   0    -B_x |
//          | E_z -B_y   B_x   0   |
//
// Example: E = [1, 0, 0], B = [0, 0, 1]

define em_field_tensor = [
    [0, negate(1), 0, 0],
    [1, 0, 0, 0],
    [0, 0, 0, negate(1)],
    [0, 0, 1, 0]
]

example "EM tensor antisymmetric F_01 = -F_10" {
    tensor_get(em_field_tensor, [0, 1]) = negate(tensor_get(em_field_tensor, [1, 0]))
}

example "EM tensor diagonal zero" {
    tensor_get(em_field_tensor, [0, 0]) = 0
}

example "EM tensor E_x = 1" {
    tensor_get(em_field_tensor, [1, 0]) = 1
}

example "EM tensor trace = 0" {
    trace(em_field_tensor) = 0
}

