// Kleis Standard Library - Matrices
// Defines matrix structures and operations following ADR-016
//
// Matrices are parametric over:
//   m: number of rows (Nat)
//   n: number of columns (Nat)
//   T: element type (typically ℝ or ℂ)

/* Matrix Structure - TYPE constructor
 * 
 * Matrix(m, n, T) is a TYPE that represents m×n matrices with elements of type T.
 * 
 * NOTE (ADR-020): This is the TYPE constructor, not a value constructor.
 * To create matrix values, use the 'matrix' operation below.
 */
structure Matrix(m: Nat, n: Nat, T) {
    operation transpose : Matrix(m, n, T) → Matrix(n, m, T)
}

// Implementation for Matrix operations
implements Matrix(m, n, ℝ) {
    operation transpose = builtin_transpose
}

/* Matrix Value Constructor
 * 
 * Creates matrix values from elements.
 * Dimensions (m, n) must be provided by type annotation or inferred from context.
 * 
 * Example: matrix(1, 2, 3, 4) : Matrix(2, 2, ℝ)
 */
structure MatrixConstructor(m: Nat, n: Nat, T) {
    operation matrix : Matrix(m, n, T)
}

implements MatrixConstructor(m, n, ℝ) {
    operation matrix = builtin_matrix_constructor
}

/* Matrix Addition/Subtraction - Only when dimensions match
 *
 * CRITICAL: Both arguments must have the SAME dimensions (m, n).
 * This constraint is enforced by the type signature - the SignatureInterpreter
 * will fail to unify if dimensions don't match.
 *
 * Example:
 *   matrix_add(Matrix(3,3), Matrix(3,3)) → OK, returns Matrix(3,3)
 *   matrix_add(Matrix(3,3), Matrix(2,2)) → TYPE ERROR: dimensions don't unify
 *
 * Note: Generic 'plus' and 'minus' from Arithmetic are also available,
 * but type inference delegates to these specialized operations for matrices
 * to enforce dimension matching.
 */
structure MatrixAddable(m: Nat, n: Nat, T) {
    // Specialized operations with dimension constraints
    operation matrix_add : Matrix(m, n, T) → Matrix(m, n, T) → Matrix(m, n, T)
    operation matrix_sub : Matrix(m, n, T) → Matrix(m, n, T) → Matrix(m, n, T)
}

implements MatrixAddable(m, n, ℝ) {
    operation matrix_add = builtin_matrix_add
    operation matrix_sub = builtin_matrix_sub
}

/* Matrix Multiplication - (m×n) · (n×p) → (m×p) */
structure MatrixMultipliable(m: Nat, n: Nat, p: Nat, T) {
    operation multiply : Matrix(m, n, T) → Matrix(n, p, T) → Matrix(m, p, T)
}

implements MatrixMultipliable(m, n, p, ℝ) {
    operation multiply = builtin_matrix_multiply
}

/* Square Matrices - Additional operations for n×n matrices */
structure SquareMatrix(n: Nat, T) {
    operation det : Matrix(n, n, T) → T
    operation trace : Matrix(n, n, T) → T
    operation identity : Matrix(n, n, T)
}

implements SquareMatrix(n, ℝ) {
    operation det = builtin_determinant
    operation trace = builtin_trace
    operation identity = builtin_identity
}

/* Block Matrix Support
 * 
 * Block matrices (matrices of matrices) work automatically through polymorphism!
 * 
 * Example: A 2×2 block matrix where each block is 3×3:
 *   [[A₁₁, A₁₂],     where each Aᵢⱼ is a 3×3 matrix
 *    [A₂₁, A₂₂]]
 * 
 * Type: Matrix(2, 2, Matrix(3, 3, ℝ))
 * 
 * The existing polymorphic operations work for block matrices at ANY depth:
 *   - multiply: works when T = ℝ (regular) OR T = Matrix(k, l, T) (recursive!)
 *   - add: works when T = ℝ OR T = Matrix(k, l, T)
 *   - transpose: works when T = ℝ OR T = Matrix(k, l, T)
 * 
 * Examples:
 *   - Regular: Matrix(2, 2, ℝ)
 *   - 1-level: Matrix(2, 2, Matrix(3, 3, ℝ))
 *   - 2-level: Matrix(2, 2, Matrix(3, 3, Matrix(4, 4, ℝ)))
 *   - N-level: Matrix(... Matrix(... Matrix(...) ...) ...)
 * 
 * No special block operations needed - parametric polymorphism handles infinite nesting!
 */

/* Conjugate Transpose (Dagger / Hermitian Adjoint)
 * 
 * For complex matrices: A† = transpose(conj(A))
 * For real matrices: A† = transpose(A)
 * 
 * Postfix syntax: A†
 * Function syntax: dagger(A)
 */
structure HermitianAdjoint(m: Nat, n: Nat, T) {
    operation dagger : Matrix(m, n, T) → Matrix(n, m, T)
}

// For real matrices, dagger = transpose
implements HermitianAdjoint(m, n, ℝ) {
    operation dagger = builtin_transpose
}

/* Dagger Axioms (for symbolic reasoning)
 * 
 * These axioms define conjugate transpose semantics for Z3 verification:
 * 
 *   dagger_real       : ∀(A : Matrix(m, n, ℝ)). dagger(A) = transpose(A)
 *   dagger_involution : ∀(A : Matrix(m, n, T)). dagger(dagger(A)) = A
 *   dagger_sum        : ∀(A B : Matrix(m, n, T)). dagger(A + B) = dagger(A) + dagger(B)
 *   dagger_product    : ∀(A : Matrix(m, n, T)) (B : Matrix(n, p, T)). dagger(A · B) = dagger(B) · dagger(A)
 *   dagger_scalar     : ∀(c : T) (A : Matrix(m, n, T)). dagger(c · A) = conj(c) · dagger(A)
 * 
 * Hermitian matrix: A = A†
 *   hermitian_def     : ∀(A : Matrix(n, n, T)). hermitian(A) ⟺ A = dagger(A)
 * 
 * Unitary matrix: U† · U = I
 *   unitary_def       : ∀(U : Matrix(n, n, T)). unitary(U) ⟺ dagger(U) · U = identity(n)
 * 
 * Note: These are loaded into Z3 via capabilities.toml, not parsed as stdlib.
 */

/* ============================================
 * LEGACY MATRIX CONSTRUCTORS - REMOVED
 * ============================================
 * 
 * Old operations like matrix2x2, matrix2x3, pmatrix2x2 have been removed.
 * Use the parametric Matrix constructor instead:
 * 
 * Before: matrix2x2(a, b, c, d)
 * Now:    Matrix(2, 2, [a, b, c, d])
 * 
 * This provides:
 * - Type polymorphism (works for any element type T)
 * - Arbitrary dimensions (not just 2x2, 3x3)
 * - Consistent syntax across all matrix operations
 */
