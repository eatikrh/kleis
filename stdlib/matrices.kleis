// Kleis Standard Library - Matrices
// Defines matrix structures and operations following ADR-016
//
// Matrices are parametric over:
//   m: number of rows (Nat)
//   n: number of columns (Nat)
//   T: element type (typically ℝ or ℂ)

/* Matrix Structure - TYPE constructor
 * 
 * Matrix(m, n, T) is a TYPE that represents m×n matrices with elements of type T.
 * 
 * NOTE (ADR-020): This is the TYPE constructor, not a value constructor.
 * To create matrix values, use the 'matrix' operation below.
 */
structure Matrix(m: Nat, n: Nat, T) {
    operation transpose : Matrix(m, n, T) → Matrix(n, m, T)
}

// Implementation for Matrix operations
implements Matrix(m, n, ℝ) {
    operation transpose = builtin_transpose
}

/* Matrix Value Constructor
 * 
 * Creates matrix values from elements.
 * Dimensions (m, n) must be provided by type annotation or inferred from context.
 * 
 * Example: matrix(1, 2, 3, 4) : Matrix(2, 2, ℝ)
 */
structure MatrixConstructor(m: Nat, n: Nat, T) {
    operation matrix : Matrix(m, n, T)
}

implements MatrixConstructor(m, n, ℝ) {
    operation matrix = builtin_matrix_constructor
}

/* Matrix Addition/Subtraction - Only when dimensions match
 *
 * CRITICAL: Both arguments must have the SAME dimensions (m, n).
 * This constraint is enforced by the type signature - the SignatureInterpreter
 * will fail to unify if dimensions don't match.
 *
 * Example:
 *   matrix_add(Matrix(3,3), Matrix(3,3)) → OK, returns Matrix(3,3)
 *   matrix_add(Matrix(3,3), Matrix(2,2)) → TYPE ERROR: dimensions don't unify
 *
 * Note: Generic 'plus' and 'minus' from Arithmetic are also available,
 * but type inference delegates to these specialized operations for matrices
 * to enforce dimension matching.
 */
structure MatrixAddable(m: Nat, n: Nat, T) {
    // Specialized operations with dimension constraints
    operation matrix_add : Matrix(m, n, T) → Matrix(m, n, T) → Matrix(m, n, T)
    operation matrix_sub : Matrix(m, n, T) → Matrix(m, n, T) → Matrix(m, n, T)
}

implements MatrixAddable(m, n, ℝ) {
    operation matrix_add = builtin_matrix_add
    operation matrix_sub = builtin_matrix_sub
}

/* Matrix Multiplication - (m×n) · (n×p) → (m×p) */
structure MatrixMultipliable(m: Nat, n: Nat, p: Nat, T) {
    operation multiply : Matrix(m, n, T) → Matrix(n, p, T) → Matrix(m, p, T)
}

implements MatrixMultipliable(m, n, p, ℝ) {
    operation multiply = builtin_matrix_multiply
}

/* Square Matrices - Additional operations for n×n matrices */
structure SquareMatrix(n: Nat, T) {
    operation det : Matrix(n, n, T) → T
    operation trace : Matrix(n, n, T) → T
    operation identity : Matrix(n, n, T)
}

implements SquareMatrix(n, ℝ) {
    operation det = builtin_determinant
    operation trace = builtin_trace
    operation identity = builtin_identity
}

/* Block Matrix Support
 * 
 * Block matrices (matrices of matrices) work automatically through polymorphism!
 * 
 * Example: A 2×2 block matrix where each block is 3×3:
 *   [[A₁₁, A₁₂],     where each Aᵢⱼ is a 3×3 matrix
 *    [A₂₁, A₂₂]]
 * 
 * Type: Matrix(2, 2, Matrix(3, 3, ℝ))
 * 
 * The existing polymorphic operations work for block matrices at ANY depth:
 *   - multiply: works when T = ℝ (regular) OR T = Matrix(k, l, T) (recursive!)
 *   - add: works when T = ℝ OR T = Matrix(k, l, T)
 *   - transpose: works when T = ℝ OR T = Matrix(k, l, T)
 * 
 * Examples:
 *   - Regular: Matrix(2, 2, ℝ)
 *   - 1-level: Matrix(2, 2, Matrix(3, 3, ℝ))
 *   - 2-level: Matrix(2, 2, Matrix(3, 3, Matrix(4, 4, ℝ)))
 *   - N-level: Matrix(... Matrix(... Matrix(...) ...) ...)
 * 
 * No special block operations needed - parametric polymorphism handles infinite nesting!
 */

/* Conjugate Transpose (Dagger / Hermitian Adjoint)
 * 
 * For complex matrices: A† = transpose(conj(A))
 * For real matrices: A† = transpose(A)
 * 
 * Postfix syntax: A†
 * Function syntax: dagger(A)
 */
structure HermitianAdjoint(m: Nat, n: Nat, T) {
    operation dagger : Matrix(m, n, T) → Matrix(n, m, T)
}

// For real matrices, dagger = transpose
implements HermitianAdjoint(m, n, ℝ) {
    operation dagger = builtin_transpose
}

/* Dagger Axioms (for symbolic reasoning)
 * 
 * These axioms define conjugate transpose semantics for Z3 verification:
 * 
 *   dagger_real       : ∀(A : Matrix(m, n, ℝ)). dagger(A) = transpose(A)
 *   dagger_involution : ∀(A : Matrix(m, n, T)). dagger(dagger(A)) = A
 *   dagger_sum        : ∀(A B : Matrix(m, n, T)). dagger(A + B) = dagger(A) + dagger(B)
 *   dagger_product    : ∀(A : Matrix(m, n, T)) (B : Matrix(n, p, T)). dagger(A · B) = dagger(B) · dagger(A)
 *   dagger_scalar     : ∀(c : T) (A : Matrix(m, n, T)). dagger(c · A) = conj(c) · dagger(A)
 * 
 * Hermitian matrix: A = A†
 *   hermitian_def     : ∀(A : Matrix(n, n, T)). hermitian(A) ⟺ A = dagger(A)
 * 
 * Unitary matrix: U† · U = I
 *   unitary_def       : ∀(U : Matrix(n, n, T)). unitary(U) ⟺ dagger(U) · U = identity(n)
 * 
 * Note: These are loaded into Z3 via capabilities.toml, not parsed as stdlib.
 */

/* ============================================
 * COMPLEX MATRICES AS PRODUCT TYPE (ℂ ≅ ℝ×ℝ)
 * ============================================
 * 
 * A complex matrix M = A + B·i is represented as the pair (A, B)
 * where A, B : Matrix(m, n, ℝ).
 * 
 * This representation:
 *   - Avoids native complex arithmetic
 *   - Works with real LAPACK routines
 *   - Keeps Z3/SMT solvers in real arithmetic
 *   - Matches control theory practice (H∞, μ-analysis)
 */

/* Type Definition (specification - parser support pending)
 *
 * type ComplexMatrix(m: Nat, n: Nat) = (Matrix(m, n, ℝ), Matrix(m, n, ℝ))
 *
 * Structures for complex matrix operations:
 *
 * structure ComplexMatrixOps(m: Nat, n: Nat) {
 *     operation complex_zero : ComplexMatrix(m, n)
 *     operation as_complex : Matrix(m, n, ℝ) → ComplexMatrix(m, n)
 *     operation as_imaginary : Matrix(m, n, ℝ) → ComplexMatrix(m, n)
 *     operation real_part : ComplexMatrix(m, n) → Matrix(m, n, ℝ)
 *     operation imag_part : ComplexMatrix(m, n) → Matrix(m, n, ℝ)
 *     operation cmat_conj : ComplexMatrix(m, n) → ComplexMatrix(m, n)
 *     operation cmat_transpose : ComplexMatrix(m, n) → ComplexMatrix(n, m)
 *     operation cmat_dagger : ComplexMatrix(m, n) → ComplexMatrix(n, m)
 * }
 *
 * structure ComplexSquareMatrixOps(n: Nat) {
 *     operation complex_eye : ComplexMatrix(n, n)
 *     operation cmat_trace : ComplexMatrix(n, n) → (ℝ, ℝ)
 * }
 *
 * structure ComplexMatrixArithmetic(m: Nat, n: Nat) {
 *     operation cmat_add : ComplexMatrix(m, n) → ComplexMatrix(m, n) → ComplexMatrix(m, n)
 *     operation cmat_sub : ComplexMatrix(m, n) → ComplexMatrix(m, n) → ComplexMatrix(m, n)
 *     operation cmat_scalar_real : ℝ → ComplexMatrix(m, n) → ComplexMatrix(m, n)
 *     operation cmat_scalar_complex : (ℝ, ℝ) → ComplexMatrix(m, n) → ComplexMatrix(m, n)
 * }
 *
 * structure ComplexMatrixMultiply(m: Nat, n: Nat, p: Nat) {
 *     operation cmat_mul : ComplexMatrix(m, n) → ComplexMatrix(n, p) → ComplexMatrix(m, p)
 * }
 *
 * structure ComplexMatrixGram(m: Nat, n: Nat) {
 *     operation cmat_gram : ComplexMatrix(m, n) → ComplexMatrix(n, n)
 * }
 *
 * structure Realification(n: Nat) {
 *     operation realify : ComplexMatrix(n, n) → Matrix(2*n, 2*n, ℝ)
 *     operation complexify : Matrix(2*n, 2*n, ℝ) → ComplexMatrix(n, n)
 * }
 */

/* Complex Matrix Axioms
 * 
 * ═══════════════════════════════════════════════════════════════════
 * CONSTRUCTORS
 * ═══════════════════════════════════════════════════════════════════
 * 
 * complex_zero(m, n) = (zeros(m, n), zeros(m, n))
 * complex_eye(n) = (eye(n), zeros(n, n))
 * as_complex(A) = (A, zeros(m, n))
 * as_imaginary(B) = (zeros(m, n), B)
 * 
 * ═══════════════════════════════════════════════════════════════════
 * EXTRACTORS
 * ═══════════════════════════════════════════════════════════════════
 * 
 * real_part((A, B)) = A
 * imag_part((A, B)) = B
 * 
 * ═══════════════════════════════════════════════════════════════════
 * ARITHMETIC AXIOMS
 * ═══════════════════════════════════════════════════════════════════
 * 
 * cmat_add:
 *   ∀(A₁ B₁ A₂ B₂ : Matrix(m, n, ℝ)).
 *     (A₁, B₁) + (A₂, B₂) = (A₁ + A₂, B₁ + B₂)
 * 
 * cmat_sub:
 *   ∀(A₁ B₁ A₂ B₂ : Matrix(m, n, ℝ)).
 *     (A₁, B₁) - (A₂, B₂) = (A₁ - A₂, B₁ - B₂)
 * 
 * cmat_mul (the key axiom):
 *   ∀(A₁ B₁ : Matrix(m, n, ℝ)) (A₂ B₂ : Matrix(n, p, ℝ)).
 *     (A₁, B₁) · (A₂, B₂) = (A₁·A₂ - B₁·B₂, A₁·B₂ + B₁·A₂)
 * 
 * cmat_scalar_real:
 *   ∀(r : ℝ) (A B : Matrix(m, n, ℝ)).
 *     r · (A, B) = (r·A, r·B)
 * 
 * cmat_scalar_complex:
 *   ∀(x y : ℝ) (A B : Matrix(m, n, ℝ)).
 *     (x, y) · (A, B) = (x·A - y·B, x·B + y·A)
 * 
 * ═══════════════════════════════════════════════════════════════════
 * CONJUGATION AND TRANSPOSE AXIOMS
 * ═══════════════════════════════════════════════════════════════════
 * 
 * cmat_conj (element-wise conjugate):
 *   ∀(A B : Matrix(m, n, ℝ)).
 *     conj((A, B)) = (A, -B)
 * 
 * cmat_transpose:
 *   ∀(A B : Matrix(m, n, ℝ)).
 *     transpose((A, B)) = (transpose(A), transpose(B))
 * 
 * cmat_dagger (conjugate transpose):
 *   ∀(A B : Matrix(m, n, ℝ)).
 *     dagger((A, B)) = (transpose(A), -transpose(B))
 * 
 * dagger_involution:
 *   ∀(M : ComplexMatrix(m, n)).
 *     dagger(dagger(M)) = M
 * 
 * dagger_product:
 *   ∀(M : ComplexMatrix(m, n)) (N : ComplexMatrix(n, p)).
 *     dagger(M · N) = dagger(N) · dagger(M)
 * 
 * dagger_sum:
 *   ∀(M N : ComplexMatrix(m, n)).
 *     dagger(M + N) = dagger(M) + dagger(N)
 * 
 * ═══════════════════════════════════════════════════════════════════
 * TRACE AXIOM
 * ═══════════════════════════════════════════════════════════════════
 * 
 * cmat_trace:
 *   ∀(A B : Matrix(n, n, ℝ)).
 *     trace((A, B)) = (trace(A), trace(B))
 * 
 * ═══════════════════════════════════════════════════════════════════
 * HERMITIAN CONJUGATE PRODUCT (M† · M) - THE GRAM MATRIX
 * ═══════════════════════════════════════════════════════════════════
 * 
 * This is fundamental for singular values, norms, and unitarity.
 * 
 * cmat_gram:
 *   ∀(A B : Matrix(m, n, ℝ)).
 *     dagger((A, B)) · (A, B) = (Aᵀ·A + Bᵀ·B, Aᵀ·B - Bᵀ·A)
 * 
 * Properties:
 *   - Real part (Aᵀ·A + Bᵀ·B) is symmetric positive semi-definite
 *   - Imaginary part (Aᵀ·B - Bᵀ·A) is skew-symmetric
 *   - Singular values: σ(M) = sqrt(eigenvalues of Aᵀ·A + Bᵀ·B)
 * 
 * ═══════════════════════════════════════════════════════════════════
 * REALIFICATION FUNCTOR
 * ═══════════════════════════════════════════════════════════════════
 * 
 * Embed complex n×n into real 2n×2n:
 * 
 * realify_def:
 *   ∀(A B : Matrix(n, n, ℝ)).
 *     realify((A, B)) = block([[A, -B], [B, A]])
 * 
 * realify_mul (multiplication preserved):
 *   ∀(M N : ComplexMatrix(n, n)).
 *     realify(M · N) = realify(M) · realify(N)
 * 
 * realify_add (addition preserved):
 *   ∀(M N : ComplexMatrix(n, n)).
 *     realify(M + N) = realify(M) + realify(N)
 * 
 * cmat_det_realify (determinant via realification):
 *   ∀(M : ComplexMatrix(n, n)).
 *     |det(M)|² = det(realify(M))
 * 
 * complexify extracts (A, B) from block structure [[A, -B], [B, A]]
 * 
 * ═══════════════════════════════════════════════════════════════════
 * SPECIAL MATRICES
 * ═══════════════════════════════════════════════════════════════════
 * 
 * Hermitian (M = M†):
 *   ∀(A B : Matrix(n, n, ℝ)).
 *     hermitian((A, B)) ⟺ (A = Aᵀ) ∧ (B = -Bᵀ)
 *   i.e., A is symmetric, B is skew-symmetric
 * 
 * Unitary (U† · U = I):
 *   ∀(A B : Matrix(n, n, ℝ)).
 *     unitary((A, B)) ⟺ (Aᵀ·A + Bᵀ·B = I) ∧ (Aᵀ·B = Bᵀ·A)
 * 
 * Skew-Hermitian (M = -M†):
 *   ∀(A B : Matrix(n, n, ℝ)).
 *     skew_hermitian((A, B)) ⟺ (A = -Aᵀ) ∧ (B = Bᵀ)
 *   i.e., A is skew-symmetric, B is symmetric
 * 
 * Normal (M · M† = M† · M):
 *   ∀(M : ComplexMatrix(n, n)).
 *     normal(M) ⟺ M · dagger(M) = dagger(M) · M
 * 
 * ═══════════════════════════════════════════════════════════════════
 * SCHUR DECOMPOSITION VIA REALIFICATION
 * ═══════════════════════════════════════════════════════════════════
 * 
 * Complex Schur from real Schur (no new algorithm needed!):
 * 
 * schur_complex(M) =
 *   let Ã = realify(M)               // Embed in ℝ^{2n×2n}
 *   let (Q̃, R̃) = schur_real(Ã)      // Use existing real Schur
 *   (complexify(Q̃), complexify(R̃))  // Extract complex matrices
 * 
 * Properties:
 *   - Q̃ has structure [[Ur, -Ui], [Ui, Ur]], so complexify gives unitary U
 *   - 2×2 blocks in R̃ of form [[a, b], [-b, a]] → eigenvalue a + bi
 *   - Real Schur already separates complex conjugate pairs
 * 
 * ═══════════════════════════════════════════════════════════════════
 * SINGULAR VALUES VIA REAL ARITHMETIC
 * ═══════════════════════════════════════════════════════════════════
 * 
 * For M = (A, B):
 *   σ(M)² = eigenvalues of (Aᵀ·A + Bᵀ·B)
 * 
 * This is a real symmetric matrix - no complex eigenvalue solver needed!
 * 
 * Frobenius norm:
 *   ‖M‖²_F = trace(Aᵀ·A + Bᵀ·B) = ‖A‖²_F + ‖B‖²_F
 * 
 * Spectral norm (operator norm):
 *   ‖M‖₂ = σ_max(M) = sqrt(λ_max(Aᵀ·A + Bᵀ·B))
 */

/* ============================================
 * LEGACY MATRIX CONSTRUCTORS - REMOVED
 * ============================================
 * 
 * Old operations like matrix2x2, matrix2x3, pmatrix2x2 have been removed.
 * Use the parametric Matrix constructor instead:
 * 
 * Before: matrix2x2(a, b, c, d)
 * Now:    Matrix(2, 2, [a, b, c, d])
 * 
 * This provides:
 * - Type polymorphism (works for any element type T)
 * - Arbitrary dimensions (not just 2x2, 3x3)
 * - Consistent syntax across all matrix operations
 */
