// =============================================================================
// arXiv Preprint Paper Template
// =============================================================================
//
// Based on:
// - arxiv-style: https://github.com/kourgeorge/arxiv-style
// - arXiv submission guidelines: https://info.arxiv.org/help/submit/index.html
// - NeurIPS single-column aesthetic
//
// arXiv Paper Structure:
// 1. Title and authors with affiliations
// 2. Abstract
// 3. Introduction
// 4. Related Work (optional)
// 5. Methods/Approach
// 6. Experiments/Results
// 7. Discussion
// 8. Conclusion
// 9. Acknowledgments (optional)
// 10. References
// 11. Appendix (optional)
//
// =============================================================================

import "stdlib/prelude.kleis"

// =============================================================================
// Template Metadata
// =============================================================================

define template_name = "arXiv Preprint"
define template_version = "1.0"
define template_source = "https://github.com/kourgeorge/arxiv-style"
define template_type = "paper"

// =============================================================================
// Author and Affiliation Types
// =============================================================================

// Author with affiliation numbers (e.g., Author("Jane Doe", "1,2") for affiliations 1 and 2)
data Author = Author(String, String)  // name, affiliation_numbers

// Affiliation (e.g., Affiliation(1, "MIT", "Cambridge, MA"))
data Affiliation = Affiliation(â„•, String, String)  // number, institution, location

// =============================================================================
// Document Element Types
// =============================================================================

data ArxivDocExpr =
    ArxivSection(String, String)              // title, content
  | ArxivSubsection(String, String)           // title, content
  | ArxivSubsubsection(String, String)        // title, content
  | ArxivEquation(String, String, Bool)       // label, typst_math, numbered
  | ArxivFigure(String, String, String)       // label, caption, typst_code
  | ArxivTable(String, String, String)        // label, caption, typst_table
  | ArxivDiagram(String, String, String)      // label, caption, diagram_code (lilaq)
  | ArxivAlgorithm(String, String, String)    // label, caption, pseudocode
  | ArxivReference(String, String)            // key, citation
  | ArxivAcknowledgments(String)              // acknowledgments text
  | ArxivAppendix(String, String, String)     // letter, title, content

// Complete arXiv paper
data ArxivPaper = Paper(
    String,      // title
    List,        // authors (List of Author)
    List,        // affiliations (List of Affiliation)
    String,      // abstract
    String,      // keywords (comma-separated, optional)
    List         // elements (sections, figures, etc.)
)

// =============================================================================
// Document Construction
// =============================================================================

// Full constructor
define arxiv_paper(title, authors, affiliations, abstract_text, keywords, elements) =
    Paper(title, authors, affiliations, abstract_text, keywords, elements)

// Simple constructor (single author, single affiliation)
define arxiv_paper_simple(title, author_name, institution, location, abstract_text, elements) =
    Paper(title, 
          Cons(Author(author_name, "1"), Nil),
          Cons(Affiliation(1, institution, location), Nil),
          abstract_text, "", elements)

// =============================================================================
// Validation Functions
// =============================================================================

define valid_arxiv_paper(paper) = match paper {
    Paper(title, authors, affiliations, abstract_text, keywords, elements) =>
        // Title required
        if eq(strlen(title), 0) then false
        // At least one author required
        else if eq(length(authors), 0) then false
        // At least one affiliation required
        else if eq(length(affiliations), 0) then false
        // Abstract required
        else if eq(strlen(abstract_text), 0) then false
        else true
}

// =============================================================================
// Typst Styling - arXiv/NeurIPS-inspired
// =============================================================================

// Page setup: US Letter, comfortable margins for reading
define typst_arxiv_page_setup = 
"#set page(
  paper: \"us-letter\",
  margin: (top: 1in, bottom: 1in, left: 1in, right: 1in),
  numbering: \"1\",
  header: align(right)[_Preprint_],
)
"

// Text: 11pt for readability (NeurIPS style)
define typst_arxiv_text_setup = 
"#set text(
  font: \"New Computer Modern\",
  size: 11pt,
  lang: \"en\",
)
"

// Paragraphs: Justified with first-line indent
define typst_arxiv_paragraph_setup = 
"#set par(
  justify: true,
  leading: 0.65em,
  first-line-indent: 1em,
)

// No indent after headings
#show heading: it => {
  it
  par(text(size: 0pt, \"\"))
}
"

// Headings: Clean section numbering
define typst_arxiv_heading_setup = 
"#set heading(numbering: \"1.1\")

// Section headings (level 1)
#show heading.where(level: 1): it => {
  v(1em)
  text(size: 12pt, weight: \"bold\")[#counter(heading).display() #it.body]
  v(0.5em)
}

// Subsection headings (level 2)
#show heading.where(level: 2): it => {
  v(0.8em)
  text(size: 11pt, weight: \"bold\")[#counter(heading).display() #it.body]
  v(0.4em)
}

// Subsubsection headings (level 3)
#show heading.where(level: 3): it => {
  v(0.6em)
  text(size: 10pt, weight: \"bold\", style: \"italic\")[#counter(heading).display() #it.body]
  v(0.3em)
}
"

// Figure and table captions
define typst_arxiv_figure_setup =
"#set figure(placement: auto)
#show figure.caption: it => {
  text(size: 9pt)[#it]
}
"

// Links styling
define typst_arxiv_link_setup =
"#show link: it => text(fill: blue.darken(20%))[#underline[#it]]
"

define typst_arxiv_preamble = concat(concat(concat(concat(concat(typst_arxiv_page_setup, typst_arxiv_text_setup), typst_arxiv_paragraph_setup), typst_arxiv_heading_setup), typst_arxiv_figure_setup), typst_arxiv_link_setup)

// =============================================================================
// Title Block Template
// =============================================================================

define typst_arxiv_title_block =
"#align(center)[
  #text(size: 17pt, weight: \"bold\")[TITLE]
  
  #v(1em)
  
  AUTHORS_BLOCK
  
  #v(0.5em)
  
  AFFILIATIONS_BLOCK
]

#v(1em)

#align(center)[
  #rect(width: 85%, stroke: none)[
    #align(left)[
      #text(weight: \"bold\")[Abstract]
      #v(0.3em)
      #text(size: 10pt)[ABSTRACT_TEXT]
    ]
  ]
]

KEYWORDS_BLOCK

#v(1em)
"

// =============================================================================
// Compilation Helper Functions
// =============================================================================

// Format a single author (superscript for affiliation numbers)
define format_author(a) = match a {
    Author(name, affil_nums) => 
        concat(concat(name, "#super["), concat(affil_nums, "]"))
}

// Format authors list
define format_authors_acc(authors, acc) =
    if eq(length(authors), 0) then acc
    else
        let author_str = format_author(head(authors)) in
        let new_acc = if eq(strlen(acc), 0) then author_str
                      else concat(concat(acc, ", "), author_str) in
        format_authors_acc(tail(authors), new_acc)

define format_authors(authors) = format_authors_acc(authors, "")

// Format a single affiliation (superscript for number)
define format_affiliation(a) = match a {
    Affiliation(num, institution, location) =>
        concat(concat(concat(concat("#super[", intToStr(num)), "]"), institution), concat(", ", location))
}

// Format affiliations list
define format_affiliations_acc(affiliations, acc) =
    if eq(length(affiliations), 0) then acc
    else
        let affil_str = format_affiliation(head(affiliations)) in
        let new_acc = if eq(strlen(acc), 0) then affil_str
                      else concat(concat(acc, " #linebreak()\n    "), affil_str) in
        format_affiliations_acc(tail(affiliations), new_acc)

define format_affiliations(affiliations) = format_affiliations_acc(affiliations, "")

// Substitute placeholders in title block
define substitute_arxiv_title(template, title, authors, affiliations, abstract_text, keywords) =
    let t1 = replaceAll(template, "TITLE", title) in
    let authors_block = format_authors(authors) in
    let affiliations_block = format_affiliations(affiliations) in
    let t2 = replaceAll(t1, "AUTHORS_BLOCK", authors_block) in
    let t3 = replaceAll(t2, "AFFILIATIONS_BLOCK", affiliations_block) in
    let t4 = replaceAll(t3, "ABSTRACT_TEXT", abstract_text) in
    let keywords_block = if eq(strlen(keywords), 0) then ""
        else concat("#text(size: 9pt)[*Keywords:* ", concat(keywords, "]")) in
    replaceAll(t4, "KEYWORDS_BLOCK", keywords_block)

// =============================================================================
// Element Compilation Functions
// =============================================================================

// Check if element is a reference
define is_arxiv_reference(elem) = match elem {
    ArxivReference(key, citation) => true
  | ArxivSection(title, content) => false
  | ArxivSubsection(title, content) => false
  | ArxivSubsubsection(title, content) => false
  | ArxivEquation(label, typst_math, numbered) => false
  | ArxivFigure(label, caption, code) => false
  | ArxivTable(label, caption, table_code) => false
  | ArxivDiagram(label, caption, diagram_code) => false
  | ArxivAlgorithm(label, caption, pseudocode) => false
  | ArxivAcknowledgments(text) => false
  | ArxivAppendix(letter, title, content) => false
}

// Check if element is an appendix
define is_arxiv_appendix(elem) = match elem {
    ArxivAppendix(letter, title, content) => true
  | ArxivReference(key, citation) => false
  | ArxivSection(title, content) => false
  | ArxivSubsection(title, content) => false
  | ArxivSubsubsection(title, content) => false
  | ArxivEquation(label, typst_math, numbered) => false
  | ArxivFigure(label, caption, code) => false
  | ArxivTable(label, caption, table_code) => false
  | ArxivDiagram(label, caption, diagram_code) => false
  | ArxivAlgorithm(label, caption, pseudocode) => false
  | ArxivAcknowledgments(text) => false
}

// Check if element is acknowledgments
define is_arxiv_acknowledgments(elem) = match elem {
    ArxivAcknowledgments(text) => true
  | ArxivAppendix(letter, title, content) => false
  | ArxivReference(key, citation) => false
  | ArxivSection(title, content) => false
  | ArxivSubsection(title, content) => false
  | ArxivSubsubsection(title, content) => false
  | ArxivEquation(label, typst_math, numbered) => false
  | ArxivFigure(label, caption, code) => false
  | ArxivTable(label, caption, table_code) => false
  | ArxivDiagram(label, caption, diagram_code) => false
  | ArxivAlgorithm(label, caption, pseudocode) => false
}

// Compile a single element to Typst
define compile_arxiv_element(elem) = match elem {
    ArxivSection(title, content) => 
        concat(concat(concat("= ", title), "\n\n"), content)
  | ArxivSubsection(title, content) =>
        concat(concat(concat("== ", title), "\n\n"), content)
  | ArxivSubsubsection(title, content) =>
        concat(concat(concat("=== ", title), "\n\n"), content)
  | ArxivEquation(label, typst_math, numbered) =>
        if numbered then
            concat(concat(concat("$ ", typst_math), " $ <"), concat(label, ">"))
        else
            concat(concat("$ ", typst_math), " $")
  | ArxivFigure(label, caption, code) =>
        concat(concat(concat("#figure(\n  ", code), ",\n  caption: ["), concat(concat(caption, "]\n) <"), concat(label, ">")))
  | ArxivTable(label, caption, table_code) =>
        concat(concat(concat("#figure(\n  ", table_code), ",\n  caption: ["), concat(concat(caption, "]\n) <"), concat(label, ">")))
  | ArxivDiagram(label, caption, diagram_code) =>
        concat(concat(concat("#figure(\n  ", diagram_code), ",\n  caption: ["), concat(concat(caption, "]\n) <"), concat(label, ">")))
  | ArxivAlgorithm(label, caption, pseudocode) =>
        concat(concat(concat("#figure(\n  rect(stroke: 0.5pt, inset: 10pt)[\n    ", pseudocode), "\n  ],\n  caption: ["), concat(concat(caption, "]\n) <"), concat(label, ">")))
  | ArxivReference(key, citation) =>
        concat(concat(concat("[", key), "] "), citation)
  | ArxivAcknowledgments(text) =>
        ""  // Handled separately
  | ArxivAppendix(letter, title, content) =>
        concat(concat(concat("= ", title), "\n\n"), content)
}

// Compile body elements (excluding references, appendices, acknowledgments)
define compile_arxiv_body_acc(xs, acc) =
    if eq(length(xs), 0) then acc
    else 
        let elem = head(xs) in
        if is_arxiv_reference(elem) then compile_arxiv_body_acc(tail(xs), acc)
        else if is_arxiv_appendix(elem) then compile_arxiv_body_acc(tail(xs), acc)
        else if is_arxiv_acknowledgments(elem) then compile_arxiv_body_acc(tail(xs), acc)
        else
            let elem_typst = compile_arxiv_element(elem) in
            let new_acc = if eq(strlen(acc), 0) then elem_typst 
                          else concat(concat(acc, "\n\n"), elem_typst) in
            compile_arxiv_body_acc(tail(xs), new_acc)

define compile_arxiv_body(xs) = compile_arxiv_body_acc(xs, "")

// Compile only references
define compile_arxiv_references_acc(xs, acc) =
    if eq(length(xs), 0) then acc
    else 
        let elem = head(xs) in
        if is_arxiv_reference(elem) then
            let elem_typst = compile_arxiv_element(elem) in
            let new_acc = if eq(strlen(acc), 0) then elem_typst 
                          else concat(concat(acc, "\n\n"), elem_typst) in
            compile_arxiv_references_acc(tail(xs), new_acc)
        else
            compile_arxiv_references_acc(tail(xs), acc)

define compile_arxiv_references(xs) = compile_arxiv_references_acc(xs, "")

// Compile only appendices
define compile_arxiv_appendices_acc(xs, acc) =
    if eq(length(xs), 0) then acc
    else 
        let elem = head(xs) in
        if is_arxiv_appendix(elem) then
            let elem_typst = compile_arxiv_element(elem) in
            let new_acc = if eq(strlen(acc), 0) then elem_typst 
                          else concat(concat(acc, "\n\n"), elem_typst) in
            compile_arxiv_appendices_acc(tail(xs), new_acc)
        else
            compile_arxiv_appendices_acc(tail(xs), acc)

define compile_arxiv_appendices(xs) = compile_arxiv_appendices_acc(xs, "")

// Get acknowledgments text
define get_acknowledgments_acc(xs) =
    if eq(length(xs), 0) then ""
    else match head(xs) {
        ArxivAcknowledgments(text) => text
      | ArxivSection(t, c) => get_acknowledgments_acc(tail(xs))
      | ArxivSubsection(t, c) => get_acknowledgments_acc(tail(xs))
      | ArxivSubsubsection(t, c) => get_acknowledgments_acc(tail(xs))
      | ArxivEquation(l, m, n) => get_acknowledgments_acc(tail(xs))
      | ArxivFigure(l, c, code) => get_acknowledgments_acc(tail(xs))
      | ArxivTable(l, c, code) => get_acknowledgments_acc(tail(xs))
      | ArxivDiagram(l, c, code) => get_acknowledgments_acc(tail(xs))
      | ArxivAlgorithm(l, c, code) => get_acknowledgments_acc(tail(xs))
      | ArxivReference(k, c) => get_acknowledgments_acc(tail(xs))
      | ArxivAppendix(letter, title, content) => get_acknowledgments_acc(tail(xs))
    }

define get_acknowledgments(xs) = get_acknowledgments_acc(xs)

// Check if list has references
define has_arxiv_references_acc(xs) =
    if eq(length(xs), 0) then false
    else if is_arxiv_reference(head(xs)) then true
    else has_arxiv_references_acc(tail(xs))

define has_arxiv_references(xs) = has_arxiv_references_acc(xs)

// Check if list has appendices
define has_arxiv_appendices_acc(xs) =
    if eq(length(xs), 0) then false
    else if is_arxiv_appendix(head(xs)) then true
    else has_arxiv_appendices_acc(tail(xs))

define has_arxiv_appendices(xs) = has_arxiv_appendices_acc(xs)

// =============================================================================
// Acknowledgments Section
// =============================================================================

define typst_arxiv_acknowledgments_header =
"#heading(numbering: none)[Acknowledgments]
"

// =============================================================================
// References Section
// =============================================================================

define typst_arxiv_references_header =
"#heading(numbering: none)[References]
#set text(size: 9pt)
"

// =============================================================================
// Appendix Setup
// =============================================================================

define typst_arxiv_appendix_setup =
"#pagebreak()
// Reset heading counter for appendices
#counter(heading).update(0)
#set heading(numbering: \"A.1\")

#align(center)[
  #text(size: 14pt, weight: \"bold\")[Appendix]
]
#v(1em)
"

// =============================================================================
// Main Compilation Function
// =============================================================================

define compile_arxiv_paper(paper) = match paper {
    Paper(title, authors, affiliations, abstract_text, keywords, elements) =>
        let preamble = typst_arxiv_preamble in
        
        // Title block
        let title_block = substitute_arxiv_title(typst_arxiv_title_block, title, authors, affiliations, abstract_text, keywords) in
        
        // Body (sections, figures, tables, equations)
        let body = compile_arxiv_body(elements) in
        
        // Acknowledgments (if any)
        let ack_text = get_acknowledgments(elements) in
        let ack_section = if eq(strlen(ack_text), 0) then ""
            else concat(typst_arxiv_acknowledgments_header, ack_text) in
        
        // References
        let refs = if has_arxiv_references(elements) then
            concat(typst_arxiv_references_header, compile_arxiv_references(elements))
            else "" in
        
        // Appendices (if any)
        let appendices = if has_arxiv_appendices(elements) then
            concat(typst_arxiv_appendix_setup, compile_arxiv_appendices(elements))
            else "" in
        
        // Assemble all parts
        concat(preamble,
        concat("\n\n", concat(title_block,
        concat("\n\n", concat(body,
        concat("\n\n", concat(ack_section,
        concat("\n\n", concat(refs,
        concat("\n\n", appendices))))))))))
}

// =============================================================================
// Examples
// =============================================================================

example "test_arxiv_author_formatting" {
    let authors = Cons(Author("Jane Doe", "1"), Cons(Author("John Smith", "1,2"), Nil)) in
    let formatted = format_authors(authors) in
    out(formatted)
}

example "test_arxiv_affiliation_formatting" {
    let affiliations = Cons(Affiliation(1, "MIT", "Cambridge, MA"), Cons(Affiliation(2, "Stanford", "Palo Alto, CA"), Nil)) in
    let formatted = format_affiliations(affiliations) in
    out(formatted)
}

example "test_arxiv_paper_validation" {
    let paper = arxiv_paper_simple(
        "A Novel Approach to X",
        "Jane Doe",
        "MIT",
        "Cambridge, MA",
        "We present a novel approach...",
        Cons(ArxivSection("Introduction", "This paper presents..."), Nil)
    ) in
    assert(valid_arxiv_paper(paper) = true)
    out("arXiv paper validation works")
}

example "test_arxiv_compile" {
    let paper = arxiv_paper_simple(
        "Sample Paper",
        "Test Author",
        "Test University",
        "Test City",
        "This is the abstract.",
        Cons(ArxivSection("Introduction", "Introduction content."), 
        Cons(ArxivSection("Methods", "Methods content."),
        Cons(ArxivReference("ref1", "Author et al. (2024). Title. Journal."),
        Nil)))
    ) in
    let typst = compile_arxiv_paper(paper) in
    out(typst)
}
