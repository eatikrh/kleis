// Kleis Standard Library - Tensors
// Differential geometry and General Relativity operations
//
// Tensors are fundamental to Einstein's field equations and curved spacetime.
// This file defines tensor structures following ADR-016.
//
// **xAct/xTensor-Style Notation**
//
// We use xAct-style notation where:
//   - Positive index → contravariant (upper): T(μ, ρ) → T^μρ
//   - Negative index → covariant (lower): T(-μ, -ν) → T_μν
//   - Mixed: T(μ, -ν) → T^μ_ν
//
// Examples:
//   g(-μ, -ν)              // Metric tensor g_μν
//   Γ(λ, -μ, -ν)          // Christoffel symbol Γ^λ_μν
//   R(ρ, -σ, -μ, -ν)      // Riemann tensor R^ρ_σμν
//
// Tensors are parametric over:
//   - Rank: (contravariant, covariant) index counts
//   - Dimension: spacetime dimension (typically 4 for GR)
//   - T: element type (typically ℝ)

/* Tensor Type
 * 
 * A tensor is a multilinear map with contravariant (upper) and covariant (lower) indices.
 * 
 * Notation conventions:
 *   - Contravariant (upper): Tᵘ, Tᵘᵛ, ...
 *   - Covariant (lower): Tᵤ, Tᵤᵥ, ...
 *   - Mixed: Tᵘᵥ, Tᵘᵛᵥᵨ, ...
 * 
 * Type parameters:
 *   - upper: number of contravariant indices (Nat)
 *   - lower: number of covariant indices (Nat)
 *   - dim: spacetime dimension (Nat)
 *   - T: element type
 * 
 * Examples:
 *   - Scalar: Tensor(0, 0, 4, ℝ)
 *   - Vector: Tensor(1, 0, 4, ℝ) or Tensor(0, 1, 4, ℝ)
 *   - Metric: Tensor(0, 2, 4, ℝ) → gᵤᵥ
 *   - Riemann: Tensor(1, 3, 4, ℝ) → Rᵘᵥᵨσ
 */
structure Tensor(upper: Nat, lower: Nat, dim: Nat, T) {
    operation contract : Tensor(upper, lower, dim, T) → T
}

implements Tensor(upper, lower, dim, ℝ) {
    operation contract = builtin_tensor_contract
}

/* Metric Tensor - The Foundation of GR
 * 
 * The metric tensor gᵤᵥ defines distances and angles in curved spacetime.
 * In GR, the metric determines the geometry of spacetime.
 * 
 * Properties:
 *   - Symmetric: gᵤᵥ = gᵥᵤ
 *   - Signature: Typically (-,+,+,+) for Minkowski or (timelike, spacelike³)
 *   - Inverse: gᵘᵛ gᵥᵨ = δᵘᵨ (Kronecker delta)
 * 
 * Type: Tensor(0, 2, dim, ℝ) - covariant rank-2 tensor
 */
structure MetricTensor(dim: Nat) {
    operation inverse : Tensor(0, 2, dim, ℝ) → Tensor(2, 0, dim, ℝ)
    operation determinant : Tensor(0, 2, dim, ℝ) → ℝ
    operation signature : Tensor(0, 2, dim, ℝ) → ℝ
}

implements MetricTensor(dim) {
    operation inverse = builtin_metric_inverse
    operation determinant = builtin_metric_determinant
    operation signature = builtin_metric_signature
}

/* Christoffel Symbols - Connection Coefficients
 * 
 * The Christoffel symbols Γᵘᵥᵨ describe how vectors change as they're parallel-transported.
 * They encode the curvature of spacetime in terms of metric derivatives.
 * 
 * Definition: Γᵘᵥᵨ = ½ gᵘσ (∂ᵥgσᵨ + ∂ᵨgσᵥ - ∂σgᵥᵨ)
 * 
 * Type: Tensor(1, 2, dim, ℝ) - one contravariant, two covariant indices
 * 
 * Properties:
 *   - Symmetric in lower indices: Γᵘᵥᵨ = Γᵘᵨᵥ
 *   - Not a tensor! (transforms non-linearly)
 *   - Zero in flat spacetime with Cartesian coordinates
 */
structure Connection(dim: Nat) {
    operation christoffel : Tensor(0, 2, dim, ℝ) → Tensor(1, 2, dim, ℝ)
}

implements Connection(dim) {
    operation christoffel = builtin_christoffel_from_metric
}

/* Riemann Curvature Tensor - The Heart of GR
 * 
 * The Riemann tensor Rᵘᵥᵨσ measures the curvature of spacetime.
 * It describes tidal forces and is the fundamental object in GR.
 * 
 * Definition: Rᵘᵥᵨσ = ∂ᵨΓᵘᵥσ - ∂σΓᵘᵥᵨ + ΓᵘλᵨΓλᵥσ - ΓᵘλσΓλᵥᵨ
 * 
 * Type: Tensor(1, 3, dim, ℝ) - one contravariant, three covariant indices
 * 
 * Properties:
 *   - Antisymmetric in first pair: Rᵘᵥᵨσ = -Rᵥᵘᵨσ
 *   - Antisymmetric in second pair: Rᵘᵥᵨσ = -Rᵘᵥσᵨ
 *   - First Bianchi identity: Rᵘ[ᵥᵨσ] = 0 (cyclic sum)
 *   - Second Bianchi identity: ∇[λRᵘᵥ]ᵨσ = 0
 *   - Zero ⟺ flat spacetime
 * 
 * In 4D: 20 independent components (256 → 20 by symmetries)
 */
structure Curvature(dim: Nat) {
    operation riemann : Tensor(1, 2, dim, ℝ) → Tensor(1, 3, dim, ℝ)
    operation riemann_from_metric : Tensor(0, 2, dim, ℝ) → Tensor(1, 3, dim, ℝ)
}

implements Curvature(dim) {
    operation riemann = builtin_riemann_from_christoffel
    operation riemann_from_metric = builtin_riemann_from_metric
}

/* Ricci Tensor - Trace of Riemann Tensor
 * 
 * The Ricci tensor Rᵤᵥ is obtained by contracting the Riemann tensor.
 * It appears in Einstein's field equations.
 * 
 * Definition: Rᵤᵥ = Rᵘᵤᵨᵥ (contraction on first and third indices)
 * 
 * Type: Tensor(0, 2, dim, ℝ) - covariant rank-2 tensor
 * 
 * Properties:
 *   - Symmetric: Rᵤᵥ = Rᵥᵤ
 *   - In 4D: 10 independent components
 *   - Describes local matter/energy content
 */
structure RicciTensor(dim: Nat) {
    operation ricci : Tensor(1, 3, dim, ℝ) → Tensor(0, 2, dim, ℝ)
}

implements RicciTensor(dim) {
    operation ricci = builtin_ricci_from_riemann
}

/* Ricci Scalar - Complete Contraction
 * 
 * The Ricci scalar R is the trace of the Ricci tensor.
 * It's a scalar measure of spacetime curvature.
 * 
 * Definition: R = gᵘᵛ Rᵤᵥ
 * 
 * Type: ℝ (scalar)
 * 
 * Physical meaning:
 *   - R > 0: positive curvature (sphere-like)
 *   - R < 0: negative curvature (hyperbolic)
 *   - R = 0: flat or Ricci-flat (vacuum)
 */
structure RicciScalar(dim: Nat) {
    operation ricci_scalar : Tensor(0, 2, dim, ℝ) → Tensor(2, 0, dim, ℝ) → ℝ
}

implements RicciScalar(dim) {
    operation ricci_scalar = builtin_ricci_scalar
}

/* Einstein Tensor - Left Side of Field Equations
 * 
 * The Einstein tensor Gᵤᵥ appears in Einstein's field equations:
 *   Gᵤᵥ = 8πG/c⁴ Tᵤᵥ
 * 
 * Definition: Gᵤᵥ = Rᵤᵥ - ½ R gᵤᵥ
 * 
 * Type: Tensor(0, 2, dim, ℝ) - covariant rank-2 tensor
 * 
 * Properties:
 *   - Symmetric: Gᵤᵥ = Gᵥᵤ
 *   - Divergence-free: ∇ᵘ Gᵤᵥ = 0 (conservation of energy-momentum)
 *   - Automatically satisfies Bianchi identity
 */
structure EinsteinTensor(dim: Nat) {
    operation einstein : Tensor(0, 2, dim, ℝ) → ℝ → Tensor(0, 2, dim, ℝ) → Tensor(0, 2, dim, ℝ)
}

implements EinsteinTensor(dim) {
    operation einstein = builtin_einstein_tensor
}

// ============================================
// Einstein Summation Convention (Dimension-Agnostic)
// ============================================

/* Einstein Summation - Index Contraction
 * 
 * The Einstein summation convention: repeated indices are summed over.
 *   T^μ_μ = Σ_μ T^μ_μ (trace)
 *   A^μ B_μ = Σ_μ A^μ B_μ (contraction)
 * 
 * In Z3, we model summation abstractly via contraction operations
 * rather than explicit sum_over with lambdas (Z3 doesn't handle HOF well).
 * 
 * Key principle: Summation is implicit in contraction operations.
 * We axiomatize the RESULTS of summation, not the summation process itself.
 */
structure EinsteinSummation(dim: Nat) {
    // Trace operation: Σ_μ T^μ_μ
    operation trace2 : Tensor(1, 1, dim, ℝ) → ℝ
    
    // Index contraction: contracts specified indices
    operation contract2 : Tensor(0, 2, dim, ℝ) → Tensor(2, 0, dim, ℝ) → ℝ
    
    // Trace is additive (linear in first argument)
    axiom trace_additive : ∀ T : Tensor(1, 1, dim, ℝ) . ∀ S : Tensor(1, 1, dim, ℝ) .
        trace2(add(T, S)) = plus(trace2(T), trace2(S))
    
    // Contraction with delta: δ^μ_μ = 1 for each μ
    axiom delta_self_contract : ∀ μ : Nat .
        times(delta(μ, μ), 1) = 1
    
    // Trace of zero tensor is zero
    axiom trace_zero : ∀ T : Tensor(1, 1, dim, ℝ) .
        (∀ μ : Nat . ∀ ν : Nat . component(T, μ, ν) = 0) →
        trace2(T) = 0
}

implements EinsteinSummation(dim) {
    operation trace2 = builtin_trace2
    operation contract2 = builtin_contract2
}

// ============================================
// Tensor Contraction Definitions (Dimension-Agnostic)
// ============================================

/* Ricci Tensor Definition
 * 
 * The Ricci tensor is defined as the contraction of the Riemann tensor:
 *   R_μν = R^ρ_μρν = Σ_ρ R^ρ_μρν
 * 
 * This is the trace over the first and third indices.
 * We axiomatize the properties rather than the explicit summation.
 */
structure RicciTensorDefinition(dim: Nat) {
    // Ricci tensor is symmetric (follows from Riemann symmetries)
    axiom ricci_symmetric : ∀ Ric : Tensor(0, 2, dim, ℝ) .
        ∀ μ : Nat . ∀ ν : Nat .
        component(Ric, μ, ν) = component(Ric, ν, μ)
    
    // Ricci inherits from Riemann: when Riemann vanishes, so does Ricci
    axiom ricci_from_flat : ∀ Riem : Tensor(1, 3, dim, ℝ) .
        (∀ ρ : Nat . ∀ σ : Nat . ∀ μ : Nat . ∀ ν : Nat .
            component4(Riem, ρ, σ, μ, ν) = 0) →
        (∀ μ : Nat . ∀ ν : Nat . component(ricci(Riem), μ, ν) = 0)
}

/* Ricci Scalar Definition
 * 
 * The Ricci scalar is the trace of the Ricci tensor with the metric:
 *   R = g^μν R_μν
 * 
 * We axiomatize the properties rather than explicit double summation.
 */
structure RicciScalarDefinition(dim: Nat) {
    // Ricci scalar is real (well-defined)
    // R = g^μν R_μν is a contraction, hence scalar
    
    // Ricci scalar vanishes for flat space
    axiom ricci_scalar_flat : ∀ g : Tensor(0, 2, dim, ℝ) .
        ∀ g_inv : Tensor(2, 0, dim, ℝ) .
        (∀ μ : Nat . ∀ ν : Nat . component(ricci(riemann_from_metric(g)), μ, ν) = 0) →
        ricci_scalar(g, g_inv) = 0
    
    // Ricci scalar scaling under conformal transformation (property)
    // This is a key property that constrains the scalar
}

/* Einstein Tensor Definition
 * 
 * The Einstein tensor is defined as:
 *   G_μν = R_μν - (1/2) R g_μν
 * 
 * We axiomatize the key properties that make G_μν special.
 */
structure EinsteinTensorDefinition(dim: Nat) {
    // Einstein tensor is symmetric (inherits from metric and Ricci)
    axiom einstein_symmetric : ∀ G : Tensor(0, 2, dim, ℝ) .
        is_symmetric(G)
    
    // Einstein tensor trace: G = g^μν G_μν = R - 2R = -R (in 4D: R - 4·(R/2) = -R)
    // For dim=4: trace(G) = R - (1/2)·4·R = R - 2R = -R
    // General: trace(G) = R - (dim/2)·R = R·(1 - dim/2)
    
    // Einstein tensor vanishes for flat space
    axiom einstein_flat : ∀ g : Tensor(0, 2, dim, ℝ) .
        ∀ G : Tensor(0, 2, dim, ℝ) .
        (∀ μ : Nat . ∀ ν : Nat . component(ricci(riemann_from_metric(g)), μ, ν) = 0) →
        (∀ μ : Nat . ∀ ν : Nat . component(G, μ, ν) = 0)
}

// ============================================
// Bianchi Identities and Conservation Laws
// ============================================

/* Contracted Bianchi Identity
 * 
 * The most important identity in GR - Einstein chose G_μν because of this:
 *   ∇^μ G_μν = 0
 * 
 * This means the Einstein tensor is divergence-free, which guarantees
 * conservation of energy-momentum when coupled to matter.
 * 
 * This identity follows algebraically from the Second Bianchi Identity
 * applied to the Riemann tensor, then contracted.
 */
structure ContractedBianchi(dim: Nat) {
    // Covariant divergence of Einstein tensor vanishes
    // ∇^μ G_μν = Σ_μ g^μρ ∇_ρ G_μν = 0
    axiom einstein_divergence_free : ∀ G : Tensor(0, 2, dim, ℝ) .
        ∀ ν : Nat .
        covariant_divergence(G, ν) = 0
    
    // Covariant divergence operation
    operation covariant_divergence : Tensor(0, 2, dim, ℝ) → Nat → ℝ
}

implements ContractedBianchi(dim) {
    operation covariant_divergence = builtin_covariant_divergence
}

/* Energy-Momentum Conservation
 * 
 * From Einstein's field equations G_μν + Λg_μν = κT_μν
 * and the contracted Bianchi identity ∇^μ G_μν = 0,
 * it follows that:
 *   ∇^μ T_μν = 0
 * 
 * This is the conservation of energy-momentum!
 */
structure EnergyMomentumConservation(dim: Nat) {
    // Stress-energy tensor is covariantly conserved
    axiom stress_energy_conserved : ∀ T : Tensor(0, 2, dim, ℝ) .
        ∀ ν : Nat .
        covariant_divergence(T, ν) = 0
}

/* Einstein Field Equations - Full Axiomatization
 * 
 * The complete Einstein field equations with cosmological constant:
 *   G_μν + Λ g_μν = κ T_μν
 * 
 * where κ = 8πG/c⁴
 * 
 * This structure provides the axiom that relates geometry to matter.
 */
structure EinsteinFieldEquationsAxiom(dim: Nat) {
    // Field equation in component form
    axiom field_equation_components : ∀ g : Tensor(0, 2, dim, ℝ) .
        ∀ G : Tensor(0, 2, dim, ℝ) .
        ∀ T : Tensor(0, 2, dim, ℝ) .
        ∀ Lambda : ℝ .
        ∀ kappa : ℝ .
        ∀ μ : Nat . ∀ ν : Nat .
        plus(component(G, μ, ν), times(Lambda, component(g, μ, ν))) = 
            times(kappa, component(T, μ, ν))
    
    // Vacuum solution: T_μν = 0 implies G_μν = -Λg_μν
    axiom vacuum_field_equation : ∀ g : Tensor(0, 2, dim, ℝ) .
        ∀ G : Tensor(0, 2, dim, ℝ) .
        ∀ Lambda : ℝ .
        ∀ μ : Nat . ∀ ν : Nat .
        component(G, μ, ν) = negate(times(Lambda, component(g, μ, ν)))
}

/* Tensor Index Notation - Display Operations
 * 
 * These operations create indexed tensor notation for display.
 * They differ from computation operations - they build notation, not compute values.
 * 
 * Examples:
 *   - gamma(Γ, λ, μ, ν) → displays as Γ^λ_μν
 *   - riemann(R, ρ, σ, μ, ν) → displays as R^ρ_σμν
 * 
 * These are used by the UI palette to create properly indexed tensor expressions.
 * 
 * Note: The visual editor uses display symbols (Γ, R, g) which are mapped to
 * tensor types at the UI level. Full type checking integration is future work.
 */
structure TensorNotation(T) {
    operation gamma : T → T → T → T → T
    operation riemann : T → T → T → T → T → T
}

implements TensorNotation(ℝ) {
    operation gamma = builtin_gamma_notation
    operation riemann = builtin_riemann_notation
}

/* Tensor Index Operations
 * 
 * Mixed index notation: Tᵘᵥ (one up, one down)
 * 
 * Operations:
 *   - Raise index: gᵘᵛ Tᵥ = Tᵘ
 *   - Lower index: gᵤᵥ Tᵛ = Tᵤ
 *   - Contract: Tᵘᵤ (sum over repeated index)
 */
structure TensorIndexOps(dim: Nat, T) {
    operation raise_index : Tensor(2, 0, dim, T) → Tensor(0, 1, dim, T) → Tensor(1, 0, dim, T)
    operation lower_index : Tensor(0, 2, dim, T) → Tensor(1, 0, dim, T) → Tensor(0, 1, dim, T)
    operation index_mixed : T → T → T → T
}

implements TensorIndexOps(dim, ℝ) {
    operation raise_index = builtin_raise_index
    operation lower_index = builtin_lower_index
    operation index_mixed = builtin_index_mixed
}

/* Covariant Derivative - Parallel Transport
 * 
 * The covariant derivative ∇ᵤ generalizes ordinary derivatives to curved spaces.
 * It accounts for the curvature via Christoffel symbols.
 * 
 * For a vector: ∇ᵤ Vᵛ = ∂ᵤ Vᵛ + Γᵛᵤλ Vλ
 * For a covector: ∇ᵤ ωᵥ = ∂ᵤ ωᵥ - Γλᵤᵥ ωλ
 * 
 * Parallel transport: ∇ᵤ Vᵛ = 0 along a curve
 */
structure CovariantDerivative(dim: Nat) {
    operation covariant_derivative : Tensor(1, 2, dim, ℝ) → Tensor(1, 0, dim, ℝ) → Tensor(1, 1, dim, ℝ)
}

implements CovariantDerivative(dim) {
    operation covariant_derivative = builtin_covariant_derivative
}

/* Tensor Product (Outer Product)
 * 
 * The tensor product combines two tensors into a higher-rank tensor.
 * 
 * Example: Tᵘ ⊗ Sᵛ = Wᵘᵛ
 * 
 * Ranks add: Tensor(p, q) ⊗ Tensor(r, s) = Tensor(p+r, q+s)
 * 
 * v0.92+: Parser now supports arithmetic in type parameters (p + r).
 */
structure TensorProduct(p: Nat, q: Nat, r: Nat, s: Nat, dim: Nat, T) {
    operation tensor_product : 
        Tensor(p, q, dim, T) → 
        Tensor(r, s, dim, T) → 
        Tensor(p + r, q + s, dim, T)
}

implements TensorProduct(p, q, r, s, dim, ℝ) {
    operation tensor_product = builtin_tensor_product
}

/* Wedge Product (Antisymmetric Tensor Product)
 * 
 * The wedge product ∧ creates antisymmetric tensors (differential forms).
 * Fundamental to differential geometry and electromagnetism.
 * 
 * Properties:
 *   - Antisymmetric: α ∧ β = -β ∧ α
 *   - Associative: (α ∧ β) ∧ γ = α ∧ (β ∧ γ)
 *   - α ∧ α = 0 for any 1-form α
 * 
 * v0.92+: Parser now supports arithmetic in type parameters (p + q).
 * 
 * NOTE: Axioms for antisymmetry/nilpotency require proper Z3 declarations
 * for scale(), sign_factor(), and zero. These are verified computationally
 * in stdlib/tensors_functional.kleis instead.
 */
structure ExteriorAlgebra(p: Nat, q: Nat, dim: Nat) {
    operation wedge : Tensor(0, p, dim, ℝ) → Tensor(0, q, dim, ℝ) → Tensor(0, p + q, dim, ℝ)
}

/* Wedge Product Nilpotency for 1-forms
 * 
 * For any 1-form α: α ∧ α = 0 (the zero 2-form)
 * 
 * This follows from antisymmetry: α ∧ α = -α ∧ α implies α ∧ α = 0
 * Expressed at component level since wedge returns a tensor.
 * 
 * In coordinates: if α = a_i dx^i, then
 *   α ∧ α = Σ(a_i a_j - a_j a_i) dx^i ∧ dx^j = 0
 */
structure WedgeNilpotent(dim: Nat) {
    // Component accessor for 2-forms (rank-2 covariant tensors)
    operation component2 : Tensor(0, 2, dim, ℝ) → Nat → Nat → ℝ
    
    // Every component of α ∧ α is zero
    axiom wedge_nilpotent : ∀ alpha : Tensor(0, 1, dim, ℝ) .
        ∀ i : Nat . ∀ j : Nat .
        component2(wedge(alpha, alpha), i, j) = 0
}

implements WedgeNilpotent(dim) {
    operation component2 = builtin_tensor_component2
}

implements ExteriorAlgebra(p, q, dim) {
    operation wedge = builtin_wedge_product
}

/* Lie Derivative - Infinitesimal Diffeomorphisms
 * 
 * The Lie derivative ℒ_X measures how a tensor changes along a vector field X.
 * It describes infinitesimal coordinate transformations.
 * 
 * For a function: ℒ_X f = X(f) (directional derivative)
 * For a vector: ℒ_X Y = [X, Y] (Lie bracket)
 * For the metric: ℒ_X g = 0 ⟺ X is a Killing vector (symmetry)
 */
structure LieDerivative(upper: Nat, lower: Nat, dim: Nat) {
    operation lie_derivative : 
        Tensor(1, 0, dim, ℝ) → 
        Tensor(upper, lower, dim, ℝ) → 
        Tensor(upper, lower, dim, ℝ)
}

implements LieDerivative(upper, lower, dim) {
    operation lie_derivative = builtin_lie_derivative
}

/* Killing Vector - Spacetime Symmetry
 * 
 * A Killing vector K satisfies ℒ_K g = 0, representing a spacetime symmetry.
 * Each Killing vector corresponds to a conserved quantity.
 * 
 * Examples:
 *   - Time translation: ∂/∂t → energy conservation
 *   - Spatial rotation: ∂/∂φ → angular momentum conservation
 *   - Spatial translation: ∂/∂x → linear momentum conservation
 */
structure KillingVector(dim: Nat) {
    operation is_killing : Tensor(1, 0, dim, ℝ) → Tensor(0, 2, dim, ℝ) → Bool
}

implements KillingVector(dim) {
    operation is_killing = builtin_is_killing_vector
}

/* Stress-Energy Tensor - Matter/Energy Content
 * 
 * The stress-energy tensor Tᵤᵥ describes the density and flux of energy and momentum.
 * Right-hand side of Einstein's field equations.
 * 
 * Components:
 *   - T₀₀: energy density
 *   - T₀ᵢ: momentum density / energy flux
 *   - Tᵢⱼ: stress tensor (pressure, shear)
 * 
 * Type: Tensor(0, 2, dim, ℝ)
 * 
 * Properties:
 *   - Symmetric: Tᵤᵥ = Tᵥᵤ
 *   - Conserved: ∇ᵘ Tᵤᵥ = 0 (energy-momentum conservation)
 */
structure StressEnergyTensor(dim: Nat) {
    operation perfect_fluid : ℝ → ℝ → Tensor(1, 0, dim, ℝ) → Tensor(0, 2, dim, ℝ)
    operation dust : ℝ → Tensor(1, 0, dim, ℝ) → Tensor(0, 2, dim, ℝ)
    operation electromagnetic : Tensor(0, 2, dim, ℝ) → Tensor(0, 2, dim, ℝ)
}

implements StressEnergyTensor(dim) {
    operation perfect_fluid = builtin_stress_energy_perfect_fluid
    operation dust = builtin_stress_energy_dust
    operation electromagnetic = builtin_stress_energy_em
}

/* Weyl Tensor - Conformal Curvature
 * 
 * The Weyl tensor Cᵘᵥᵨσ is the traceless part of the Riemann tensor.
 * It represents curvature NOT due to local matter/energy (gravitational waves).
 * 
 * Definition: Cᵘᵥᵨσ = Rᵘᵥᵨσ - (various terms involving Ricci and metric)
 * 
 * Type: Tensor(1, 3, dim, ℝ)
 * 
 * Properties:
 *   - Traceless: Cᵘᵥᵤσ = 0
 *   - Same symmetries as Riemann
 *   - Zero in 3D (all curvature is Ricci)
 *   - Describes gravitational waves in vacuum
 */
structure WeylTensor(dim: Nat) {
    operation weyl : 
        Tensor(1, 3, dim, ℝ) → 
        Tensor(0, 2, dim, ℝ) → 
        ℝ → 
        Tensor(0, 2, dim, ℝ) → 
        Tensor(1, 3, dim, ℝ)
}

implements WeylTensor(dim) {
    operation weyl = builtin_weyl_tensor
}

/* Geodesic Equation - Free Fall Paths
 * 
 * The geodesic equation describes the path of freely falling particles.
 * In GR, planets orbit the sun by following geodesics in curved spacetime.
 * 
 * Equation: d²xᵘ/dτ² + Γᵘᵥᵨ (dxᵛ/dτ) (dxᵨ/dτ) = 0
 * 
 * where τ is proper time
 */
structure Geodesic(dim: Nat) {
    operation geodesic_acceleration : 
        Tensor(1, 2, dim, ℝ) → 
        Tensor(1, 0, dim, ℝ) → 
        Tensor(1, 0, dim, ℝ) → 
        Tensor(1, 0, dim, ℝ)
}

implements Geodesic(dim) {
    operation geodesic_acceleration = builtin_geodesic_acceleration
}

/* Einstein Field Equations
 * 
 * The Einstein field equations relate spacetime geometry to matter/energy:
 * 
 *   Gᵤᵥ + Λgᵤᵥ = (8πG/c⁴) Tᵤᵥ
 * 
 * where:
 *   - Gᵤᵥ: Einstein tensor (geometry)
 *   - Λ: cosmological constant (dark energy)
 *   - Tᵤᵥ: stress-energy tensor (matter/energy)
 *   - G: Newton's gravitational constant
 *   - c: speed of light
 * 
 * This single equation governs:
 *   - Black holes
 *   - Gravitational waves
 *   - Expanding universe
 *   - Time dilation
 *   - All gravitational phenomena!
 */
structure EinsteinEquations(dim: Nat) {
    operation field_equation : 
        Tensor(0, 2, dim, ℝ) →  // Metric gᵤᵥ
        ℝ →                      // Cosmological constant Λ
        Tensor(0, 2, dim, ℝ) →  // Stress-energy Tᵤᵥ
        Bool                     // True if equation satisfied
}

implements EinsteinEquations(dim) {
    operation field_equation = builtin_einstein_field_equations
}

/* Common Spacetime Metrics
 * 
 * Predefined metrics for standard spacetimes.
 * These enable quick setup for common GR problems.
 */
structure StandardMetrics(dim: Nat) {
    operation minkowski : Tensor(0, 2, dim, ℝ)
    operation schwarzschild : ℝ → Tensor(0, 2, 4, ℝ)
    operation kerr : ℝ → ℝ → Tensor(0, 2, 4, ℝ)
    operation flrw : ℝ → ℝ → Tensor(0, 2, 4, ℝ)
}

implements StandardMetrics(dim) {
    operation minkowski = builtin_minkowski_metric
    operation schwarzschild = builtin_schwarzschild_metric
    operation kerr = builtin_kerr_metric
    operation flrw = builtin_flrw_metric
}

// ============================================
// xAct/xTensor-Style Tensor Algebra
// ============================================
//
// These structures define tensor operations using xAct-style notation.
// The sign of indices determines variance:
//   - Positive (μ): contravariant (upper index)
//   - Negative (-μ): covariant (lower index)

/* Index Contraction (Einstein Summation)
 * 
 * When a contravariant index and covariant index share the same name,
 * they are contracted (summed over).
 * 
 * Example: T(μ, -μ) = Σ_μ T^μ_μ (trace)
 * 
 * Axiom: Contraction of repeated indices produces a lower-rank tensor.
 */
structure IndexContraction(dim: Nat) {
    operation contract : Tensor(1, 1, dim, ℝ) → ℝ
    
    // Contraction is well-defined (returns a value)
    // Note: Type judgments (expr : Type) require parser extension
    // For now, we document the type in the operation signature above
}

implements IndexContraction(dim) {
    operation contract = builtin_trace
}

/* Metric Index Raising/Lowering
 * 
 * The metric tensor relates contravariant and covariant indices:
 *   - Raise: V^μ = g^{μν} V_ν
 *   - Lower: V_μ = g_{μν} V^ν
 * 
 * xAct notation:
 *   - V(μ) raised from V(-μ) using g(μ, ν)
 *   - V(-μ) lowered from V(μ) using g(-μ, -ν)
 */
structure MetricIndexOps(dim: Nat) {
    operation raise : Tensor(2, 0, dim, ℝ) → Tensor(0, 1, dim, ℝ) → Tensor(1, 0, dim, ℝ)
    operation lower : Tensor(0, 2, dim, ℝ) → Tensor(1, 0, dim, ℝ) → Tensor(0, 1, dim, ℝ)
    
    // Raising then lowering returns original
    axiom raise_lower_identity : ∀ g_up : Tensor(2, 0, dim, ℝ) .
        ∀ g_down : Tensor(0, 2, dim, ℝ) .
        ∀ V : Tensor(1, 0, dim, ℝ) .
        raise(g_up, lower(g_down, V)) = V
    
    // Lowering then raising returns original
    axiom lower_raise_identity : ∀ g_up : Tensor(2, 0, dim, ℝ) .
        ∀ g_down : Tensor(0, 2, dim, ℝ) .
        ∀ W : Tensor(0, 1, dim, ℝ) .
        lower(g_down, raise(g_up, W)) = W
}

implements MetricIndexOps(dim) {
    operation raise = builtin_raise_with_metric
    operation lower = builtin_lower_with_metric
}

/* Tensor Component Accessors
 * 
 * These operations extract individual components from tensors.
 * They are ESSENTIAL for Z3 to verify tensor axioms correctly.
 * 
 * Without proper type signatures, Z3 defaults to Int → Int and
 * cannot apply symmetry/Bianchi axioms properly.
 * 
 * Convention:
 *   - component  : 2-index tensors (metric g_μν)
 *   - component3 : 3-index tensors (Christoffel Γ^λ_μν)
 *   - component4 : 4-index tensors (Riemann R^ρ_σμν)
 */
structure TensorComponents(dim: Nat) {
    // 2-index tensor component: T_μν → T[μ][ν]
    operation component : Tensor(0, 2, dim, ℝ) → Nat → Nat → ℝ
    
    // 3-index tensor component: Γ^λ_μν → Γ[λ][μ][ν]
    operation component3 : Tensor(1, 2, dim, ℝ) → Nat → Nat → Nat → ℝ
    
    // 4-index tensor component: R^ρ_σμν → R[ρ][σ][μ][ν]
    operation component4 : Tensor(1, 3, dim, ℝ) → Nat → Nat → Nat → Nat → ℝ
}

implements TensorComponents(dim) {
    operation component = builtin_tensor_component
    operation component3 = builtin_tensor_component3
    operation component4 = builtin_tensor_component4
}

/* Kronecker Delta
 * 
 * The Kronecker delta δ^μ_ν is the identity tensor:
 *   δ^μ_ν = 1 if μ = ν, 0 otherwise
 * 
 * Essential properties:
 *   - g^{μρ} g_{ρν} = δ^μ_ν (metric inverse identity)
 *   - T^μ δ^ν_μ = T^ν (index substitution)
 *   - δ^μ_μ = dim (trace equals dimension)
 * 
 * In Z3, delta is an uninterpreted function constrained by axioms.
 */
structure KroneckerDelta(dim: Nat) {
    // Kronecker delta: δ(μ, ν) = 1 if μ=ν, else 0
    operation delta : Nat → Nat → ℝ
    
    // Diagonal is 1
    axiom delta_diagonal : ∀ μ : Nat .
        delta(μ, μ) = 1
    
    // Off-diagonal is 0 (for distinct indices)
    axiom delta_off_diagonal : ∀ μ : Nat . ∀ ν : Nat .
        (μ ≠ ν) → (delta(μ, ν) = 0)
}

implements KroneckerDelta(dim) {
    operation delta = builtin_kronecker_delta
}

/* Index Symmetrization
 * 
 * Symmetrize a tensor over specified indices:
 *   T_{(μν)} = (1/2)(T_{μν} + T_{νμ})
 * 
 * For n indices: sum over all permutations, divide by n!
 * 
 * Properties:
 *   - Idempotent: symmetrize(symmetrize(T)) = symmetrize(T)
 *   - Symmetric tensors are fixed points
 *   - Symmetric tensor: T_{μν} = T_{νμ}
 */
structure IndexSymmetrization(dim: Nat) {
    // Symmetrize over two indices
    operation symmetrize2 : Tensor(0, 2, dim, ℝ) → Tensor(0, 2, dim, ℝ)
    
    // Check if tensor is symmetric
    operation is_symmetric : Tensor(0, 2, dim, ℝ) → Bool
    
    // Symmetric tensor definition: T_{μν} = T_{νμ}
    axiom symmetric_def : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_symmetric(T) → (∀ μ : Nat . ∀ ν : Nat .
            component(T, μ, ν) = component(T, ν, μ))
    
    // Idempotence: symmetrizing twice = symmetrizing once
    axiom symmetrize2_idempotent : ∀ T : Tensor(0, 2, dim, ℝ) .
        symmetrize2(symmetrize2(T)) = symmetrize2(T)
    
    // Symmetric tensor is fixed point
    axiom symmetric_fixed_point : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_symmetric(T) → (symmetrize2(T) = T)
    
    // Result of symmetrization is symmetric
    axiom symmetrize2_is_symmetric : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_symmetric(symmetrize2(T))
}

implements IndexSymmetrization(dim) {
    operation symmetrize2 = builtin_symmetrize2
    operation is_symmetric = builtin_is_symmetric
}

/* Index Antisymmetrization
 * 
 * Antisymmetrize a tensor over specified indices:
 *   T_{[μν]} = (1/2)(T_{μν} - T_{νμ})
 * 
 * For n indices: sum over all permutations with sign, divide by n!
 * 
 * Properties:
 *   - Idempotent: antisymmetrize(antisymmetrize(T)) = antisymmetrize(T)
 *   - T_{[μν]} = -T_{[νμ]} (antisymmetry)
 *   - Antisymmetric tensors are fixed points
 *   - Forms (ω ∧ η) are antisymmetric
 */
structure IndexAntisymmetrization(dim: Nat) {
    // Antisymmetrize over two indices
    operation antisymmetrize2 : Tensor(0, 2, dim, ℝ) → Tensor(0, 2, dim, ℝ)
    
    // Check if tensor is antisymmetric
    operation is_antisymmetric : Tensor(0, 2, dim, ℝ) → Bool
    
    // Antisymmetric tensor definition: T_{μν} = -T_{νμ}
    axiom antisymmetric_def : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_antisymmetric(T) → (∀ μ : Nat . ∀ ν : Nat .
            component(T, μ, ν) = negate(component(T, ν, μ)))
    
    // Antisymmetric diagonal is zero: T_{μμ} = 0
    axiom antisymmetric_diagonal_zero : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_antisymmetric(T) → (∀ μ : Nat . component(T, μ, μ) = 0)
    
    // Result is antisymmetric
    axiom antisymmetrize2_antisym : ∀ T : Tensor(0, 2, dim, ℝ) .
        ∀ μ : Nat . ∀ ν : Nat .
        component(antisymmetrize2(T), μ, ν) = 
            negate(component(antisymmetrize2(T), ν, μ))
    
    // Idempotence
    axiom antisymmetrize2_idempotent : ∀ T : Tensor(0, 2, dim, ℝ) .
        antisymmetrize2(antisymmetrize2(T)) = antisymmetrize2(T)
    
    // Antisymmetric tensor is fixed point
    axiom antisymmetric_fixed_point : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_antisymmetric(T) → (antisymmetrize2(T) = T)
    
    // Result of antisymmetrization is antisymmetric
    axiom antisymmetrize2_is_antisymmetric : ∀ T : Tensor(0, 2, dim, ℝ) .
        is_antisymmetric(antisymmetrize2(T))
}

implements IndexAntisymmetrization(dim) {
    operation antisymmetrize2 = builtin_antisymmetrize2
    operation is_antisymmetric = builtin_is_antisymmetric
}

/* Metric Symmetry via is_symmetric predicate
 * 
 * The metric tensor is symmetric by definition.
 */
structure MetricSymmetryPredicate(dim: Nat) {
    axiom metric_is_symmetric : ∀ g : Tensor(0, 2, dim, ℝ) .
        is_symmetric(g)
}

/* Metric Tensor Symmetry
 * 
 * The metric tensor is symmetric: g_μν = g_νμ
 * In xAct notation: g(-μ, -ν) = g(-ν, -μ)
 */
structure MetricSymmetry(dim: Nat) {
    axiom metric_symmetric : ∀ g : Tensor(0, 2, dim, ℝ) .
        ∀ μ : Nat . ∀ ν : Nat .
        component(g, μ, ν) = component(g, ν, μ)
}

/* Riemann Tensor Symmetries
 * 
 * The Riemann tensor R^ρ_σμν has several symmetries:
 *   1. Antisymmetric in last two indices: R^ρ_σμν = -R^ρ_σνμ
 *   2. First Bianchi identity: R^ρ_[σμν] = 0 (cyclic sum)
 */
structure RiemannSymmetries(dim: Nat) {
    // Antisymmetry in μ, ν
    axiom riemann_antisym_34 : ∀ R : Tensor(1, 3, dim, ℝ) .
        ∀ ρ : Nat . ∀ σ : Nat . ∀ μ : Nat . ∀ ν : Nat .
        component4(R, ρ, σ, μ, ν) = negate(component4(R, ρ, σ, ν, μ))
    
    // First Bianchi identity (cyclic sum = 0)
    axiom riemann_bianchi_1 : ∀ R : Tensor(1, 3, dim, ℝ) .
        ∀ ρ : Nat . ∀ σ : Nat . ∀ μ : Nat . ∀ ν : Nat .
        plus(component4(R, ρ, σ, μ, ν),
             plus(component4(R, ρ, μ, ν, σ),
                  component4(R, ρ, ν, σ, μ))) = 0
}

/* Christoffel Symbol Symmetry
 * 
 * Christoffel symbols Γ^λ_μν are symmetric in lower indices: Γ^λ_μν = Γ^λ_νμ
 * In xAct notation: Γ(λ, -μ, -ν) = Γ(λ, -ν, -μ)
 */
structure ChristoffelSymmetry(dim: Nat) {
    // Note: Using ASCII identifiers due to parser reserved symbols (λ, Γ)
    axiom christoffel_symmetric : ∀ conn : Tensor(1, 2, dim, ℝ) .
        ∀ l : Nat . ∀ m : Nat . ∀ n : Nat .
        component3(conn, l, m, n) = component3(conn, l, n, m)
}

/* Tensor Addition
 * 
 * Tensors of the same rank can be added component-wise.
 */
structure TensorAddition(upper: Nat, lower: Nat, dim: Nat) {
    operation add : Tensor(upper, lower, dim, ℝ) → Tensor(upper, lower, dim, ℝ) → Tensor(upper, lower, dim, ℝ)
    
    // Commutativity
    axiom add_commutative : ∀ A : Tensor(upper, lower, dim, ℝ) .
        ∀ B : Tensor(upper, lower, dim, ℝ) .
        add(A, B) = add(B, A)
    
    // Associativity
    axiom add_associative : ∀ A : Tensor(upper, lower, dim, ℝ) .
        ∀ B : Tensor(upper, lower, dim, ℝ) .
        ∀ C : Tensor(upper, lower, dim, ℝ) .
        add(add(A, B), C) = add(A, add(B, C))
}

implements TensorAddition(upper, lower, dim) {
    operation add = builtin_tensor_add
}

/* Scalar Multiplication
 * 
 * Tensors can be multiplied by scalars.
 */
structure TensorScalarMult(upper: Nat, lower: Nat, dim: Nat) {
    operation scale : ℝ → Tensor(upper, lower, dim, ℝ) → Tensor(upper, lower, dim, ℝ)
    
    // Distributivity over scalar addition
    axiom scale_distributes : ∀ a : ℝ . ∀ b : ℝ .
        ∀ T : Tensor(upper, lower, dim, ℝ) .
        scale(plus(a, b), T) = add(scale(a, T), scale(b, T))
    
    // Identity: scaling by 1 does nothing
    axiom scale_identity : ∀ T : Tensor(upper, lower, dim, ℝ) .
        scale(1, T) = T
}

implements TensorScalarMult(upper, lower, dim) {
    operation scale = builtin_tensor_scale
}

