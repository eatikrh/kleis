// ============================================
// Kleis Standard Library - Cartan Computation
// Actual Computation of Curvature Tensors
// ============================================
//
// This module bridges symbolic_diff.kleis (Expr AST, diff function)
// to ACTUALLY COMPUTE curvature tensors via differential forms.
//
// Representation:
//   1-form: List of 4 Expr coefficients [ω_0, ω_1, ω_2, ω_3]
//   2-form: List of 4 lists (4x4 matrix) of Expr coefficients
//
// The exterior derivative d uses our diff function from symbolic_diff.kleis!

import "stdlib/symbolic_diff.kleis"

// ============================================
// Coordinate System
// ============================================

// Standard 4D coordinates for general relativity
define coord_names = ["t", "r", "theta", "phi"]

// Get coordinate name by index
define coord(mu) = nth(coord_names, mu)

// Dimension
define dim = 4

// ============================================
// Coordinate 1-forms (basis)
// ============================================

// 1-form is a list of 4 coefficients: [c_t, c_r, c_θ, c_φ]
// dt = (1, 0, 0, 0) means ω = 1·dt + 0·dr + 0·dθ + 0·dφ

define dt = [Const(1), Const(0), Const(0), Const(0)]
define dr = [Const(0), Const(1), Const(0), Const(0)]
define dtheta = [Const(0), Const(0), Const(1), Const(0)]
define dphi = [Const(0), Const(0), Const(0), Const(1)]

// Zero 1-form
define zero1 = [Const(0), Const(0), Const(0), Const(0)]

// Zero 2-form (4x4 matrix of zeros)
define zero2 = [
    [Const(0), Const(0), Const(0), Const(0)],
    [Const(0), Const(0), Const(0), Const(0)],
    [Const(0), Const(0), Const(0), Const(0)],
    [Const(0), Const(0), Const(0), Const(0)]
]

// ============================================
// Form Arithmetic
// ============================================

// Scale a 1-form by a scalar expression
define scale1(f, omega) = [
    simplify(Mul(f, nth(omega, 0))),
    simplify(Mul(f, nth(omega, 1))),
    simplify(Mul(f, nth(omega, 2))),
    simplify(Mul(f, nth(omega, 3)))
]

// Add two 1-forms
define add1(a, b) = [
    simplify(Add(nth(a, 0), nth(b, 0))),
    simplify(Add(nth(a, 1), nth(b, 1))),
    simplify(Add(nth(a, 2), nth(b, 2))),
    simplify(Add(nth(a, 3), nth(b, 3)))
]

// Add two 2-forms
define add2(a, b) = [
    [simplify(Add(nth(nth(a, 0), 0), nth(nth(b, 0), 0))),
     simplify(Add(nth(nth(a, 0), 1), nth(nth(b, 0), 1))),
     simplify(Add(nth(nth(a, 0), 2), nth(nth(b, 0), 2))),
     simplify(Add(nth(nth(a, 0), 3), nth(nth(b, 0), 3)))],
    [simplify(Add(nth(nth(a, 1), 0), nth(nth(b, 1), 0))),
     simplify(Add(nth(nth(a, 1), 1), nth(nth(b, 1), 1))),
     simplify(Add(nth(nth(a, 1), 2), nth(nth(b, 1), 2))),
     simplify(Add(nth(nth(a, 1), 3), nth(nth(b, 1), 3)))],
    [simplify(Add(nth(nth(a, 2), 0), nth(nth(b, 2), 0))),
     simplify(Add(nth(nth(a, 2), 1), nth(nth(b, 2), 1))),
     simplify(Add(nth(nth(a, 2), 2), nth(nth(b, 2), 2))),
     simplify(Add(nth(nth(a, 2), 3), nth(nth(b, 2), 3)))],
    [simplify(Add(nth(nth(a, 3), 0), nth(nth(b, 3), 0))),
     simplify(Add(nth(nth(a, 3), 1), nth(nth(b, 3), 1))),
     simplify(Add(nth(nth(a, 3), 2), nth(nth(b, 3), 2))),
     simplify(Add(nth(nth(a, 3), 3), nth(nth(b, 3), 3)))]
]

// ============================================
// Exterior Derivative d
// ============================================

/* Exterior Derivative of 0-form (scalar function)
 *
 * d(f) = Σ_μ (∂f/∂x^μ) dx^μ = [∂f/∂t, ∂f/∂r, ∂f/∂θ, ∂f/∂φ]
 *
 * We use coordinate-specific diff functions from symbolic_diff.kleis
 * that avoid conditional explosion by pattern matching on variable names.
 */
define d0(f) = [
    simplify(diff_wrt_t(f)),
    simplify(diff_wrt_r(f)),
    simplify(diff_wrt_theta(f)),
    simplify(diff_wrt_phi(f))
]

/* Exterior Derivative of 1-form
 *
 * d(ω) = d(ω_μ dx^μ)
 * 
 * (d(ω))_μν = ∂ω_ν/∂x^μ - ∂ω_μ/∂x^ν  (antisymmetric!)
 *
 * Uses coordinate-specific diff functions to avoid conditional explosion.
 */
define d1(omega) = 
    let w0 = nth(omega, 0) in
    let w1 = nth(omega, 1) in
    let w2 = nth(omega, 2) in
    let w3 = nth(omega, 3) in
    [
        // Row 0: d/dt derivatives
        [Const(0),
         simplify(Sub(diff_wrt_t(w1), diff_wrt_r(w0))),
         simplify(Sub(diff_wrt_t(w2), diff_wrt_theta(w0))),
         simplify(Sub(diff_wrt_t(w3), diff_wrt_phi(w0)))],
        // Row 1: d/dr derivatives
        [simplify(Sub(diff_wrt_r(w0), diff_wrt_t(w1))),
         Const(0),
         simplify(Sub(diff_wrt_r(w2), diff_wrt_theta(w1))),
         simplify(Sub(diff_wrt_r(w3), diff_wrt_phi(w1)))],
        // Row 2: d/dθ derivatives
        [simplify(Sub(diff_wrt_theta(w0), diff_wrt_t(w2))),
         simplify(Sub(diff_wrt_theta(w1), diff_wrt_r(w2))),
         Const(0),
         simplify(Sub(diff_wrt_theta(w3), diff_wrt_phi(w2)))],
        // Row 3: d/dφ derivatives
        [simplify(Sub(diff_wrt_phi(w0), diff_wrt_t(w3))),
         simplify(Sub(diff_wrt_phi(w1), diff_wrt_r(w3))),
         simplify(Sub(diff_wrt_phi(w2), diff_wrt_theta(w3))),
         Const(0)]
    ]

// ============================================
// Wedge Product
// ============================================

/* Wedge Product of two 1-forms
 *
 * (α ∧ β)_μν = α_μ β_ν - α_ν β_μ
 */
define wedge(a, b) =
    let a0 = nth(a, 0) in let a1 = nth(a, 1) in
    let a2 = nth(a, 2) in let a3 = nth(a, 3) in
    let b0 = nth(b, 0) in let b1 = nth(b, 1) in
    let b2 = nth(b, 2) in let b3 = nth(b, 3) in
    [
        [Const(0),
         simplify(Sub(Mul(a0, b1), Mul(a1, b0))),
         simplify(Sub(Mul(a0, b2), Mul(a2, b0))),
         simplify(Sub(Mul(a0, b3), Mul(a3, b0)))],
        [simplify(Sub(Mul(a1, b0), Mul(a0, b1))),
         Const(0),
         simplify(Sub(Mul(a1, b2), Mul(a2, b1))),
         simplify(Sub(Mul(a1, b3), Mul(a3, b1)))],
        [simplify(Sub(Mul(a2, b0), Mul(a0, b2))),
         simplify(Sub(Mul(a2, b1), Mul(a1, b2))),
         Const(0),
         simplify(Sub(Mul(a2, b3), Mul(a3, b2)))],
        [simplify(Sub(Mul(a3, b0), Mul(a0, b3))),
         simplify(Sub(Mul(a3, b1), Mul(a1, b3))),
         simplify(Sub(Mul(a3, b2), Mul(a2, b3))),
         Const(0)]
    ]

// ============================================
// Schwarzschild Metric
// ============================================

/* Schwarzschild Tetrad
 *
 * ds² = -(1-2M/r)dt² + dr²/(1-2M/r) + r²dθ² + r²sin²θ dφ²
 *
 * Tetrad (orthonormal frame):
 *   e^0 = √(1-2M/r) dt
 *   e^1 = dr / √(1-2M/r)
 *   e^2 = r dθ
 *   e^3 = r sin(θ) dφ
 */

// f(r) = 1 - 2M/r
define schw_f(M) = Sub(Const(1), Div(Mul(Const(2), M), Var("r")))

// √f
define schw_sqrt_f(M) = Sqrt(schw_f(M))

// Schwarzschild tetrad as list of 4 1-forms
define schwarzschild_tetrad(M) = [
    scale1(schw_sqrt_f(M), dt),                              // e^0
    scale1(Div(Const(1), schw_sqrt_f(M)), dr),               // e^1
    scale1(Var("r"), dtheta),                                // e^2
    scale1(Mul(Var("r"), Sin(Var("theta"))), dphi)           // e^3
]

// ============================================
// Minkowski Tetrad (Flat Space)
// ============================================

define minkowski_tetrad = [
    dt,                                          // e^0 = dt
    dr,                                          // e^1 = dr
    scale1(Var("r"), dtheta),                    // e^2 = r dθ
    scale1(Mul(Var("r"), Sin(Var("theta"))), dphi) // e^3 = r sin(θ) dφ
]

// ============================================
// Compute de^a (exterior derivatives of tetrad)
// ============================================

define d_tetrad(tetrad) = [
    d1(nth(tetrad, 0)),
    d1(nth(tetrad, 1)),
    d1(nth(tetrad, 2)),
    d1(nth(tetrad, 3))
]

// ============================================
// Curvature: R = dω + ω∧ω
// ============================================

/* Given connection ω^a_b (4x4 matrix of 1-forms),
 * compute curvature R^a_b = dω^a_b + Σ_c ω^a_c ∧ ω^c_b
 *
 * This IS the Riemann curvature tensor in form language!
 */

// For a single component R^a_b:
define curvature_component(omega, a, b) =
    let omega_ab = nth(nth(omega, a), b) in
    let d_omega_ab = d1(omega_ab) in
    // Add Σ_c ω^a_c ∧ ω^c_b
    let wedge_sum = 
        add2(add2(
            wedge(nth(nth(omega, a), 0), nth(nth(omega, 0), b)),
            wedge(nth(nth(omega, a), 1), nth(nth(omega, 1), b))),
            add2(
            wedge(nth(nth(omega, a), 2), nth(nth(omega, 2), b)),
            wedge(nth(nth(omega, a), 3), nth(nth(omega, 3), b))))
    in
    add2(d_omega_ab, wedge_sum)

// ============================================
// Ricci Tensor Components
// ============================================

/* Ricci from curvature 2-forms:
 * Ric_ab = trace over curvature = Σ_c R^c_acb
 *
 * For 2-forms, we extract components:
 * Ric(a,b) = Σ_c (R^c_c)_{ab}
 */
define ricci_component(R, a, b) =
    // Sum of (a,b) components of R^c_c
    simplify(Add(Add(
        nth(nth(nth(nth(R, 0), 0), a), b),
        nth(nth(nth(nth(R, 1), 1), a), b)),
        Add(
        nth(nth(nth(nth(R, 2), 2), a), b),
        nth(nth(nth(nth(R, 3), 3), a), b))))

// ============================================
// Ricci Scalar
// ============================================

// R = η^ab Ric_ab = -Ric_00 + Ric_11 + Ric_22 + Ric_33
define ricci_scalar(ric) =
    simplify(Add(Add(
        Neg(nth(nth(ric, 0), 0)),
        nth(nth(ric, 1), 1)),
        Add(
        nth(nth(ric, 2), 2),
        nth(nth(ric, 3), 3))))

// ============================================
// Simple Example: d(r²)
// ============================================

// Test: d(r²) should give 2r in the dr component
define test_d_r_squared = d0(Pow(Var("r"), Const(2)))

// Test: d(sin(θ)) should give cos(θ) in the dθ component
define test_d_sin_theta = d0(Sin(Var("theta")))

// Test: dt ∧ dr should be non-zero only at (0,1) and (1,0)
define test_wedge_dt_dr = wedge(dt, dr)

// ============================================
// Connection Solver (Torsion-Free)
// ============================================

/* Solve for Levi-Civita Connection
 *
 * Given tetrad e^a, the torsion-free condition de^a + ω^a_b ∧ e^b = 0
 * has an explicit solution:
 *
 *   ω^a_b = ½(C^a_bc - C^b_ac + C^c_ab) e^c
 *
 * where C^a_bc are the anholonomy coefficients:
 *   de^a = ½ C^a_bc e^b ∧ e^c
 *
 * For our coordinate basis representation, C^a_bc = (de^a)_bc
 */

// Extract anholonomy coefficient C^a_bc from de^a
// de^a is stored as a 4x4 matrix, C^a_bc = (de^a)[b][c]
define get_C(de, a, b, c) = nth(nth(nth(de, a), b), c)

// Compute connection component ω^a_b
// ω^a_b = Σ_c ½(C^a_bc - C^b_ac + C^c_ab) e^c
define connection_ab(de, tetrad, a, b) =
    // Sum over c = 0,1,2,3
    let c0_coeff = simplify(Mul(Div(Const(1), Const(2)), 
        Add(get_C(de, a, b, 0), Sub(get_C(de, 0, a, b), get_C(de, b, a, 0))))) in
    let c1_coeff = simplify(Mul(Div(Const(1), Const(2)),
        Add(get_C(de, a, b, 1), Sub(get_C(de, 1, a, b), get_C(de, b, a, 1))))) in
    let c2_coeff = simplify(Mul(Div(Const(1), Const(2)),
        Add(get_C(de, a, b, 2), Sub(get_C(de, 2, a, b), get_C(de, b, a, 2))))) in
    let c3_coeff = simplify(Mul(Div(Const(1), Const(2)),
        Add(get_C(de, a, b, 3), Sub(get_C(de, 3, a, b), get_C(de, b, a, 3))))) in
    // ω^a_b = c0 * e^0 + c1 * e^1 + c2 * e^2 + c3 * e^3
    add1(add1(
        scale1(c0_coeff, nth(tetrad, 0)),
        scale1(c1_coeff, nth(tetrad, 1))),
        add1(
        scale1(c2_coeff, nth(tetrad, 2)),
        scale1(c3_coeff, nth(tetrad, 3))))

// Full connection matrix ω^a_b (4x4 matrix of 1-forms)
define solve_connection(tetrad) =
    let de = d_tetrad(tetrad) in
    [
        [connection_ab(de, tetrad, 0, 0), connection_ab(de, tetrad, 0, 1),
         connection_ab(de, tetrad, 0, 2), connection_ab(de, tetrad, 0, 3)],
        [connection_ab(de, tetrad, 1, 0), connection_ab(de, tetrad, 1, 1),
         connection_ab(de, tetrad, 1, 2), connection_ab(de, tetrad, 1, 3)],
        [connection_ab(de, tetrad, 2, 0), connection_ab(de, tetrad, 2, 1),
         connection_ab(de, tetrad, 2, 2), connection_ab(de, tetrad, 2, 3)],
        [connection_ab(de, tetrad, 3, 0), connection_ab(de, tetrad, 3, 1),
         connection_ab(de, tetrad, 3, 2), connection_ab(de, tetrad, 3, 3)]
    ]

// ============================================
// Full Curvature Computation
// ============================================

// Compute curvature R^a_b = dω^a_b + Σ_c ω^a_c ∧ ω^c_b
define curvature_ab(omega, a, b) =
    let omega_ab = nth(nth(omega, a), b) in
    let d_omega = d1(omega_ab) in
    // Add wedge products
    let w0 = wedge(nth(nth(omega, a), 0), nth(nth(omega, 0), b)) in
    let w1 = wedge(nth(nth(omega, a), 1), nth(nth(omega, 1), b)) in
    let w2 = wedge(nth(nth(omega, a), 2), nth(nth(omega, 2), b)) in
    let w3 = wedge(nth(nth(omega, a), 3), nth(nth(omega, 3), b)) in
    add2(d_omega, add2(add2(w0, w1), add2(w2, w3)))

// Full curvature matrix R^a_b (4x4 matrix of 2-forms)
define compute_curvature(omega) = [
    [curvature_ab(omega, 0, 0), curvature_ab(omega, 0, 1),
     curvature_ab(omega, 0, 2), curvature_ab(omega, 0, 3)],
    [curvature_ab(omega, 1, 0), curvature_ab(omega, 1, 1),
     curvature_ab(omega, 1, 2), curvature_ab(omega, 1, 3)],
    [curvature_ab(omega, 2, 0), curvature_ab(omega, 2, 1),
     curvature_ab(omega, 2, 2), curvature_ab(omega, 2, 3)],
    [curvature_ab(omega, 3, 0), curvature_ab(omega, 3, 1),
     curvature_ab(omega, 3, 2), curvature_ab(omega, 3, 3)]
]

// ============================================
// Complete Pipeline: Tetrad → Riemann
// ============================================

// Given a tetrad, compute the full Riemann curvature!
define compute_riemann(tetrad) =
    let omega = solve_connection(tetrad) in
    compute_curvature(omega)

// Test: Minkowski should have zero curvature
define minkowski_curvature = compute_riemann(minkowski_tetrad)

// Test: Schwarzschild curvature (the actual Riemann tensor!)
define schwarzschild_curvature(M) = compute_riemann(schwarzschild_tetrad(M))

// ============================================
// Summary
// ============================================

/* What we can now compute:
 *
 * 1. d0(f) - exterior derivative of scalar → 1-form
 *    Uses diff() from symbolic_diff.kleis
 *
 * 2. d1(ω) - exterior derivative of 1-form → 2-form
 *    Uses diff() for each partial derivative
 *
 * 3. wedge(α, β) - wedge product of 1-forms → 2-form
 *
 * 4. schwarzschild_tetrad(M) - orthonormal frame for Schwarzschild
 *
 * 5. d_tetrad(e) - exterior derivatives of tetrad 1-forms
 *
 * Next steps to complete:
 * - solve_connection: solve de^a + ω∧e = 0 for ω
 * - compute_curvature: R = dω + ω∧ω for all (a,b)
 * - compute_ricci: contract curvature to Ricci
 * - compute_einstein: G = Ric - ½R g
 */
