// Generated by Kleis Cross-Compiler
// https://github.com/eatikrh/kleis
//
// Source: more_examples.kleis

// ============================================================================
// 1. ALGEBRAIC DATA TYPES
// ============================================================================

// data Color = Red | Green | Blue
#[derive(Debug, Clone, PartialEq)]
enum Color {
    Red,
    Green,
    Blue,
}

// data Maybe(T) = Nothing | Just(value: T)
#[derive(Debug, Clone, PartialEq)]
enum Maybe<T> {
    Nothing,
    Just { value: T },
}

// data Either(A, B) = Left(value: A) | Right(value: B)
#[derive(Debug, Clone, PartialEq)]
enum Either<A, B> {
    Left { value: A },
    Right { value: B },
}

// data BinTree(T) = Empty | Node(value: T, left: BinTree(T), right: BinTree(T))
#[derive(Debug, Clone, PartialEq)]
enum BinTree<T> {
    Empty,
    Node { value: T, left: Box<BinTree<T>>, right: Box<BinTree<T>> },
}

// data Expr = Num(n: ℤ) | Var(name: String) | Add(...) | Mul(...) | Neg(...)
#[derive(Debug, Clone, PartialEq)]
enum Expr {
    Num { n: i64 },
    Var { name: String },
    Add { left: Box<Expr>, right: Box<Expr> },
    Mul { left: Box<Expr>, right: Box<Expr> },
    Neg { inner: Box<Expr> },
}


// ============================================================================
// 2. PATTERN MATCHING
// ============================================================================

// define color_to_rgb(c : Color) : ℕ = match c { Red => ... | Green => ... | Blue => ... }
fn color_to_rgb(c: &Color) -> u64 {
    match c {
        Color::Red => 16711680,
        Color::Green => 65280,
        Color::Blue => 255,
    }
}

// define unwrap_or(m : Maybe(ℕ), default : ℕ) : ℕ = match m { Nothing => default | Just(v) => v }
fn unwrap_or(m: &Maybe<u64>, default: u64) -> u64 {
    match m {
        Maybe::Nothing => default,
        Maybe::Just { value } => *value,
    }
}

// define either_to_nat(e : Either(ℕ, Bool)) : ℕ = match e { Left(n) => n | Right(true) => 1 | Right(false) => 0 }
fn either_to_nat(e: &Either<u64, bool>) -> u64 {
    match e {
        Either::Left { value } => *value,
        Either::Right { value: true } => 1,
        Either::Right { value: false } => 0,
    }
}

// define tree_size(t : BinTree(ℕ)) : ℕ = match t { Empty => 0 | Node(_, left, right) => 1 + ... }
fn tree_size(t: &BinTree<u64>) -> u64 {
    match t {
        BinTree::Empty => 0,
        BinTree::Node { value: _, left, right } => 1 + tree_size(left) + tree_size(right),
    }
}

// define tree_sum(t : BinTree(ℕ)) : ℕ = match t { Empty => 0 | Node(v, left, right) => v + ... }
fn tree_sum(t: &BinTree<u64>) -> u64 {
    match t {
        BinTree::Empty => 0,
        BinTree::Node { value, left, right } => value + tree_sum(left) + tree_sum(right),
    }
}

// define eval_expr(e : Expr) : ℤ = match e { Num(n) => n | Var(_) => 0 | Add(l, r) => ... | ... }
fn eval_expr(e: &Expr) -> i64 {
    match e {
        Expr::Num { n } => *n,
        Expr::Var { name: _ } => 0,
        Expr::Add { left, right } => eval_expr(left) + eval_expr(right),
        Expr::Mul { left, right } => eval_expr(left) * eval_expr(right),
        Expr::Neg { inner } => -eval_expr(inner),
    }
}


// ============================================================================
// 3. LET BINDINGS
// ============================================================================

// define quadratic(a, b, c, x) = let x2 = x * x in a * x2 + b * x + c
fn quadratic(a: f64, b: f64, c: f64, x: f64) -> f64 {
    let x2 = x * x;
    a * x2 + b * x + c
}

// define distance(x1, y1, x2, y2) = let dx = x2 - x1 in let dy = y2 - y1 in sqrt(dx*dx + dy*dy)
fn distance(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    (dx * dx + dy * dy).sqrt()
}

// define swap_pair(p) = let (a, b) = p in (b, a)
fn swap_pair(p: (u64, u64)) -> (u64, u64) {
    let (a, b) = p;
    (b, a)
}


// ============================================================================
// 4. HIGHER-ORDER FUNCTIONS
// ============================================================================

// define map_maybe(f, m) = match m { Nothing => Nothing | Just(v) => Just(f(v)) }
fn map_maybe<F: Fn(u64) -> u64>(f: F, m: &Maybe<u64>) -> Maybe<u64> {
    match m {
        Maybe::Nothing => Maybe::Nothing,
        Maybe::Just { value } => Maybe::Just { value: f(*value) },
    }
}

// define fold_tree(f, zero, t) = match t { Empty => zero | Node(v, l, r) => f(v, fold_tree(...), fold_tree(...)) }
fn fold_tree<F: Fn(u64, u64, u64) -> u64 + Copy>(f: F, zero: u64, t: &BinTree<u64>) -> u64 {
    match t {
        BinTree::Empty => zero,
        BinTree::Node { value, left, right } => f(*value, fold_tree(f, zero, left), fold_tree(f, zero, right)),
    }
}

// define compose(f, g, x) = f(g(x))
fn compose<F: Fn(u64) -> u64, G: Fn(u64) -> u64>(f: F, g: G, x: u64) -> u64 {
    f(g(x))
}

// define twice(f, x) = f(f(x))
fn twice<F: Fn(u64) -> u64 + Copy>(f: F, x: u64) -> u64 {
    f(f(x))
}


// ============================================================================
// 5. LAMBDA EXPRESSIONS
// ============================================================================

// define add_n(n) = λ x . x + n
fn add_n(n: u64) -> impl Fn(u64) -> u64 {
    move |x| x + n
}

// define multiplier(n) = λ x . x * n
fn multiplier(n: u64) -> impl Fn(u64) -> u64 {
    move |x| x * n
}

// define curry_add = λ x . λ y . x + y
fn curry_add() -> impl Fn(u64) -> Box<dyn Fn(u64) -> u64> {
    |x| Box::new(move |y| x + y)
}


// ============================================================================
// 6. IF-THEN-ELSE
// ============================================================================

// define abs(x) = if x < 0 then 0 - x else x
fn abs_val(x: i64) -> i64 {
    if x < 0 { -x } else { x }
}

// define max(a, b) = if a > b then a else b
fn max_val(a: u64, b: u64) -> u64 {
    if a > b { a } else { b }
}

// define min(a, b) = if a < b then a else b
fn min_val(a: u64, b: u64) -> u64 {
    if a < b { a } else { b }
}

// define clamp(x, lo, hi) = if x < lo then lo else if x > hi then hi else x
fn clamp(x: u64, lo: u64, hi: u64) -> u64 {
    if x < lo { lo } else if x > hi { hi } else { x }
}

// define sign(x) = if x < 0 then -1 else if x > 0 then 1 else 0
fn sign(x: i64) -> i64 {
    if x < 0 { -1 } else if x > 0 { 1 } else { 0 }
}


// ============================================================================
// 7. RECURSIVE FUNCTIONS
// ============================================================================

// define gcd(a, b) = if b = 0 then a else gcd(b, a mod b)
fn gcd(a: u64, b: u64) -> u64 {
    if b == 0 { a } else { gcd(b, a % b) }
}

// define power(base, exp) = if exp = 0 then 1 else base * power(base, exp - 1)
fn power(base: u64, exp: u64) -> u64 {
    if exp == 0 { 1 } else { base * power(base, exp - 1) }
}

// define sum_to(n) = if n = 0 then 0 else n + sum_to(n - 1)
fn sum_to(n: u64) -> u64 {
    if n == 0 { 0 } else { n + sum_to(n - 1) }
}


// ============================================================================
// 8. LIST OPERATIONS
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
enum List<T> {
    Nil,
    Cons { head: T, tail: Box<List<T>> },
}

// define length(xs) = match xs { Nil => 0 | Cons(_, rest) => 1 + length(rest) }
fn length(xs: &List<u64>) -> u64 {
    match xs {
        List::Nil => 0,
        List::Cons { head: _, tail } => 1 + length(tail),
    }
}

// define reverse_acc(xs, acc) = match xs { Nil => acc | Cons(h, t) => reverse_acc(t, Cons(h, acc)) }
fn reverse_acc(xs: List<u64>, acc: List<u64>) -> List<u64> {
    match xs {
        List::Nil => acc,
        List::Cons { head, tail } => reverse_acc(*tail, List::Cons { head, tail: Box::new(acc) }),
    }
}

// define reverse(xs) = reverse_acc(xs, Nil)
fn reverse(xs: List<u64>) -> List<u64> {
    reverse_acc(xs, List::Nil)
}

// define append(xs, ys) = match xs { Nil => ys | Cons(h, t) => Cons(h, append(t, ys)) }
fn append(xs: List<u64>, ys: List<u64>) -> List<u64> {
    match xs {
        List::Nil => ys,
        List::Cons { head, tail } => List::Cons { head, tail: Box::new(append(*tail, ys)) },
    }
}

// define filter(p, xs) = match xs { Nil => Nil | Cons(h, t) => if p(h) then Cons(h, filter(p, t)) else filter(p, t) }
fn filter<F: Fn(u64) -> bool + Copy>(p: F, xs: List<u64>) -> List<u64> {
    match xs {
        List::Nil => List::Nil,
        List::Cons { head, tail } => {
            if p(head) {
                List::Cons { head, tail: Box::new(filter(p, *tail)) }
            } else {
                filter(p, *tail)
            }
        }
    }
}

// define take(n, xs) = if n = 0 then Nil else match xs { Nil => Nil | Cons(h, t) => Cons(h, take(n-1, t)) }
fn take(n: u64, xs: List<u64>) -> List<u64> {
    if n == 0 {
        List::Nil
    } else {
        match xs {
            List::Nil => List::Nil,
            List::Cons { head, tail } => List::Cons { head, tail: Box::new(take(n - 1, *tail)) },
        }
    }
}

// define drop(n, xs) = if n = 0 then xs else match xs { Nil => Nil | Cons(_, t) => drop(n-1, t) }
fn drop(n: u64, xs: List<u64>) -> List<u64> {
    if n == 0 {
        xs
    } else {
        match xs {
            List::Nil => List::Nil,
            List::Cons { head: _, tail } => drop(n - 1, *tail),
        }
    }
}


// ============================================================================
// MAIN - Test all constructs
// ============================================================================

fn main() {
    println!("=== Pattern Matching ===");
    println!("color_to_rgb(Red) = {} (0x{:06X})", color_to_rgb(&Color::Red), color_to_rgb(&Color::Red));
    println!("color_to_rgb(Green) = {} (0x{:06X})", color_to_rgb(&Color::Green), color_to_rgb(&Color::Green));
    println!("color_to_rgb(Blue) = {} (0x{:06X})", color_to_rgb(&Color::Blue), color_to_rgb(&Color::Blue));

    println!("\n=== Maybe/Option ===");
    println!("unwrap_or(Just(42), 0) = {}", unwrap_or(&Maybe::Just { value: 42 }, 0));
    println!("unwrap_or(Nothing, 99) = {}", unwrap_or(&Maybe::Nothing, 99));

    println!("\n=== Either ===");
    println!("either_to_nat(Left(7)) = {}", either_to_nat(&Either::Left { value: 7 }));
    println!("either_to_nat(Right(true)) = {}", either_to_nat(&Either::Right { value: true }));
    println!("either_to_nat(Right(false)) = {}", either_to_nat(&Either::Right { value: false }));

    println!("\n=== Binary Tree ===");
    let tree: BinTree<u64> = BinTree::Node {
        value: 10,
        left: Box::new(BinTree::Node {
            value: 5,
            left: Box::new(BinTree::Empty),
            right: Box::new(BinTree::Empty),
        }),
        right: Box::new(BinTree::Node {
            value: 15,
            left: Box::new(BinTree::Empty),
            right: Box::new(BinTree::Empty),
        }),
    };
    println!("tree_size = {}", tree_size(&tree));
    println!("tree_sum = {}", tree_sum(&tree));

    println!("\n=== Expression Evaluator ===");
    // (3 + 4) * 2 = 14
    let expr = Expr::Mul {
        left: Box::new(Expr::Add {
            left: Box::new(Expr::Num { n: 3 }),
            right: Box::new(Expr::Num { n: 4 }),
        }),
        right: Box::new(Expr::Num { n: 2 }),
    };
    println!("eval((3 + 4) * 2) = {}", eval_expr(&expr));

    // -(5 + 3) = -8
    let neg_expr = Expr::Neg {
        inner: Box::new(Expr::Add {
            left: Box::new(Expr::Num { n: 5 }),
            right: Box::new(Expr::Num { n: 3 }),
        }),
    };
    println!("eval(-(5 + 3)) = {}", eval_expr(&neg_expr));

    println!("\n=== Let Bindings ===");
    println!("quadratic(1, 2, 1, 3) = {} (should be 16)", quadratic(1.0, 2.0, 1.0, 3.0));
    println!("distance(0, 0, 3, 4) = {} (should be 5)", distance(0.0, 0.0, 3.0, 4.0));
    println!("swap_pair((1, 2)) = {:?}", swap_pair((1, 2)));

    println!("\n=== Higher-Order Functions ===");
    let doubled = map_maybe(|x| x * 2, &Maybe::Just { value: 21 });
    println!("map_maybe(x*2, Just(21)) = {:?}", doubled);
    println!("compose(x+1, x*2, 5) = {}", compose(|x| x + 1, |x| x * 2, 5));
    println!("twice(x*2, 3) = {}", twice(|x| x * 2, 3));

    println!("\n=== Lambdas ===");
    let add_5 = add_n(5);
    println!("add_n(5)(10) = {}", add_5(10));
    let times_3 = multiplier(3);
    println!("multiplier(3)(7) = {}", times_3(7));

    println!("\n=== If-Then-Else ===");
    println!("abs(-5) = {}", abs_val(-5));
    println!("max(3, 7) = {}", max_val(3, 7));
    println!("min(3, 7) = {}", min_val(3, 7));
    println!("clamp(15, 0, 10) = {}", clamp(15, 0, 10));
    println!("sign(-42) = {}", sign(-42));

    println!("\n=== Recursive Functions ===");
    println!("gcd(48, 18) = {}", gcd(48, 18));
    println!("power(2, 10) = {}", power(2, 10));
    println!("sum_to(10) = {}", sum_to(10));

    println!("\n=== List Operations ===");
    let list = List::Cons {
        head: 1,
        tail: Box::new(List::Cons {
            head: 2,
            tail: Box::new(List::Cons {
                head: 3,
                tail: Box::new(List::Cons {
                    head: 4,
                    tail: Box::new(List::Cons {
                        head: 5,
                        tail: Box::new(List::Nil),
                    }),
                }),
            }),
        }),
    };
    println!("length([1,2,3,4,5]) = {}", length(&list));
    let reversed = reverse(list.clone());
    println!("reverse([1,2,3,4,5]) = {:?}", reversed);
    let filtered = filter(|x| x % 2 == 0, list.clone());
    println!("filter(even, [1,2,3,4,5]) = {:?}", filtered);
    let taken = take(3, list.clone());
    println!("take(3, [1,2,3,4,5]) = {:?}", taken);
    let dropped = drop(2, list);
    println!("drop(2, [1,2,3,4,5]) = {:?}", dropped);

    println!("\n=== fold_tree ===");
    // Use fold to compute sum
    let sum_via_fold = fold_tree(|v, l, r| v + l + r, 0, &tree);
    println!("fold_tree(+, 0, tree) = {}", sum_via_fold);
}

