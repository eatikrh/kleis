// Generated by Kleis Cross-Compiler
// https://github.com/eatikrh/kleis
//
// Source: solver_api.kleis
//
// This is a Z3-backed implementation of the Kleis Solver API.
// Requires: z3 crate

use std::collections::HashMap;
use z3::ast::{Ast, Bool, Real};
use z3::{Config, Context, SatResult as Z3SatResult, Solver};

// ============================================================================
// 1. SOLVER RESULT TYPES
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
pub enum SatResult {
    Sat,
    Unsat,
    Unknown,
}

#[derive(Debug, Clone, PartialEq)]
pub enum VerifyResult {
    Valid,
    Invalid,
    Timeout,
}

#[derive(Debug, Clone)]
pub struct Binding {
    pub name: String,
    pub value: f64,
}

#[derive(Debug, Clone)]
pub enum Witness {
    NoWitness,
    Model(Vec<Binding>),
}

// ============================================================================
// 2. CONSTRAINT AND TERM TYPES
// ============================================================================

#[derive(Debug, Clone)]
pub enum Term {
    Var(String),
    Num(f64),
    Add(Box<Term>, Box<Term>),
    Sub(Box<Term>, Box<Term>),
    Mul(Box<Term>, Box<Term>),
    Div(Box<Term>, Box<Term>),
    Neg(Box<Term>),
}

#[derive(Debug, Clone)]
pub enum Constraint {
    True,
    False,
    Var(String),
    And(Box<Constraint>, Box<Constraint>),
    Or(Box<Constraint>, Box<Constraint>),
    Not(Box<Constraint>),
    Implies(Box<Constraint>, Box<Constraint>),
    ForAll(String, Box<Constraint>),
    Exists(String, Box<Constraint>),
    Eq(Term, Term),
    Lt(Term, Term),
    Le(Term, Term),
}

// ============================================================================
// 3. SMART CONSTRUCTORS (DSL)
// ============================================================================

impl Term {
    pub fn var(name: &str) -> Term {
        Term::Var(name.to_string())
    }

    pub fn num(n: f64) -> Term {
        Term::Num(n)
    }

    pub fn add(self, other: Term) -> Term {
        Term::Add(Box::new(self), Box::new(other))
    }

    pub fn sub(self, other: Term) -> Term {
        Term::Sub(Box::new(self), Box::new(other))
    }

    pub fn mul(self, other: Term) -> Term {
        Term::Mul(Box::new(self), Box::new(other))
    }

    pub fn div(self, other: Term) -> Term {
        Term::Div(Box::new(self), Box::new(other))
    }

    pub fn neg(self) -> Term {
        Term::Neg(Box::new(self))
    }
}

impl Constraint {
    pub fn and(self, other: Constraint) -> Constraint {
        Constraint::And(Box::new(self), Box::new(other))
    }

    pub fn or(self, other: Constraint) -> Constraint {
        Constraint::Or(Box::new(self), Box::new(other))
    }

    pub fn not(self) -> Constraint {
        Constraint::Not(Box::new(self))
    }

    pub fn implies(self, other: Constraint) -> Constraint {
        Constraint::Implies(Box::new(self), Box::new(other))
    }

    pub fn forall(var: &str, body: Constraint) -> Constraint {
        Constraint::ForAll(var.to_string(), Box::new(body))
    }

    pub fn exists(var: &str, body: Constraint) -> Constraint {
        Constraint::Exists(var.to_string(), Box::new(body))
    }

    pub fn eq(left: Term, right: Term) -> Constraint {
        Constraint::Eq(left, right)
    }

    pub fn lt(left: Term, right: Term) -> Constraint {
        Constraint::Lt(left, right)
    }

    pub fn le(left: Term, right: Term) -> Constraint {
        Constraint::Le(left, right)
    }
}

// ============================================================================
// 4. Z3 SOLVER IMPLEMENTATION
// ============================================================================

pub struct Z3Solver<'ctx> {
    ctx: &'ctx Context,
    solver: Solver<'ctx>,
}

impl<'ctx> Z3Solver<'ctx> {
    pub fn new(ctx: &'ctx Context) -> Self {
        Z3Solver {
            ctx,
            solver: Solver::new(ctx),
        }
    }

    /// Check satisfiability of a constraint
    pub fn check_sat(&self, constraint: &Constraint) -> SatResult {
        self.solver.reset();
        let mut vars = HashMap::new();
        let z3_expr = self.translate_constraint(constraint, &mut vars);
        self.solver.assert(&z3_expr);

        match self.solver.check() {
            Z3SatResult::Sat => SatResult::Sat,
            Z3SatResult::Unsat => SatResult::Unsat,
            Z3SatResult::Unknown => SatResult::Unknown,
        }
    }

    /// Check validity (is the constraint always true?)
    pub fn check_valid(&self, constraint: &Constraint) -> VerifyResult {
        // Valid iff negation is unsatisfiable
        let negated = negate_constraint(constraint);
        match self.check_sat(&negated) {
            SatResult::Unsat => VerifyResult::Valid,
            SatResult::Sat => VerifyResult::Invalid,
            SatResult::Unknown => VerifyResult::Timeout,
        }
    }

    /// Get a model (witness) if satisfiable
    pub fn get_model(&self, constraint: &Constraint) -> Witness {
        self.solver.reset();
        let mut vars = HashMap::new();
        let z3_expr = self.translate_constraint(constraint, &mut vars);
        self.solver.assert(&z3_expr);

        if self.solver.check() == Z3SatResult::Sat {
            if let Some(model) = self.solver.get_model() {
                let bindings: Vec<Binding> = vars
                    .iter()
                    .filter_map(|(name, var)| {
                        model.eval(var, true).and_then(|val| {
                            // Try to extract a rational value
                            val.as_real().map(|(num, den)| Binding {
                                name: name.clone(),
                                value: num as f64 / den as f64,
                            })
                        })
                    })
                    .collect();
                Witness::Model(bindings)
            } else {
                Witness::NoWitness
            }
        } else {
            Witness::NoWitness
        }
    }

    /// Translate a Kleis Term to Z3 Real
    fn translate_term<'a>(
        &self,
        term: &Term,
        vars: &mut HashMap<String, Real<'ctx>>,
    ) -> Real<'ctx> {
        match term {
            Term::Var(name) => {
                vars.entry(name.clone())
                    .or_insert_with(|| Real::new_const(self.ctx, name.as_str()))
                    .clone()
            }
            Term::Num(n) => {
                // Convert f64 to rational approximation
                let (num, den) = float_to_rational(*n);
                Real::from_real(self.ctx, num, den)
            }
            Term::Add(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l + r
            }
            Term::Sub(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l - r
            }
            Term::Mul(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l * r
            }
            Term::Div(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l / r
            }
            Term::Neg(inner) => {
                let i = self.translate_term(inner, vars);
                -i
            }
        }
    }

    /// Translate a Kleis Constraint to Z3 Bool
    fn translate_constraint<'a>(
        &self,
        constraint: &Constraint,
        vars: &mut HashMap<String, Real<'ctx>>,
    ) -> Bool<'ctx> {
        match constraint {
            Constraint::True => Bool::from_bool(self.ctx, true),
            Constraint::False => Bool::from_bool(self.ctx, false),
            Constraint::Var(name) => Bool::new_const(self.ctx, name.as_str()),
            Constraint::And(left, right) => {
                let l = self.translate_constraint(left, vars);
                let r = self.translate_constraint(right, vars);
                Bool::and(self.ctx, &[&l, &r])
            }
            Constraint::Or(left, right) => {
                let l = self.translate_constraint(left, vars);
                let r = self.translate_constraint(right, vars);
                Bool::or(self.ctx, &[&l, &r])
            }
            Constraint::Not(inner) => {
                let i = self.translate_constraint(inner, vars);
                i.not()
            }
            Constraint::Implies(premise, conclusion) => {
                let p = self.translate_constraint(premise, vars);
                let c = self.translate_constraint(conclusion, vars);
                p.implies(&c)
            }
            Constraint::ForAll(var_name, body) => {
                let var = Real::new_const(self.ctx, var_name.as_str());
                vars.insert(var_name.clone(), var.clone());
                let body_expr = self.translate_constraint(body, vars);
                z3::ast::forall_const(self.ctx, &[&var], &[], &body_expr)
            }
            Constraint::Exists(var_name, body) => {
                let var = Real::new_const(self.ctx, var_name.as_str());
                vars.insert(var_name.clone(), var.clone());
                let body_expr = self.translate_constraint(body, vars);
                z3::ast::exists_const(self.ctx, &[&var], &[], &body_expr)
            }
            Constraint::Eq(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l._eq(&r)
            }
            Constraint::Lt(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l.lt(&r)
            }
            Constraint::Le(left, right) => {
                let l = self.translate_term(left, vars);
                let r = self.translate_term(right, vars);
                l.le(&r)
            }
        }
    }
}

// ============================================================================
// 5. HELPER FUNCTIONS
// ============================================================================

/// Negate a constraint (De Morgan's laws)
pub fn negate_constraint(c: &Constraint) -> Constraint {
    match c {
        Constraint::True => Constraint::False,
        Constraint::False => Constraint::True,
        Constraint::Not(inner) => (**inner).clone(),
        Constraint::And(a, b) => Constraint::Or(
            Box::new(negate_constraint(a)),
            Box::new(negate_constraint(b)),
        ),
        Constraint::Or(a, b) => Constraint::And(
            Box::new(negate_constraint(a)),
            Box::new(negate_constraint(b)),
        ),
        Constraint::ForAll(x, body) => {
            Constraint::Exists(x.clone(), Box::new(negate_constraint(body)))
        }
        Constraint::Exists(x, body) => {
            Constraint::ForAll(x.clone(), Box::new(negate_constraint(body)))
        }
        Constraint::Implies(a, b) => {
            Constraint::And(a.clone(), Box::new(negate_constraint(b)))
        }
        _ => Constraint::Not(Box::new(c.clone())),
    }
}

/// Convert f64 to a rational approximation (numerator, denominator)
fn float_to_rational(f: f64) -> (i32, i32) {
    if f == f.floor() {
        (f as i32, 1)
    } else {
        // Simple approximation: multiply by 1000000 and simplify
        let scale = 1000000;
        let num = (f * scale as f64).round() as i64;
        let den = scale as i64;
        let g = gcd(num.abs(), den);
        ((num / g) as i32, (den / g) as i32)
    }
}

fn gcd(a: i64, b: i64) -> i64 {
    if b == 0 { a } else { gcd(b, a % b) }
}

// ============================================================================
// 6. EXAMPLE CONSTRAINTS (from solver_api.kleis)
// ============================================================================

/// x + y = 10 ∧ x - y = 2
/// Solution: x = 6, y = 4
pub fn linear_system() -> Constraint {
    Constraint::eq(
        Term::var("x").add(Term::var("y")),
        Term::num(10.0),
    )
    .and(Constraint::eq(
        Term::var("x").sub(Term::var("y")),
        Term::num(2.0),
    ))
}

/// x² = 4
/// Solutions: x = 2 or x = -2
pub fn quadratic_eq() -> Constraint {
    Constraint::eq(
        Term::var("x").mul(Term::var("x")),
        Term::num(4.0),
    )
}

/// ∀x. x + 0 = x
pub fn additive_identity() -> Constraint {
    Constraint::forall(
        "x",
        Constraint::eq(Term::var("x").add(Term::num(0.0)), Term::var("x")),
    )
}

/// ∀x. ∀y. x + y = y + x
pub fn commutativity() -> Constraint {
    Constraint::forall(
        "x",
        Constraint::forall(
            "y",
            Constraint::eq(
                Term::var("x").add(Term::var("y")),
                Term::var("y").add(Term::var("x")),
            ),
        ),
    )
}

/// ∃x. x * x = -1 (unsatisfiable over reals)
pub fn no_real_sqrt_neg() -> Constraint {
    Constraint::exists(
        "x",
        Constraint::eq(Term::var("x").mul(Term::var("x")), Term::num(-1.0)),
    )
}

// ============================================================================
// 7. MAIN - Test the solver API
// ============================================================================

fn main() {
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = Z3Solver::new(&ctx);

    println!("=== Kleis Solver API (Z3 Backend) ===\n");

    // Test 1: Linear system
    println!("1. Linear System: x + y = 10 ∧ x - y = 2");
    let c1 = linear_system();
    println!("   check_sat = {:?}", solver.check_sat(&c1));
    match solver.get_model(&c1) {
        Witness::Model(bindings) => {
            println!("   Solution:");
            for b in bindings {
                println!("     {} = {}", b.name, b.value);
            }
        }
        Witness::NoWitness => println!("   No witness"),
    }

    // Test 2: Quadratic equation
    println!("\n2. Quadratic: x² = 4");
    let c2 = quadratic_eq();
    println!("   check_sat = {:?}", solver.check_sat(&c2));
    match solver.get_model(&c2) {
        Witness::Model(bindings) => {
            println!("   One solution:");
            for b in bindings {
                println!("     {} = {}", b.name, b.value);
            }
        }
        Witness::NoWitness => println!("   No witness"),
    }

    // Test 3: Additive identity (should be valid)
    println!("\n3. Additive Identity: ∀x. x + 0 = x");
    let c3 = additive_identity();
    println!("   check_valid = {:?}", solver.check_valid(&c3));

    // Test 4: Commutativity (should be valid)
    println!("\n4. Commutativity: ∀x. ∀y. x + y = y + x");
    let c4 = commutativity();
    println!("   check_valid = {:?}", solver.check_valid(&c4));

    // Test 5: No real sqrt of -1 (should be unsat)
    println!("\n5. No Real Sqrt: ∃x. x² = -1");
    let c5 = no_real_sqrt_neg();
    println!("   check_sat = {:?}", solver.check_sat(&c5));

    // Test 6: Custom constraint
    println!("\n6. Custom: x > 5 ∧ x < 10 ∧ x² = 49");
    let c6 = Constraint::lt(Term::num(5.0), Term::var("x"))
        .and(Constraint::lt(Term::var("x"), Term::num(10.0)))
        .and(Constraint::eq(
            Term::var("x").mul(Term::var("x")),
            Term::num(49.0),
        ));
    println!("   check_sat = {:?}", solver.check_sat(&c6));
    match solver.get_model(&c6) {
        Witness::Model(bindings) => {
            println!("   Solution:");
            for b in bindings {
                println!("     {} = {}", b.name, b.value);
            }
        }
        Witness::NoWitness => println!("   No witness"),
    }

    println!("\n=== Done ===");
}

