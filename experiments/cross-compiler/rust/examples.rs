// Generated by Kleis Cross-Compiler
// https://github.com/eatikrh/kleis
//
// Examples of Kleis → Rust translation

// ============================================================================
// From: data Option(T) = None | Some(value: T)
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
enum Option<T> {
    None,
    Some { value: T },
}

// ============================================================================
// From: data List(T) = Nil | Cons(head: T, tail: List(T))
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
enum List<T> {
    Nil,
    Cons { head: T, tail: Box<List<T>> },
}

// ============================================================================
// From: data Tree(T) = Leaf(value: T) | Node(left: Tree(T), right: Tree(T))
// ============================================================================

#[derive(Debug, Clone, PartialEq)]
enum Tree<T> {
    Leaf { value: T },
    Node { left: Box<Tree<T>>, right: Box<Tree<T>> },
}

// ============================================================================
// From: define fib(n : ℕ) : ℕ = if n < 2 then n else fib(n-1) + fib(n-2)
// ============================================================================

fn fib(n: u64) -> u64 {
    if n < 2 { n } else { fib(n - 1) + fib(n - 2) }
}

// ============================================================================
// From: define factorial(n : ℕ) : ℕ = if n = 0 then 1 else n * factorial(n - 1)
// ============================================================================

fn factorial(n: u64) -> u64 {
    if n == 0 { 1 } else { n * factorial(n - 1) }
}

// ============================================================================
// From: define sum_list(xs : List(ℕ)) : ℕ = match xs { Nil => 0 | Cons(h, t) => h + sum_list(t) }
// ============================================================================

fn sum_list(xs: &List<u64>) -> u64 {
    match xs {
        List::Nil => 0,
        List::Cons { head, tail } => head + sum_list(tail),
    }
}

// ============================================================================
// From: define map(f : T → U, xs : List(T)) : List(U) = match xs { Nil => Nil | Cons(h, t) => Cons(f(h), map(f, t)) }
// ============================================================================

fn map<T: Clone, U>(f: impl Fn(T) -> U + Copy, xs: &List<T>) -> List<U> {
    match xs {
        List::Nil => List::Nil,
        List::Cons { head, tail } => List::Cons {
            head: f(head.clone()),
            tail: Box::new(map(f, tail)),
        },
    }
}

// ============================================================================
// From: define tree_sum(t : Tree(ℕ)) : ℕ = match t { Leaf(v) => v | Node(l, r) => tree_sum(l) + tree_sum(r) }
// ============================================================================

fn tree_sum(t: &Tree<u64>) -> u64 {
    match t {
        Tree::Leaf { value } => *value,
        Tree::Node { left, right } => tree_sum(left) + tree_sum(right),
    }
}

// ============================================================================
// Main - Test all functions
// ============================================================================

fn main() {
    println!("=== Fibonacci ===");
    for i in 0..10 {
        println!("fib({}) = {}", i, fib(i));
    }

    println!("\n=== Factorial ===");
    for i in 0..10 {
        println!("{}! = {}", i, factorial(i));
    }

    println!("\n=== List Sum ===");
    let list = List::Cons {
        head: 1,
        tail: Box::new(List::Cons {
            head: 2,
            tail: Box::new(List::Cons {
                head: 3,
                tail: Box::new(List::Cons {
                    head: 4,
                    tail: Box::new(List::Cons {
                        head: 5,
                        tail: Box::new(List::Nil),
                    }),
                }),
            }),
        }),
    };
    println!("sum([1,2,3,4,5]) = {}", sum_list(&list));

    println!("\n=== Map ===");
    let doubled = map(|x| x * 2, &list);
    println!("map(x*2, [1,2,3,4,5]) = {:?}", doubled);

    println!("\n=== Tree Sum ===");
    let tree = Tree::Node {
        left: Box::new(Tree::Node {
            left: Box::new(Tree::Leaf { value: 1 }),
            right: Box::new(Tree::Leaf { value: 2 }),
        }),
        right: Box::new(Tree::Node {
            left: Box::new(Tree::Leaf { value: 3 }),
            right: Box::new(Tree::Leaf { value: 4 }),
        }),
    };
    println!("tree_sum(Node(Node(1,2), Node(3,4))) = {}", tree_sum(&tree));
}

