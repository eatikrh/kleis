// Generated by Kleis Cross-Compiler
// https://github.com/eatikrh/kleis
//
// Source: symbolic.kleis
//
// SYMBOLIC COMPUTATION LAYER
// ==========================
// This module provides symbolic values that propagate through computation
// until they are solved by Z3. Variables are NOT concrete Rust values -
// they are symbolic placeholders that build expression trees.

use std::collections::{HashMap, HashSet};
use std::fmt;
use std::ops::{Add, Sub, Mul, Div, Neg, Not, BitAnd, BitOr};
use z3::ast::{Ast, Bool as Z3Bool, Real as Z3Real};
use z3::{Config, Context, SatResult as Z3SatResult, Solver, Model};

// ============================================================================
// 1. SYMBOLIC VALUE TYPES
// ============================================================================

/// A symbolic value can be:
/// - Concrete: a known value that can be computed
/// - Variable: an unknown that represents a free variable
/// - Expr: a symbolic expression tree
#[derive(Debug, Clone)]
pub enum Sym<T: Clone> {
    Concrete(T),
    Variable(String),
    Expr { op: String, args: Vec<Sym<T>> },
}

/// Type aliases for common symbolic types
pub type SymReal = Sym<f64>;
pub type SymInt = Sym<i64>;
pub type SymBool = Sym<bool>;

// ============================================================================
// 2. SYMBOLIC CONSTRUCTORS
// ============================================================================

impl<T: Clone> Sym<T> {
    /// Create a concrete (known) value
    pub fn concrete(value: T) -> Self {
        Sym::Concrete(value)
    }

    /// Create a symbolic variable
    pub fn var(name: &str) -> Self {
        Sym::Variable(name.to_string())
    }

    /// Create a symbolic expression
    pub fn expr(op: &str, args: Vec<Sym<T>>) -> Self {
        Sym::Expr {
            op: op.to_string(),
            args,
        }
    }

    /// Check if this value is concrete
    pub fn is_concrete(&self) -> bool {
        matches!(self, Sym::Concrete(_))
    }

    /// Check if this value is symbolic (variable or expression)
    pub fn is_symbolic(&self) -> bool {
        !self.is_concrete()
    }

    /// Get the concrete value if available
    pub fn get_concrete(&self) -> Option<&T> {
        match self {
            Sym::Concrete(v) => Some(v),
            _ => None,
        }
    }
}

// ============================================================================
// 3. SYMBOLIC ARITHMETIC (with constant folding)
// ============================================================================

impl Add for SymReal {
    type Output = SymReal;

    fn add(self, other: SymReal) -> SymReal {
        match (&self, &other) {
            // Both concrete: compute!
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a + b),
            // 0 + x = x
            (Sym::Concrete(a), _) if *a == 0.0 => other,
            (_, Sym::Concrete(b)) if *b == 0.0 => self,
            // Otherwise: defer to solver
            _ => Sym::expr("add", vec![self, other]),
        }
    }
}

impl Sub for SymReal {
    type Output = SymReal;

    fn sub(self, other: SymReal) -> SymReal {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a - b),
            (_, Sym::Concrete(b)) if *b == 0.0 => self,
            _ => Sym::expr("sub", vec![self, other]),
        }
    }
}

impl Mul for SymReal {
    type Output = SymReal;

    fn mul(self, other: SymReal) -> SymReal {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a * b),
            // 0 * x = 0
            (Sym::Concrete(a), _) if *a == 0.0 => Sym::Concrete(0.0),
            (_, Sym::Concrete(b)) if *b == 0.0 => Sym::Concrete(0.0),
            // 1 * x = x
            (Sym::Concrete(a), _) if *a == 1.0 => other,
            (_, Sym::Concrete(b)) if *b == 1.0 => self,
            _ => Sym::expr("mul", vec![self, other]),
        }
    }
}

impl Div for SymReal {
    type Output = SymReal;

    fn div(self, other: SymReal) -> SymReal {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a / b),
            // x / 1 = x
            (_, Sym::Concrete(b)) if *b == 1.0 => self,
            _ => Sym::expr("div", vec![self, other]),
        }
    }
}

impl Neg for SymReal {
    type Output = SymReal;

    fn neg(self) -> SymReal {
        match &self {
            Sym::Concrete(a) => Sym::Concrete(-a),
            // Double negation: --x = x
            Sym::Expr { op, args } if op == "neg" && args.len() == 1 => args[0].clone(),
            _ => Sym::expr("neg", vec![self]),
        }
    }
}

// ============================================================================
// 4. SYMBOLIC COMPARISONS
// ============================================================================

impl SymReal {
    pub fn sym_eq(self, other: SymReal) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a == b),
            (Sym::Variable(n1), Sym::Variable(n2)) if n1 == n2 => Sym::Concrete(true),
            _ => Sym::expr("eq", vec![
                self.to_bool_arg(),
                other.to_bool_arg(),
            ]),
        }
    }

    pub fn sym_lt(self, other: SymReal) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a < b),
            _ => Sym::expr("lt", vec![self.to_bool_arg(), other.to_bool_arg()]),
        }
    }

    pub fn sym_le(self, other: SymReal) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a <= b),
            _ => Sym::expr("le", vec![self.to_bool_arg(), other.to_bool_arg()]),
        }
    }

    pub fn sym_gt(self, other: SymReal) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a > b),
            _ => Sym::expr("gt", vec![self.to_bool_arg(), other.to_bool_arg()]),
        }
    }

    pub fn sym_ge(self, other: SymReal) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(a), Sym::Concrete(b)) => Sym::Concrete(a >= b),
            _ => Sym::expr("ge", vec![self.to_bool_arg(), other.to_bool_arg()]),
        }
    }

    // Helper to convert to bool argument (for mixed expressions)
    fn to_bool_arg(self) -> SymBool {
        match self {
            Sym::Concrete(v) => Sym::expr("real", vec![Sym::Concrete(v != 0.0)]),
            Sym::Variable(name) => Sym::Variable(name),
            Sym::Expr { op, args: _ } => Sym::expr(&op, vec![]),
        }
    }
}

// ============================================================================
// 5. SYMBOLIC LOGIC
// ============================================================================

impl BitAnd for SymBool {
    type Output = SymBool;

    fn bitand(self, other: SymBool) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(true), _) => other,
            (_, Sym::Concrete(true)) => self,
            (Sym::Concrete(false), _) => Sym::Concrete(false),
            (_, Sym::Concrete(false)) => Sym::Concrete(false),
            _ => Sym::expr("and", vec![self, other]),
        }
    }
}

impl BitOr for SymBool {
    type Output = SymBool;

    fn bitor(self, other: SymBool) -> SymBool {
        match (&self, &other) {
            (Sym::Concrete(true), _) => Sym::Concrete(true),
            (_, Sym::Concrete(true)) => Sym::Concrete(true),
            (Sym::Concrete(false), _) => other,
            (_, Sym::Concrete(false)) => self,
            _ => Sym::expr("or", vec![self, other]),
        }
    }
}

impl Not for SymBool {
    type Output = SymBool;

    fn not(self) -> SymBool {
        match &self {
            Sym::Concrete(b) => Sym::Concrete(!b),
            Sym::Expr { op, args } if op == "not" && args.len() == 1 => args[0].clone(),
            _ => Sym::expr("not", vec![self]),
        }
    }
}

impl SymBool {
    pub fn implies(self, other: SymBool) -> SymBool {
        (!self) | other
    }
}

// ============================================================================
// 6. VARIABLE COLLECTION
// ============================================================================

impl<T: Clone> Sym<T> {
    /// Collect all variable names in this expression
    pub fn collect_vars(&self) -> HashSet<String> {
        let mut vars = HashSet::new();
        self.collect_vars_into(&mut vars);
        vars
    }

    fn collect_vars_into(&self, vars: &mut HashSet<String>) {
        match self {
            Sym::Concrete(_) => {}
            Sym::Variable(name) => {
                vars.insert(name.clone());
            }
            Sym::Expr { args, .. } => {
                for arg in args {
                    arg.collect_vars_into(vars);
                }
            }
        }
    }
}

// ============================================================================
// 7. SUBSTITUTION
// ============================================================================

impl SymReal {
    /// Substitute a variable with a value
    pub fn substitute(self, var_name: &str, value: SymReal) -> SymReal {
        match self {
            Sym::Concrete(v) => Sym::Concrete(v),
            Sym::Variable(name) if name == var_name => value,
            Sym::Variable(name) => Sym::Variable(name),
            Sym::Expr { op, args } => Sym::Expr {
                op,
                args: args.into_iter().map(|a| a.substitute(var_name, value.clone())).collect(),
            },
        }
    }

    /// Evaluate with bindings
    pub fn eval_with(self, bindings: &HashMap<String, f64>) -> SymReal {
        match self {
            Sym::Concrete(v) => Sym::Concrete(v),
            Sym::Variable(name) => {
                if let Some(&v) = bindings.get(&name) {
                    Sym::Concrete(v)
                } else {
                    Sym::Variable(name)
                }
            }
            Sym::Expr { op, args } => {
                let evaled: Vec<SymReal> = args.into_iter().map(|a| a.eval_with(bindings)).collect();
                
                // Try to reduce if all args are now concrete
                let all_concrete = evaled.iter().all(|a| a.is_concrete());
                if all_concrete {
                    Self::reduce_op(&op, &evaled)
                } else {
                    Sym::Expr { op, args: evaled }
                }
            }
        }
    }

    fn reduce_op(op: &str, args: &[SymReal]) -> SymReal {
        match (op, args) {
            ("add", [Sym::Concrete(a), Sym::Concrete(b)]) => Sym::Concrete(a + b),
            ("sub", [Sym::Concrete(a), Sym::Concrete(b)]) => Sym::Concrete(a - b),
            ("mul", [Sym::Concrete(a), Sym::Concrete(b)]) => Sym::Concrete(a * b),
            ("div", [Sym::Concrete(a), Sym::Concrete(b)]) => Sym::Concrete(a / b),
            ("neg", [Sym::Concrete(a)]) => Sym::Concrete(-a),
            _ => Sym::Expr { op: op.to_string(), args: args.to_vec() },
        }
    }
}

// ============================================================================
// 8. PRETTY PRINTING
// ============================================================================

impl fmt::Display for SymReal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Sym::Concrete(v) => write!(f, "{}", v),
            Sym::Variable(name) => write!(f, "{}", name),
            Sym::Expr { op, args } => {
                match (op.as_str(), args.as_slice()) {
                    ("add", [a, b]) => write!(f, "({} + {})", a, b),
                    ("sub", [a, b]) => write!(f, "({} - {})", a, b),
                    ("mul", [a, b]) => write!(f, "({} * {})", a, b),
                    ("div", [a, b]) => write!(f, "({} / {})", a, b),
                    ("neg", [a]) => write!(f, "-{}", a),
                    _ => {
                        write!(f, "{}(", op)?;
                        for (i, arg) in args.iter().enumerate() {
                            if i > 0 { write!(f, ", ")?; }
                            write!(f, "{}", arg)?;
                        }
                        write!(f, ")")
                    }
                }
            }
        }
    }
}

impl fmt::Display for SymBool {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Sym::Concrete(v) => write!(f, "{}", v),
            Sym::Variable(name) => write!(f, "{}", name),
            Sym::Expr { op, args } => {
                match (op.as_str(), args.as_slice()) {
                    ("and", [a, b]) => write!(f, "({} ∧ {})", a, b),
                    ("or", [a, b]) => write!(f, "({} ∨ {})", a, b),
                    ("not", [a]) => write!(f, "¬{}", a),
                    ("eq", [a, b]) => write!(f, "({} = {})", a, b),
                    ("lt", [a, b]) => write!(f, "({} < {})", a, b),
                    ("le", [a, b]) => write!(f, "({} ≤ {})", a, b),
                    ("gt", [a, b]) => write!(f, "({} > {})", a, b),
                    ("ge", [a, b]) => write!(f, "({} ≥ {})", a, b),
                    _ => {
                        write!(f, "{}(", op)?;
                        for (i, arg) in args.iter().enumerate() {
                            if i > 0 { write!(f, ", ")?; }
                            write!(f, "{}", arg)?;
                        }
                        write!(f, ")")
                    }
                }
            }
        }
    }
}

// ============================================================================
// 9. SYMBOLIC IF-THEN-ELSE
// ============================================================================

pub fn sym_ite<T: Clone>(cond: SymBool, then_val: Sym<T>, else_val: Sym<T>) -> Sym<T> {
    match cond {
        Sym::Concrete(true) => then_val,
        Sym::Concrete(false) => else_val,
        _ => Sym::expr("ite", vec![]),  // Would need more complex handling
    }
}

// ============================================================================
// 10. Z3 INTEGRATION
// ============================================================================

pub struct SymbolicSolver<'ctx> {
    ctx: &'ctx Context,
    solver: Solver<'ctx>,
}

impl<'ctx> SymbolicSolver<'ctx> {
    pub fn new(ctx: &'ctx Context) -> Self {
        SymbolicSolver {
            ctx,
            solver: Solver::new(ctx),
        }
    }

    /// Solve for a symbolic expression: find values that make constraint true
    pub fn solve(&self, constraint: &SymBool) -> Option<HashMap<String, f64>> {
        self.solver.reset();
        let mut vars: HashMap<String, Z3Real<'ctx>> = HashMap::new();
        
        let z3_expr = self.translate_bool(constraint, &mut vars);
        self.solver.assert(&z3_expr);

        if self.solver.check() == Z3SatResult::Sat {
            if let Some(model) = self.solver.get_model() {
                let mut result = HashMap::new();
                for (name, var) in &vars {
                    if let Some(val) = model.eval(var, true) {
                        if let Some((num, den)) = val.as_real() {
                            result.insert(name.clone(), num as f64 / den as f64);
                        }
                    }
                }
                return Some(result);
            }
        }
        None
    }

    /// Check if a symbolic boolean is always true (valid)
    pub fn is_valid(&self, expr: &SymBool) -> bool {
        self.solver.reset();
        let mut vars: HashMap<String, Z3Real<'ctx>> = HashMap::new();
        
        // Valid iff negation is unsatisfiable
        let negated = (!expr.clone());
        let z3_expr = self.translate_bool(&negated, &mut vars);
        self.solver.assert(&z3_expr);

        self.solver.check() == Z3SatResult::Unsat
    }

    fn translate_real(&self, expr: &SymReal, vars: &mut HashMap<String, Z3Real<'ctx>>) -> Z3Real<'ctx> {
        match expr {
            Sym::Concrete(v) => {
                let (num, den) = float_to_rational(*v);
                Z3Real::from_real(self.ctx, num, den)
            }
            Sym::Variable(name) => {
                vars.entry(name.clone())
                    .or_insert_with(|| Z3Real::new_const(self.ctx, name.as_str()))
                    .clone()
            }
            Sym::Expr { op, args } => {
                match (op.as_str(), args.as_slice()) {
                    ("add", [a, b]) => {
                        let za = self.translate_real(a, vars);
                        let zb = self.translate_real(b, vars);
                        za + zb
                    }
                    ("sub", [a, b]) => {
                        let za = self.translate_real(a, vars);
                        let zb = self.translate_real(b, vars);
                        za - zb
                    }
                    ("mul", [a, b]) => {
                        let za = self.translate_real(a, vars);
                        let zb = self.translate_real(b, vars);
                        za * zb
                    }
                    ("div", [a, b]) => {
                        let za = self.translate_real(a, vars);
                        let zb = self.translate_real(b, vars);
                        za / zb
                    }
                    ("neg", [a]) => {
                        let za = self.translate_real(a, vars);
                        -za
                    }
                    _ => Z3Real::from_real(self.ctx, 0, 1), // Fallback
                }
            }
        }
    }

    fn translate_bool(&self, expr: &SymBool, vars: &mut HashMap<String, Z3Real<'ctx>>) -> Z3Bool<'ctx> {
        match expr {
            Sym::Concrete(true) => Z3Bool::from_bool(self.ctx, true),
            Sym::Concrete(false) => Z3Bool::from_bool(self.ctx, false),
            Sym::Variable(name) => Z3Bool::new_const(self.ctx, name.as_str()),
            Sym::Expr { op, args } => {
                match op.as_str() {
                    "and" if args.len() == 2 => {
                        let a = self.translate_bool(&args[0], vars);
                        let b = self.translate_bool(&args[1], vars);
                        Z3Bool::and(self.ctx, &[&a, &b])
                    }
                    "or" if args.len() == 2 => {
                        let a = self.translate_bool(&args[0], vars);
                        let b = self.translate_bool(&args[1], vars);
                        Z3Bool::or(self.ctx, &[&a, &b])
                    }
                    "not" if args.len() == 1 => {
                        let a = self.translate_bool(&args[0], vars);
                        a.not()
                    }
                    // For comparison ops, we need to handle the Real operands
                    // This is simplified - real impl would track types properly
                    _ => Z3Bool::from_bool(self.ctx, true),
                }
            }
        }
    }
}

fn float_to_rational(f: f64) -> (i32, i32) {
    if f == f.floor() {
        (f as i32, 1)
    } else {
        let scale = 1000000;
        let num = (f * scale as f64).round() as i64;
        let den = scale as i64;
        let g = gcd(num.abs(), den);
        ((num / g) as i32, (den / g) as i32)
    }
}

fn gcd(a: i64, b: i64) -> i64 {
    if b == 0 { a } else { gcd(b, a % b) }
}

// ============================================================================
// 11. MAIN - Demonstrate symbolic execution
// ============================================================================

fn main() {
    println!("=== Kleis Symbolic Computation Layer ===\n");

    // 1. Create symbolic variables
    let x: SymReal = Sym::var("x");
    let y: SymReal = Sym::var("y");

    println!("1. Symbolic Variables:");
    println!("   x = {}", x);
    println!("   y = {}", y);

    // 2. Build symbolic expressions
    let expr1 = x.clone() + y.clone();           // x + y
    let expr2 = x.clone() * Sym::concrete(2.0);  // x * 2
    let expr3 = (x.clone() + y.clone()) * (x.clone() - y.clone()); // (x+y)(x-y)

    println!("\n2. Symbolic Expressions:");
    println!("   x + y = {}", expr1);
    println!("   x * 2 = {}", expr2);
    println!("   (x + y) * (x - y) = {}", expr3);

    // 3. Constant folding
    let a = Sym::concrete(3.0);
    let b = Sym::concrete(4.0);
    let folded = a + b;

    println!("\n3. Constant Folding:");
    println!("   3 + 4 = {} (computed!)", folded);

    // 4. Mixed expressions
    let mixed = Sym::concrete(2.0) * x.clone() + Sym::concrete(3.0);

    println!("\n4. Mixed Concrete + Symbolic:");
    println!("   2*x + 3 = {}", mixed);

    // 5. Variable collection
    let complex_expr = (x.clone() + y.clone()) * Sym::var("z");
    let vars = complex_expr.collect_vars();

    println!("\n5. Variable Collection:");
    println!("   Expr: {}", complex_expr);
    println!("   Variables: {:?}", vars);

    // 6. Substitution
    let substituted = expr1.clone().substitute("x", Sym::concrete(5.0));

    println!("\n6. Substitution (x → 5):");
    println!("   Original: {}", expr1);
    println!("   After sub: {}", substituted);

    // 7. Evaluation with bindings
    let mut bindings = HashMap::new();
    bindings.insert("x".to_string(), 3.0);
    bindings.insert("y".to_string(), 4.0);
    let evaluated = expr3.eval_with(&bindings);

    println!("\n7. Evaluation with bindings {{x=3, y=4}}:");
    println!("   (x+y)(x-y) = {} (should be -7)", evaluated);

    // 8. Symbolic comparisons
    let cmp = x.clone().sym_lt(Sym::concrete(10.0));
    println!("\n8. Symbolic Comparison:");
    println!("   x < 10 = {}", cmp);

    // 9. Solve with Z3
    println!("\n9. Solving with Z3:");
    let cfg = Config::new();
    let ctx = Context::new(&cfg);
    let solver = SymbolicSolver::new(&ctx);

    // x + y = 10 AND x - y = 2 → x = 6, y = 4
    let constraint = (x.clone() + y.clone()).sym_eq(Sym::concrete(10.0))
        & (x.clone() - y.clone()).sym_eq(Sym::concrete(2.0));
    
    println!("   Constraint: x + y = 10 ∧ x - y = 2");
    // Note: Full solve would require more complete translation
    
    println!("\n=== Symbolic Layer Demo Complete ===");
}

