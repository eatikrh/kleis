// ============================================================================
// GENERATED BY KLEIS CROSS-COMPILER
// ============================================================================
//
// Source: fibonacci.kleis (symbolic version)
//
// This shows how generated Kleis code uses the runtime library.
//
// ============================================================================

use kleis_solver_api::{Sym, SymReal, KleisSolver, SatResult};
use std::collections::HashMap;

// ============================================================================
// GENERATED: Symbolic Fibonacci
// ============================================================================

/// Symbolic fibonacci: works with both concrete and symbolic inputs
///
/// From Kleis:
///   define fib(n : ℕ) : ℕ = if n < 2 then n else fib(n-1) + fib(n-2)
///
fn fib(n: SymReal) -> SymReal {
    match n.get_concrete() {
        Some(&v) if v < 2.0 => n,
        Some(&v) => {
            let n1 = fib(Sym::concrete(v - 1.0));
            let n2 = fib(Sym::concrete(v - 2.0));
            n1 + n2
        }
        None => {
            // Symbolic: can't compute, return symbolic application
            Sym::expr("fib", vec![n])
        }
    }
}

/// Symbolic factorial
///
/// From Kleis:
///   define factorial(n : ℕ) : ℕ = if n = 0 then 1 else n * factorial(n-1)
///
fn factorial(n: SymReal) -> SymReal {
    match n.get_concrete() {
        Some(&v) if v == 0.0 => Sym::concrete(1.0),
        Some(&v) => {
            let sub = factorial(Sym::concrete(v - 1.0));
            n * sub
        }
        None => {
            Sym::expr("factorial", vec![n])
        }
    }
}

/// Symbolic quadratic: ax² + bx + c
///
/// From Kleis:
///   define quadratic(a, b, c, x) = a*x*x + b*x + c
///
fn quadratic(a: SymReal, b: SymReal, c: SymReal, x: SymReal) -> SymReal {
    let x2 = x.clone() * x.clone();
    a * x2 + b * x + c
}

// ============================================================================
// MAIN: Demonstrate symbolic execution
// ============================================================================

fn main() {
    println!("=== Kleis Generated Code with Symbolic Runtime ===\n");

    // 1. Concrete execution (like normal Rust)
    println!("1. Concrete Execution:");
    println!("   fib(10) = {}", fib(Sym::concrete(10.0)));
    println!("   factorial(5) = {}", factorial(Sym::concrete(5.0)));
    println!("   quadratic(1, -5, 6, 2) = {}", 
             quadratic(Sym::concrete(1.0), Sym::concrete(-5.0), 
                       Sym::concrete(6.0), Sym::concrete(2.0)));

    // 2. Symbolic execution (builds expression trees)
    println!("\n2. Symbolic Execution:");
    let x: SymReal = Sym::var("x");
    let y: SymReal = Sym::var("y");
    
    println!("   x + y = {}", x.clone() + y.clone());
    println!("   fib(x) = {}", fib(x.clone()));
    println!("   quadratic(1, -5, 6, x) = {}", 
             quadratic(Sym::concrete(1.0), Sym::concrete(-5.0),
                       Sym::concrete(6.0), x.clone()));

    // 3. Solving with Z3
    println!("\n3. Solving with Z3:");
    let solver = KleisSolver::new();

    // Find x such that x² = 9
    let x_squared = x.clone() * x.clone();
    let constraint = x_squared.sym_eq(Sym::concrete(9.0));
    
    println!("   Constraint: x² = 9");
    match solver.check_sat(&constraint) {
        SatResult::Sat => {
            if let Some(model) = solver.solve(&constraint) {
                for (name, value) in &model {
                    println!("   Solution: {} = {}", name, value);
                }
            }
        }
        SatResult::Unsat => println!("   Unsatisfiable"),
        SatResult::Unknown => println!("   Unknown"),
    }

    // Find x, y such that x + y = 10 AND x - y = 4
    println!("\n   Constraint: x + y = 10 AND x - y = 4");
    let c1 = (x.clone() + y.clone()).sym_eq(Sym::concrete(10.0));
    let c2 = (x.clone() - y.clone()).sym_eq(Sym::concrete(4.0));
    let combined = c1 & c2;
    
    match solver.check_sat(&combined) {
        SatResult::Sat => {
            if let Some(model) = solver.solve(&combined) {
                for (name, value) in &model {
                    println!("   Solution: {} = {}", name, value);
                }
            }
        }
        SatResult::Unsat => println!("   Unsatisfiable"),
        SatResult::Unknown => println!("   Unknown"),
    }

    // 4. Solving for a target
    println!("\n4. Solving for Target:");
    
    // Find x such that 2x + 3 = 15 → x = 6
    let expr = Sym::concrete(2.0) * x.clone() + Sym::concrete(3.0);
    println!("   Find x such that 2x + 3 = 15");
    if let Some(model) = solver.solve_for(&expr, 15.0) {
        for (name, value) in &model {
            println!("   Solution: {} = {}", name, value);
        }
    }

    // 5. Evaluation with bindings
    println!("\n5. Evaluation with Bindings:");
    let mut bindings = HashMap::new();
    bindings.insert("x".to_string(), 5.0);
    bindings.insert("y".to_string(), 3.0);

    let expr = (x.clone() + y.clone()) * (x.clone() - y.clone());
    println!("   (x + y)(x - y) with x=5, y=3");
    println!("   Expression: {}", expr);
    println!("   Evaluated: {}", expr.eval_with(&bindings));

    println!("\n=== Done ===");
}

