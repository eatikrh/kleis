// ============================================================================
// FIBONACCI MODULE - Generated by Kleis Cross-Compiler
// ============================================================================
//
// This is what `module_to_rust("Fibonacci", decls)` would generate.
// It implements the C-ABI for discovery and invocation.
//
// ============================================================================

use std::ffi::{c_char, CStr};
use crate::module_abi::{
    AbiResult, AbiValue, KleisModuleImpl, StaticAxiom, StaticFunctionSig, StaticImport,
};

// ============================================================================
// 1. THE ACTUAL FUNCTIONS (generated from Kleis definitions)
// ============================================================================

fn fib(n: u64) -> u64 {
    if n < 2 { n } else { fib(n - 1) + fib(n - 2) }
}

fn factorial(n: u64) -> u64 {
    if n == 0 { 1 } else { n * factorial(n - 1) }
}

fn is_even(n: u64) -> bool {
    n % 2 == 0
}

// ============================================================================
// 2. MODULE IMPLEMENTATION (generated by codegen)
// ============================================================================

pub struct FibonacciModule;

impl KleisModuleImpl for FibonacciModule {
    fn name(&self) -> &'static str { "Fibonacci" }
    fn version(&self) -> &'static str { "1.0.0" }
    
    fn imports(&self) -> &'static [StaticImport] {
        static IMPORTS: &[StaticImport] = &[
            StaticImport {
                path: "stdlib/prelude.kleis",
                expected_hash: "",  // Empty = any version OK (for stdlib)
                required: true,
            },
            StaticImport {
                path: "stdlib/nat.kleis",
                expected_hash: "",  // Empty = any version OK (for stdlib)
                required: true,
            },
        ];
        IMPORTS
    }
    
    fn functions(&self) -> &'static [StaticFunctionSig] {
        static FUNCS: &[StaticFunctionSig] = &[
            StaticFunctionSig {
                name: "fib",
                params: &[("n", "ℕ")],
                return_type: "ℕ",
                doc: Some("Compute nth Fibonacci number"),
            },
            StaticFunctionSig {
                name: "factorial",
                params: &[("n", "ℕ")],
                return_type: "ℕ",
                doc: Some("Compute n factorial"),
            },
            StaticFunctionSig {
                name: "is_even",
                params: &[("n", "ℕ")],
                return_type: "Bool",
                doc: Some("Check if n is even"),
            },
        ];
        FUNCS
    }
    
    fn axioms(&self) -> &'static [StaticAxiom] {
        static AXIOMS: &[StaticAxiom] = &[
            StaticAxiom {
                name: "fib_base_0",
                formula: "fib(0) = 0",
                doc: None,
            },
            StaticAxiom {
                name: "fib_base_1",
                formula: "fib(1) = 1",
                doc: None,
            },
            StaticAxiom {
                name: "fib_recursive",
                formula: "∀ n : ℕ . n ≥ 2 → fib(n) = fib(n-1) + fib(n-2)",
                doc: Some("Fibonacci recurrence relation"),
            },
            StaticAxiom {
                name: "factorial_base",
                formula: "factorial(0) = 1",
                doc: None,
            },
            StaticAxiom {
                name: "factorial_recursive",
                formula: "∀ n : ℕ . n > 0 → factorial(n) = n * factorial(n-1)",
                doc: Some("Factorial recurrence relation"),
            },
        ];
        AXIOMS
    }
    
    fn call(&self, name: &str, args: &[AbiValue]) -> AbiResult {
        match name {
            "fib" => {
                let n = match args.first() {
                    Some(AbiValue::Nat(n)) => *n,
                    _ => return AbiResult::err("fib expects Nat argument"),
                };
                AbiResult::ok(AbiValue::Nat(fib(n)))
            }
            "factorial" => {
                let n = match args.first() {
                    Some(AbiValue::Nat(n)) => *n,
                    _ => return AbiResult::err("factorial expects Nat argument"),
                };
                AbiResult::ok(AbiValue::Nat(factorial(n)))
            }
            "is_even" => {
                let n = match args.first() {
                    Some(AbiValue::Nat(n)) => *n,
                    _ => return AbiResult::err("is_even expects Nat argument"),
                };
                AbiResult::ok(AbiValue::Bool(is_even(n)))
            }
            _ => AbiResult::err(&format!("unknown function: {}", name)),
        }
    }
    
    fn get_axiom(&self, name: &str) -> Option<&'static str> {
        match name {
            "fib_base_0" => Some("fib(0) = 0"),
            "fib_base_1" => Some("fib(1) = 1"),
            "fib_recursive" => Some("∀ n : ℕ . n ≥ 2 → fib(n) = fib(n-1) + fib(n-2)"),
            "factorial_base" => Some("factorial(0) = 1"),
            "factorial_recursive" => Some("∀ n : ℕ . n > 0 → factorial(n) = n * factorial(n-1)"),
            _ => None,
        }
    }
}

// ============================================================================
// 3. C-ABI EXPORTS (for dlopen)
// ============================================================================

static MODULE: FibonacciModule = FibonacciModule;

/// Get module name
#[no_mangle]
pub extern "C" fn kleis_module_name() -> *const c_char {
    b"Fibonacci\0".as_ptr() as *const c_char
}

/// Get module version
#[no_mangle]
pub extern "C" fn kleis_module_version() -> *const c_char {
    b"1.0.0\0".as_ptr() as *const c_char
}

/// Call a function by name
#[no_mangle]
pub extern "C" fn kleis_call(
    name: *const c_char,
    args: *const AbiValue,
    args_len: usize,
) -> AbiResult {
    let name_str = unsafe {
        if name.is_null() {
            return AbiResult::err("null function name");
        }
        match CStr::from_ptr(name).to_str() {
            Ok(s) => s,
            Err(_) => return AbiResult::err("invalid UTF-8 in function name"),
        }
    };
    
    let args_slice = if args.is_null() || args_len == 0 {
        &[]
    } else {
        unsafe { std::slice::from_raw_parts(args, args_len) }
    };
    
    MODULE.call(name_str, args_slice)
}

/// Get an axiom's formula
#[no_mangle]
pub extern "C" fn kleis_get_axiom(name: *const c_char) -> *const c_char {
    let name_str = unsafe {
        if name.is_null() {
            return std::ptr::null();
        }
        match CStr::from_ptr(name).to_str() {
            Ok(s) => s,
            Err(_) => return std::ptr::null(),
        }
    };
    
    match MODULE.get_axiom(name_str) {
        Some(formula) => formula.as_ptr() as *const c_char,
        None => std::ptr::null(),
    }
}

/// Get number of functions
#[no_mangle]
pub extern "C" fn kleis_function_count() -> usize {
    MODULE.functions().len()
}

/// Get function name by index
#[no_mangle]
pub extern "C" fn kleis_function_name(index: usize) -> *const c_char {
    MODULE.functions()
        .get(index)
        .map(|f| f.name.as_ptr() as *const c_char)
        .unwrap_or(std::ptr::null())
}

/// Get number of axioms
#[no_mangle]
pub extern "C" fn kleis_axiom_count() -> usize {
    MODULE.axioms().len()
}

/// Get axiom name by index
#[no_mangle]
pub extern "C" fn kleis_axiom_name(index: usize) -> *const c_char {
    MODULE.axioms()
        .get(index)
        .map(|a| a.name.as_ptr() as *const c_char)
        .unwrap_or(std::ptr::null())
}

/// Get number of imports
#[no_mangle]
pub extern "C" fn kleis_import_count() -> usize {
    MODULE.imports().len()
}

/// Get import path by index
#[no_mangle]
pub extern "C" fn kleis_import_path(index: usize) -> *const c_char {
    MODULE.imports()
        .get(index)
        .map(|i| i.path.as_ptr() as *const c_char)
        .unwrap_or(std::ptr::null())
}

/// Check if import is required
#[no_mangle]
pub extern "C" fn kleis_import_required(index: usize) -> bool {
    MODULE.imports()
        .get(index)
        .map(|i| i.required)
        .unwrap_or(false)
}

// ============================================================================
// 4. TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fib_direct() {
        assert_eq!(fib(0), 0);
        assert_eq!(fib(1), 1);
        assert_eq!(fib(10), 55);
        assert_eq!(fib(20), 6765);
    }

    #[test]
    fn test_factorial_direct() {
        assert_eq!(factorial(0), 1);
        assert_eq!(factorial(5), 120);
        assert_eq!(factorial(10), 3628800);
    }

    #[test]
    fn test_abi_call() {
        let result = MODULE.call("fib", &[AbiValue::Nat(10)]);
        assert!(result.success);
        match result.value {
            AbiValue::Nat(n) => assert_eq!(n, 55),
            _ => panic!("expected Nat"),
        }
    }

    #[test]
    fn test_abi_axiom() {
        assert_eq!(MODULE.get_axiom("fib_base_0"), Some("fib(0) = 0"));
        assert_eq!(MODULE.get_axiom("nonexistent"), None);
    }

    #[test]
    fn test_discovery() {
        assert_eq!(MODULE.name(), "Fibonacci");
        assert_eq!(MODULE.functions().len(), 3);
        assert_eq!(MODULE.axioms().len(), 5);
    }
}

