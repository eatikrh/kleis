// ============================================================================
// KLEIS GRAMMAR IN KLEIS - Self-Describing Language Specification
// ============================================================================
//
// This file defines Kleis's grammar using Kleis itself.
// Combined with Kleis's string operations and Z3's string theory,
// this enables SYNTAX VERIFICATION of Kleis programs from within Kleis!
//
// This is a form of META-CIRCULARITY: the language describing itself.
//
// See: ADR-003 (Self-Hosting Strategy)
// ============================================================================

// ============================================================================
// PART 1: Abstract Syntax Tree (AST) Types
// ============================================================================

// --- Expressions ---

data Expression =
    EVariable(name: String)
  | ENumber(value: ℝ)
  | EString(value: String)
  | EBool(value: Bool)
  | EOperation(name: String, args: List(Expression))
  | ELambda(params: List(Param), body: Expression)
  | ELet(pattern: Pattern, value: Expression, body: Expression)
  | EMatch(scrutinee: Expression, cases: List(MatchCase))
  | EIf(cond: Expression, then_expr: Expression, else_expr: Expression)
  | EForAll(vars: List(VarDecl), body: Expression)
  | EExists(vars: List(VarDecl), body: Expression)
  | EList(elements: List(Expression))

data Param = Param(name: String, type_ann: Option(Type))

data VarDecl = VarDecl(name: String, type_ann: Option(Type))

data MatchCase = MatchCase(pattern: Pattern, guard: Option(Expression), body: Expression)

// --- Patterns ---

data Pattern =
    PWildcard
  | PVariable(name: String)
  | PConstructor(name: String, args: List(Pattern))
  | PConstant(expr: Expression)
  | PAs(inner: Pattern, alias: String)
  | PTuple(elements: List(Pattern))

// --- Types ---

data Type =
    TPrimitive(name: String)
  | TVariable(name: String)
  | TParametric(name: String, args: List(Type))
  | TFunction(domain: Type, codomain: Type)
  | TProduct(left: Type, right: Type)

// --- Declarations ---

data Declaration =
    DImport(path: String)
  | DData(name: String, params: List(String), variants: List(DataVariant))
  | DStructure(name: String, params: List(TypeParam), extends: Option(String), members: List(StructMember))
  | DImplements(name: String, args: List(Type), members: List(ImplMember))
  | DDefine(name: String, params: List(Param), return_type: Option(Type), body: Expression)
  | DTypeAlias(name: String, target: Type)

data TypeParam = TypeParam(name: String, kind: Option(String))

data DataVariant = DataVariant(name: String, fields: List(DataField))

data DataField = 
    NamedField(name: String, field_type: Type)
  | PositionalField(field_type: Type)

data StructMember =
    SMOperation(name: String, signature: Type)
  | SMElement(name: String, elem_type: Type)
  | SMAxiom(name: String, proposition: Expression)
  | SMFunction(def: Declaration)

data ImplMember =
    IMElement(name: String, value: Expression)
  | IMOperation(name: String, value: Expression)

// --- Program ---

// A Program can be constructed from source code directly!
// Parsing is implicit - the relationship between source and AST is axiomatic.
data Program = 
    Source(code: String)                          // The source code as a string
  | AST(declarations: List(Declaration))          // The parsed AST
  | Parsed(code: String, ast: List(Declaration))  // Both: source + its parse

// --- Parse Relation ---
// The fundamental relationship: source code ↔ AST

structure ParsingRelation {
    // Parse function: String → Option(List(Declaration))
    // Returns None if parsing fails, Some(ast) if it succeeds
    operation parse : String → Option(List(Declaration))
    
    // Unparse function: List(Declaration) → String  
    // Pretty-prints AST back to source code
    operation unparse : List(Declaration) → String

    // Round-trip: parse then unparse gives equivalent source
    axiom roundtrip_parse_unparse : ∀(src : String, ast : List(Declaration)).
        parse(src) = Some(ast) → parse(unparse(ast)) = Some(ast)
    
    // Unparse always produces parseable code
    axiom unparse_always_parseable : ∀(ast : List(Declaration)).
        parse(unparse(ast)) = Some(ast)
    
    // Parse is deterministic: same source → same AST
    axiom parse_deterministic : ∀(src : String, ast1 : List(Declaration), ast2 : List(Declaration)).
        parse(src) = Some(ast1) ∧ parse(src) = Some(ast2) → ast1 = ast2
    
    // Valid source produces Some, invalid produces None
    axiom parse_total : ∀(src : String).
        (∃(ast : List(Declaration)). parse(src) = Some(ast)) ∨ parse(src) = None
}


// ============================================================================
// PART 2: Lexical Predicates (String → Bool)
// ============================================================================
//
// These predicates use Kleis string operations to recognize tokens.
// Z3's string theory can verify properties about these!

// Is the string a valid identifier?
define is_identifier(s : String) : Bool =
    strlen(s) > 0 ∧ 
    is_alpha_or_underscore(charAt(s, 0)) ∧
    all_alphanum_or_underscore(s, 1)

// Helper: first char must be letter or underscore
define is_alpha_or_underscore(c : String) : Bool =
    isAlpha(c) ∨ c = "_"

// Helper: remaining chars alphanumeric or underscore
define all_alphanum_or_underscore(s : String, start : ℕ) : Bool =
    if start >= strlen(s) then true
    else isAlphaNum(charAt(s, start)) ∨ charAt(s, start) = "_"
         ∧ all_alphanum_or_underscore(s, start + 1)

// Is the string a valid number?
define is_number(s : String) : Bool =
    isDigits(s) ∨ is_decimal(s) ∨ is_scientific(s)

// Is decimal: digits.digits
define is_decimal(s : String) : Bool =
    let dot_pos = indexOf(s, ".") in
    dot_pos > 0 ∧
    isDigits(substr(s, 0, dot_pos)) ∧
    isDigits(substr(s, dot_pos + 1, strlen(s) - dot_pos - 1))

// Is scientific: decimal e [+-]? digits
define is_scientific(s : String) : Bool =
    let e_pos = indexOf(s, "e") in
    if e_pos < 0 then
        let E_pos = indexOf(s, "E") in
        E_pos > 0 ∧ is_decimal(substr(s, 0, E_pos)) ∧ isDigits(substr(s, E_pos + 1, strlen(s) - E_pos - 1))
    else
        e_pos > 0 ∧ is_decimal(substr(s, 0, e_pos)) ∧ isDigits(substr(s, e_pos + 1, strlen(s) - e_pos - 1))

// Is the string a reserved keyword?
define is_keyword(s : String) : Bool =
    s = "if" ∨ s = "then" ∨ s = "else" ∨
    s = "let" ∨ s = "in" ∨
    s = "match" ∨
    s = "lambda" ∨
    s = "define" ∨
    s = "data" ∨ s = "type" ∨
    s = "structure" ∨ s = "implements" ∨
    s = "operation" ∨ s = "element" ∨ s = "axiom" ∨
    s = "forall" ∨ s = "exists" ∨
    s = "and" ∨ s = "or" ∨ s = "not" ∨
    s = "import" ∨ s = "extends" ∨ s = "over" ∨ s = "as"

// Is the string a primitive type name?
define is_primitive_type(s : String) : Bool =
    s = "ℝ" ∨ s = "Real" ∨
    s = "ℂ" ∨ s = "Complex" ∨
    s = "ℤ" ∨ s = "Int" ∨ s = "Integer" ∨
    s = "ℕ" ∨ s = "Nat" ∨
    s = "ℚ" ∨ s = "Rational" ∨
    s = "Bool" ∨ s = "String" ∨ s = "Unit"


// ============================================================================
// PART 3: Syntactic Predicates (Structural Validation)
// ============================================================================

// A program is valid if all declarations are valid
define is_valid_program(p : Program) : Bool =
    match p {
        Source(code) => true  // Source validity is string-based
      | AST(decls) => all_valid_declarations(decls)
      | Parsed(_, decls) => all_valid_declarations(decls)
    }

// All declarations must be valid
define all_valid_declarations(decls : List(Declaration)) : Bool =
    match decls {
        Nil => true
      | Cons(d, rest) => is_valid_declaration(d) ∧ all_valid_declarations(rest)
    }

// A declaration is valid based on its kind
define is_valid_declaration(d : Declaration) : Bool =
    match d {
        DImport(path) => strlen(path) > 0
      | DData(name, params, variants) => 
            is_identifier(name) ∧ 
            all_identifiers(params) ∧
            length(variants) > 0
      | DDefine(name, params, ret, body) =>
            is_identifier(name) ∧
            is_valid_expression(body)
      | DTypeAlias(name, target) =>
            is_identifier(name) ∧
            is_valid_type(target)
      | _ => true  // Other cases simplified
    }

// An expression is valid based on its structure
define is_valid_expression(e : Expression) : Bool =
    match e {
        EVariable(name) => is_identifier(name) ∧ ¬is_keyword(name)
      | ENumber(v) => true
      | EString(s) => true
      | EBool(b) => true
      | EOperation(name, args) => 
            is_identifier(name) ∧ 
            all_valid_expressions(args)
      | ELambda(params, body) =>
            length(params) > 0 ∧
            is_valid_expression(body)
      | ELet(pat, val, body) =>
            is_valid_pattern(pat) ∧
            is_valid_expression(val) ∧
            is_valid_expression(body)
      | EIf(cond, then_e, else_e) =>
            is_valid_expression(cond) ∧
            is_valid_expression(then_e) ∧
            is_valid_expression(else_e)
      | EForAll(vars, body) =>
            length(vars) > 0 ∧
            is_valid_expression(body)
      | EExists(vars, body) =>
            length(vars) > 0 ∧
            is_valid_expression(body)
      | _ => true
    }

// A type is valid
define is_valid_type(t : Type) : Bool =
    match t {
        TPrimitive(name) => is_primitive_type(name)
      | TVariable(name) => is_identifier(name)
      | TParametric(name, args) => 
            is_identifier(name) ∧ 
            all_valid_types(args)
      | TFunction(dom, cod) =>
            is_valid_type(dom) ∧ is_valid_type(cod)
      | TProduct(l, r) =>
            is_valid_type(l) ∧ is_valid_type(r)
    }

// A pattern is valid
define is_valid_pattern(p : Pattern) : Bool =
    match p {
        PWildcard => true
      | PVariable(name) => is_identifier(name)
      | PConstructor(name, args) => 
            is_identifier(name) ∧ 
            all_valid_patterns(args)
      | PAs(inner, alias) => 
            is_valid_pattern(inner) ∧ 
            is_identifier(alias)
      | PTuple(elems) => all_valid_patterns(elems)
      | PConstant(_) => true
    }

// Helper: all strings are identifiers
define all_identifiers(ss : List(String)) : Bool =
    match ss {
        Nil => true
      | Cons(s, rest) => is_identifier(s) ∧ all_identifiers(rest)
    }

// Helper: all expressions valid
define all_valid_expressions(es : List(Expression)) : Bool =
    match es {
        Nil => true
      | Cons(e, rest) => is_valid_expression(e) ∧ all_valid_expressions(rest)
    }

// Helper: all types valid
define all_valid_types(ts : List(Type)) : Bool =
    match ts {
        Nil => true
      | Cons(t, rest) => is_valid_type(t) ∧ all_valid_types(rest)
    }

// Helper: all patterns valid
define all_valid_patterns(ps : List(Pattern)) : Bool =
    match ps {
        Nil => true
      | Cons(p, rest) => is_valid_pattern(p) ∧ all_valid_patterns(rest)
    }


// ============================================================================
// PART 4: String-Based Source Analysis
// ============================================================================
//
// These predicates analyze source code AS STRINGS.
// Z3's string theory enables verification!

// Check if a string starts with a valid identifier
define starts_with_identifier(src : String) : Bool =
    strlen(src) > 0 ∧ is_alpha_or_underscore(charAt(src, 0))

// Check if a string looks like a define statement
define is_define_statement(src : String) : Bool =
    hasPrefix(src, "define ")

// Check if a string looks like a data definition
define is_data_definition(src : String) : Bool =
    hasPrefix(src, "data ")

// Check if a string looks like a structure
define is_structure_definition(src : String) : Bool =
    hasPrefix(src, "structure ")

// Check if a string looks like an import
define is_import_statement(src : String) : Bool =
    hasPrefix(src, "import ")

// Check if a string contains a lambda
define contains_lambda(src : String) : Bool =
    contains(src, "λ") ∨ contains(src, "lambda ")

// Check if a string contains a quantifier
define contains_quantifier(src : String) : Bool =
    contains(src, "∀") ∨ contains(src, "forall") ∨
    contains(src, "∃") ∨ contains(src, "exists")

// A define statement must have "define " prefix AND contain "="
define is_complete_define(src : String) : Bool =
    hasPrefix(src, "define ") ∧ contains(src, "=")

// A data definition must have variants
define is_complete_data(src : String) : Bool =
    hasPrefix(src, "data ") ∧ 
    contains(src, "=") ∧
    (contains(src, "|") ∨ strlen(src) > indexOf(src, "=") + 2)

// Check for balanced parentheses (simplified: count must match)
define has_balanced_parens(src : String) : Bool =
    count_char(src, "(") = count_char(src, ")")

// Count occurrences of a character
define count_char(src : String, ch : String) : ℕ =
    if ¬contains(src, ch) then 0
    else 1 + count_char(replace(src, ch, "", 1), ch)

// Count occurrences of a substring
define count_substring(src : String, sub : String) : ℕ =
    if ¬contains(src, sub) then 0
    else 1 + count_substring(replace(src, sub, "", 1), sub)

// Extract the name from a define statement
// "define foo(x) = ..." → "foo"
define extract_define_name(src : String) : String =
    if ¬is_define_statement(src) then ""
    else
        let after_define = substr(src, 7, strlen(src) - 7) in
        let paren_pos = indexOf(after_define, "(") in
        let space_pos = indexOf(after_define, " ") in
        if paren_pos > 0 ∧ (space_pos < 0 ∨ paren_pos < space_pos) then
            substr(after_define, 0, paren_pos)
        else if space_pos > 0 then
            substr(after_define, 0, space_pos)
        else
            after_define

// Check if identifier is a reserved word
define uses_reserved_identifier(src : String) : Bool =
    hasPrefix(src, "define if ") ∨
    hasPrefix(src, "define then ") ∨
    hasPrefix(src, "define else ") ∨
    hasPrefix(src, "define let ") ∨
    hasPrefix(src, "define match ") ∨
    hasPrefix(src, "define data ") ∨
    hasPrefix(src, "define define ")


// ============================================================================
// PART 5: Program Analysis Functions
// ============================================================================

// Count function definitions in a program
define count_functions(p : Program) : ℕ = 
    match p {
        Source(code) => count_substring(code, "define ")
      | AST(decls) => count_function_decls(decls)
      | Parsed(code, decls) => count_function_decls(decls)
    }

// Count function declarations in a list
define count_function_decls(decls : List(Declaration)) : ℕ =
    match decls {
        Nil => 0
      | Cons(DDefine(_, _, _, _), rest) => 1 + count_function_decls(rest)
      | Cons(_, rest) => count_function_decls(rest)
    }

// Check if program contains a function name in its body (simple recursion check)
define source_uses_name(src : String, name : String) : Bool =
    contains(src, concat(name, "(")) ∧ contains(src, concat("define ", name))


// ============================================================================
// CONCLUSION
// ============================================================================
//
// This file provides the core AST types and predicates for Kleis.
//
// For tests and examples, see: kleis_grammar_tests.kleis
// For cross-compiler, see: kleis_codegen_rust.kleis
//
// ============================================================================
