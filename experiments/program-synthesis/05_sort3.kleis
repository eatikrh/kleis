// Program Synthesis Experiment 5: Sort Three Elements
// Goal: Synthesize a program that sorts a list of 3 elements
//
// This is a sorting network synthesis problem!

// =============================================================================
// Sorting Network Template
// =============================================================================

// A sorting network for 3 elements uses compare-and-swap operations.
// Optimal network uses 3 comparisons:
//   compare(0,1) → compare(0,2) → compare(1,2)
//
// We'll let Z3 find which wires to compare at each stage.

// A compare-swap unit: given indices i,j and values, 
// swaps if out of order

define min2(a: ℤ, b: ℤ) : ℤ = if a <= b then a else b
define max2(a: ℤ, b: ℤ) : ℤ = if a <= b then b else a

// Compare-swap on positions (i,j) of triple (a, b, c)
// Returns new triple

// Encoding: use 3 stages of potential swaps
// Stage 1: swap positions (s1a, s1b) where s1a, s1b ∈ {0,1,2}
// Stage 2: swap positions (s2a, s2b)
// Stage 3: swap positions (s3a, s3b)

// Get element by index
define get(idx: ℤ, a: ℤ, b: ℤ, c: ℤ) : ℤ =
    if idx = 0 then a else if idx = 1 then b else c

// After one compare-swap on indices i,j, get new value at position k
define after_swap(i: ℤ, j: ℤ, k: ℤ, a: ℤ, b: ℤ, c: ℤ) : ℤ =
    if k = i then min2(get(i, a, b, c), get(j, a, b, c))
    else if k = j then max2(get(i, a, b, c), get(j, a, b, c))
    else get(k, a, b, c)

// For simplicity, let's just verify a known good network: (0,1), (0,2), (1,2)
// Then ask Z3 to FIND such a network.

// After stage 1: swap (0,1)
define s1_0(a: ℤ, b: ℤ, c: ℤ) : ℤ = min2(a, b)
define s1_1(a: ℤ, b: ℤ, c: ℤ) : ℤ = max2(a, b)
define s1_2(a: ℤ, b: ℤ, c: ℤ) : ℤ = c

// After stage 2: swap (0,2) on result of stage 1
define s2_0(a: ℤ, b: ℤ, c: ℤ) : ℤ = min2(s1_0(a,b,c), s1_2(a,b,c))
define s2_1(a: ℤ, b: ℤ, c: ℤ) : ℤ = s1_1(a,b,c)
define s2_2(a: ℤ, b: ℤ, c: ℤ) : ℤ = max2(s1_0(a,b,c), s1_2(a,b,c))

// After stage 3: swap (1,2) on result of stage 2
define s3_0(a: ℤ, b: ℤ, c: ℤ) : ℤ = s2_0(a,b,c)
define s3_1(a: ℤ, b: ℤ, c: ℤ) : ℤ = min2(s2_1(a,b,c), s2_2(a,b,c))
define s3_2(a: ℤ, b: ℤ, c: ℤ) : ℤ = max2(s2_1(a,b,c), s2_2(a,b,c))

// =============================================================================
// Verification (not synthesis yet)
// =============================================================================

// Verify the network sorts correctly:
// :sat s3_0(3,1,2) = 1 ∧ s3_1(3,1,2) = 2 ∧ s3_2(3,1,2) = 3
// :sat s3_0(5,3,4) = 3 ∧ s3_1(5,3,4) = 4 ∧ s3_2(5,3,4) = 5

// =============================================================================
// Synthesis: Find the network indices
// =============================================================================

// Now let's actually synthesize! Search for swap indices.
// Network has 3 stages, each swaps two wires.
// Wire indices: 0, 1, 2

// Parameterized network
define net_result(i1: ℤ, j1: ℤ, i2: ℤ, j2: ℤ, i3: ℤ, j3: ℤ, 
                  pos: ℤ, a: ℤ, b: ℤ, c: ℤ) : ℤ =
    // This is getting complex... let's use a simpler encoding
    0  // placeholder

// Simpler: Just search over which elements to output
// Output: (o0, o1, o2) where each is a selection from {a, b, c} based on comparisons

// For 3 elements, there are 6 permutations. We search for the logic.
// This is essentially synthesizing a multiplexer.

// Actually, let's just verify our hardcoded network works:

