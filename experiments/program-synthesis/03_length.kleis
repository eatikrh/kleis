// Program Synthesis Experiment 3: List Length
// Goal: Synthesize a program that computes length of a list
//
// Challenge: This requires reasoning about recursion
//
// Approach: Use a recursive TEMPLATE and synthesize the parameters
//
// Template: length(xs) = if isEmpty(xs) then BASE else STEP + length(tail(xs))
//
// Search for: BASE (a constant) and STEP (a constant)

// =============================================================================
// Encoding Lists (simplified - as nesting depth)
// =============================================================================

// We represent lists by their length (since that's what we're computing)
// This is a "trick" for synthesis - we work backwards from the answer

// For real lists, we'd use ADTs, but Z3 handles recursive ADTs poorly for synthesis.
// Instead: list of length n is just the number n.

// Template: length(n) = if n = 0 then BASE else STEP + length(n - 1)
// This expands to: BASE + STEP * n

define template_length(base: ℤ, step: ℤ, list_len: ℤ) : ℤ =
    base + step * list_len

// Specification:
//   length([]) = 0
//   length([a]) = 1  
//   length([a,b]) = 2
//   length([a,b,c]) = 3

// Query:
// :sat ∃(base step : ℤ).
//     template_length(base, step, 0) = 0 ∧
//     template_length(base, step, 1) = 1 ∧
//     template_length(base, step, 2) = 2 ∧
//     template_length(base, step, 3) = 3

// Expected: base = 0, step = 1
// Meaning: length(xs) = 0 + 1 * |xs| = |xs|

// =============================================================================
// More interesting: Synthesize "double length"
// =============================================================================

// Spec: f([]) = 0, f([a]) = 2, f([a,b]) = 4
// Expected: base = 0, step = 2

