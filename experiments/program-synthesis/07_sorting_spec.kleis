// ============================================================================
// FORMAL SPECIFICATION: Sorting for Lists of Any Size
// ============================================================================
//
// This defines what "sorting" MEANS mathematically.
// A correct sorting function must satisfy this specification.
//
// ============================================================================

import "stdlib/prelude.kleis"

// ============================================================================
// PART 1: What does "sorted" mean?
// ============================================================================

// A list is sorted if every element is <= the next element.
// Formally: ∀i. 0 ≤ i < length(xs) - 1 → xs[i] ≤ xs[i+1]

// Recursive definition (equivalent, easier to express):
// - Empty list is sorted
// - Singleton list is sorted  
// - Cons(x, xs) is sorted if x <= head(xs) AND xs is sorted

define is_sorted(xs: List(ℤ)) : Bool =
    match xs {
        Nil => true
      | Cons(x, Nil) => true
      | Cons(x, Cons(y, rest)) => x <= y ∧ is_sorted(Cons(y, rest))
    }

// ============================================================================
// PART 2: What does "permutation" mean?
// ============================================================================

// Two lists are permutations if they have the same elements with same counts.
// Formally: ∀v. count(v, xs) = count(v, ys)

// Count occurrences of a value in a list
define count(v: ℤ, xs: List(ℤ)) : ℤ =
    match xs {
        Nil => 0
      | Cons(x, rest) => (if x = v then 1 else 0) + count(v, rest)
    }

// Permutation: same length AND same counts for all elements
// (Same counts implies same length, but we can check both)

define same_counts(xs: List(ℤ), ys: List(ℤ), elements: List(ℤ)) : Bool =
    match elements {
        Nil => true
      | Cons(v, rest) => count(v, xs) = count(v, ys) ∧ same_counts(xs, ys, rest)
    }

// For is_permutation, we check counts for all elements in both lists
define is_permutation(xs: List(ℤ), ys: List(ℤ)) : Bool =
    length(xs) = length(ys) ∧ 
    same_counts(xs, ys, xs) ∧ 
    same_counts(xs, ys, ys)

// Helper: length of a list
define length(xs: List(ℤ)) : ℤ =
    match xs {
        Nil => 0
      | Cons(_, rest) => 1 + length(rest)
    }

// ============================================================================
// PART 3: THE SORTING SPECIFICATION
// ============================================================================

// A function `sort` is a correct sorting function if:
//   ∀(xs : List(ℤ)). is_sorted(sort(xs)) ∧ is_permutation(sort(xs), xs)

structure SortingSpec {
    // The specification as an axiom
    axiom sort_correct : ∀(xs : List(ℤ)).
        is_sorted(sort(xs)) ∧ is_permutation(sort(xs), xs)
}

// ============================================================================
// PART 4: Verification - Does a given function satisfy the spec?
// ============================================================================

// We can VERIFY that a sorting function is correct by checking:
// :sat is_sorted(sort([3,1,2])) ∧ is_permutation(sort([3,1,2]), [3,1,2])

// For a specific implementation, we can verify:
// define my_sort(xs) = ... 
// :sat ∀(xs). is_sorted(my_sort(xs)) ∧ is_permutation(my_sort(xs), xs)

// ============================================================================
// PART 5: Synthesis Challenge
// ============================================================================

// To SYNTHESIZE a sorting function, we need Z3 to find:
//   ∃(sort : List(ℤ) → List(ℤ)). ∀(xs). is_sorted(sort(xs)) ∧ is_permutation(sort(xs), xs)
//
// This is hard because:
// 1. Searching over function space is infinite
// 2. Universal quantifier over all lists is infinite
//
// Practical approaches:
// - Bounded synthesis: fix list size, find program
// - Example-based: provide test cases, synthesize
// - Template-based: fix program structure (e.g., insertion sort skeleton), find parameters

// ============================================================================
// PART 6: Example Verification
// ============================================================================

// Test the predicates work correctly:

// :eval is_sorted(Cons(1, Cons(2, Cons(3, Nil))))           -- should be true
// :eval is_sorted(Cons(3, Cons(1, Cons(2, Nil))))           -- should be false
// :eval is_permutation(Cons(1,Cons(2,Nil)), Cons(2,Cons(1,Nil)))  -- should be true
// :eval is_permutation(Cons(1,Cons(2,Nil)), Cons(1,Cons(3,Nil)))  -- should be false

