import "../theories/pot_admissible_kernels_v2.kleis"

data SpinorField = SF(ℤ)

data DetectorAngle = DA(ℤ)

structure SpinorAlgebra {
    operation spinor_add : SpinorField -> SpinorField -> SpinorField
    operation spinor_smul : ℂ -> SpinorField -> SpinorField
    element spinor_zero : SpinorField
    axiom spinor_add_comm : ∀(s1 s2 : SpinorField). spinor_add(s1, s2) = spinor_add(s2, s1)
    axiom spinor_add_id : ∀(s : SpinorField). spinor_add(s, spinor_zero) = s
}

structure KernelFactorization {
    operation K_univ : GreenKernel
    operation K_dyn : GreenKernel
    operation K_rep : GreenKernel

    axiom univ_admissible : is_admissible(K_univ)
    axiom dyn_admissible : is_admissible(K_dyn)
    axiom rep_admissible : is_admissible(K_rep)

    operation unified_kernel : GreenKernel
    axiom kernel_factorizes : unified_kernel = compose_kernel(K_univ, compose_kernel(K_dyn, K_rep))
}

structure EntangledState {
    operation psi_AB : Flow

    operation project_at : GreenKernel -> Flow -> DetectorAngle -> SpinorField

    axiom non_separable : ∀(psi_A psi_B : Flow, G : GreenKernel, a b : DetectorAngle).
        implies(is_admissible(G),
            not(project_at(G, psi_AB, a) = project_at(G, flow_add(psi_A, psi_B), a)
                and project_at(G, psi_AB, b) = project_at(G, flow_add(psi_A, psi_B), b)))

    axiom single_source : ∀(G : GreenKernel, a b : DetectorAngle).
        implies(is_admissible(G),
            equiv(G, psi_AB, psi_AB))
}

structure Separability {
    operation is_product_state : Flow -> Bool

    axiom entangled_exists : ∀(G : GreenKernel).
        implies(is_admissible(G), not(is_product_state(psi_AB)))

    axiom product_states_factor : ∀(G : GreenKernel, psi : Flow, a b : DetectorAngle).
        implies(and(is_admissible(G), is_product_state(psi)),
            ∃(psi_A psi_B : Flow).
                project_at(G, psi, a) = project_at(G, psi_A, a)
                and project_at(G, psi, b) = project_at(G, psi_B, b))
}

structure MeasurementProjection {
    operation angle_between : DetectorAngle -> DetectorAngle -> ℝ
    operation spinor_inner : SpinorField -> SpinorField -> ℝ
    operation spin_outcome : GreenKernel -> Flow -> DetectorAngle -> ℝ

    axiom angle_symmetric : ∀(a b : DetectorAngle). angle_between(a, b) = angle_between(b, a)

    axiom angle_self_zero : ∀(a : DetectorAngle). angle_between(a, a) = 0

    axiom outcome_from_projection : ∀(G : GreenKernel, psi : Flow, a : DetectorAngle).
        implies(is_admissible(G),
            spin_outcome(G, psi, a) = spinor_inner(project_at(G, psi, a), project_at(G, psi, a)))

    axiom inner_normalized : ∀(G : GreenKernel, a : DetectorAngle).
        implies(is_admissible(G),
            spinor_inner(project_at(G, psi_AB, a), project_at(G, psi_AB, a)) = 1)
}

structure BellCorrelation {
    operation correlation : GreenKernel -> Flow -> DetectorAngle -> DetectorAngle -> ℝ
    operation neg_cos : ℝ -> ℝ

    axiom correlation_def : ∀(G : GreenKernel, a b : DetectorAngle).
        implies(is_admissible(G),
            correlation(G, psi_AB, a, b) = spinor_inner(project_at(G, psi_AB, a), project_at(G, psi_AB, b)))

    axiom singlet_correlation : ∀(G : GreenKernel, a b : DetectorAngle).
        implies(is_admissible(G),
            correlation(G, psi_AB, a, b) = neg_cos(angle_between(a, b)))

    axiom neg_cos_zero : neg_cos(0) = 0 - 1

    axiom neg_cos_pi : neg_cos(pi()) = 1
}

structure AnticorrelationLemma {
    axiom same_detector_anticorrelation : ∀(G : GreenKernel, a : DetectorAngle).
        implies(is_admissible(G),
            correlation(G, psi_AB, a, a) = neg_cos(0))

    axiom anticorrelation_value : ∀(G : GreenKernel, a : DetectorAngle).
        implies(is_admissible(G),
            correlation(G, psi_AB, a, a) = 0 - 1)
}

structure BellInequality {
    operation bell_lhs : GreenKernel -> Flow -> DetectorAngle -> DetectorAngle -> DetectorAngle -> ℝ
    operation bell_rhs : GreenKernel -> Flow -> DetectorAngle -> DetectorAngle -> DetectorAngle -> ℝ

    axiom bell_lhs_def : ∀(G : GreenKernel, psi : Flow, a b c : DetectorAngle).
        implies(is_admissible(G),
            bell_lhs(G, psi, a, b, c) = abs(correlation(G, psi, a, b) - correlation(G, psi, a, c)))

    axiom bell_rhs_def : ∀(G : GreenKernel, psi : Flow, a b c : DetectorAngle).
        implies(is_admissible(G),
            bell_rhs(G, psi, a, b, c) = 1 + correlation(G, psi, b, c))

    axiom bell_holds_for_product : ∀(G : GreenKernel, psi : Flow, a b c : DetectorAngle).
        implies(and(is_admissible(G), is_product_state(psi)),
            bell_lhs(G, psi, a, b, c) <= bell_rhs(G, psi, a, b, c))
}

structure BellViolation {
    axiom entangled_violates_bell : ∀(G : GreenKernel).
        implies(is_admissible(G),
            ∃(a b c : DetectorAngle).
                bell_lhs(G, psi_AB, a, b, c) > bell_rhs(G, psi_AB, a, b, c))

    axiom violation_legitimate : ∀(G : GreenKernel).
        implies(is_admissible(G), not(is_product_state(psi_AB)))
}
