# Cursor AI Rules for this Project

## Git Repository Rules

**CRITICAL: NEVER push to any git repository without explicit user permission.**

### Why This Is Critical - The Safe Harbor Principle

Local commits are "safe harbors" - checkpoints the user can return to.

**If LLM can push:**
- Current safe harbor destroyed (work becomes public)
- ALL safe harbors at risk (force push could rewrite history)
- Psychological safety lost (can't experiment freely)
- Entire repository integrity threatened

**The human must control the boundary between:**
- Private (local repo) ← LLM can work here
- Public (remote repo) ← Only human crosses this line

### Rules

- You may stage files (`git add`)
- You may commit files (`git commit`)
- You must ALWAYS ask before running `git push`
- You must NEVER run `git push --force` (EVER)
- Stop after committing and ask: "The changes are committed. Would you like me to push to GitHub now?"
- Wait for explicit "yes" or "push" command from the user before executing any `git push` operation
- This rule applies to ALL branches and ALL remotes
- No exceptions, no shortcuts, no "just this once"

**Push is the irreversible action - human must control it.**

## General Guidelines

- Follow user instructions carefully
- Ask for clarification when uncertain
- Be respectful of the user's workflow and preferences

## Parser Development Rules

**CRITICAL: Parser changes must align with formal grammar.**

### Rule: Grammar Consistency Check

**When modifying `src/kleis_parser.rs`:**

1. **Check against formal grammar** in `docs/grammar/kleis_grammar_v03.ebnf` or `docs/grammar/Kleis_v03.g4`
2. **Verify change is valid** according to formal specification
3. **Document any deviations** with rationale
4. **Update grammar if needed** (requires ADR if significant)

**Grammar files:**
- `docs/grammar/kleis_grammar_v03.ebnf` - EBNF specification (source of truth)
- `docs/grammar/Kleis_v03.g4` - ANTLR4 grammar
- `docs/grammar/kleis_grammar_v03.md` - Human-readable explanation

**Process:**
```
Before changing parser:
→ Read relevant grammar section
→ Verify change matches specification
→ If deviation needed, document why

After changing parser:
→ Test with examples from grammar
→ Update grammar docs if specification changed
→ Note any limitations in parser file comments
```

**Why this matters:**
- Parser is ~30% of full grammar (by design, POC)
- Must stay aligned with formal specification
- Prevents drift between implementation and design
- Makes future full parser implementation easier

## Type System Rules

**CRITICAL: Follow ADR-016 (Operations in Structures).**

### Rule: No Hardcoding Types

**Types and operations MUST be defined in Kleis structures, NOT hardcoded in Rust.**

**❌ WRONG - Hardcoded in type_inference.rs:**
```rust
"matrix2x3" => Ok(Type::Matrix(2, 3))  // BAD!
"matmul" => /* hardcoded matrix multiplication logic */  // BAD!
```

**✅ CORRECT - Defined in stdlib/*.kleis:**
```kleis
structure Matrix(m: Nat, n: Nat, T) {
    operation transpose : Matrix(n, m, T)
}

implements Matrix(m, n, ℝ) {
    operation transpose = builtin_transpose
}
```

**Then type inference queries the registry:**
```rust
// Query: What type does "matrix2x3" produce?
let ty = type_checker.infer_from_registry("matrix2x3", args)?;

// Query: Does Matrix(2,3) support multiply with Matrix(3,2)?  
let result_ty = type_checker.check_operation("multiply", &[t1, t2])?;
```

**Why this matters:**
- **Extensibility:** Users can define custom types without changing Rust code
- **Consistency:** Single source of truth (stdlib/*.kleis files)
- **Self-hosting:** Kleis defines itself in Kleis (ADR-003)
- **Maintainability:** Type rules live with their structures

**Exceptions:**
- **Built-in primitives only:** Scalar, basic arithmetic (+, -, *, /)
- **Everything else:** Define in stdlib/*.kleis structures

**When tempted to hardcode:**
1. Stop and ask: "Should this be a structure?"
2. If yes: Create/update stdlib/*.kleis file
3. Make type inference query the registry
4. Document the structure with axioms

**Related ADRs:**
- ADR-016: Operations in Structures (the foundation)
- ADR-015: Text as Source of Truth (applies to types too)
- ADR-003: Self-Hosting Strategy (Kleis defines Kleis)

## Documentation Organization Rules

**When creating documentation during a session:**

1. **Combine overlapping content** - Review documents for redundancy and consolidate
2. **Check for obsolete documents** - Remove or archive documents that are superseded
3. **Organize into subdirectories** - Don't leave many documents in root `docs/`
   - Use `docs/session-YYYY-MM-DD/` for session-specific work
   - Use `docs/notation/`, `docs/parser-implementation/`, `docs/type-system/` etc. for topic-specific docs
   - Keep only ADRs and main reference docs in root
4. **Create session README** - Summarize session work in `docs/session-YYYY-MM-DD/README.md`
5. **Update main README** - Keep `docs/README.md` as the navigation index

**Cleanup checklist before ending session:**
- [ ] Consolidate overlapping documents
- [ ] Move session-specific docs to session folder
- [ ] Move technical docs to appropriate subdirectories  
- [ ] Delete obsolete/temporary documents
- [ ] Update docs/README.md with navigation
- [ ] Create session README summarizing work

## Project Root Organization Rules

**Keep project root clean:**

1. **Generated reports** - Keep in root if they show current state
   - `comparison_report.html` - Test comparison (useful for viewing)
   - `html_gallery.html` - Rendering gallery (useful for viewing)
   - `template_coverage_report.html` - Template coverage (useful for viewing)
   - These are snapshots showing current system state

2. **No loose markdown files in root** - Except:
   - README.md
   - CHANGELOG.md
   - LICENSE
   - CONTRIBUTING.md (if exists)
   - PARSER_TODO.md, SERVER_README.md (project docs)

3. **Temporary files** - Add to .gitignore:
   - `tmp_*.html`, `tmp_*.pdf`
   - Build artifacts
   - Editor temp files

