# Cursor AI Rules for this Project

## Git Repository Rules

**CRITICAL: NEVER push to any git repository without explicit user permission.**

### Why This Is Critical - The Safe Harbor Principle

Local commits are "safe harbors" - checkpoints the user can return to.

**If LLM can push:**
- Current safe harbor destroyed (work becomes public)
- ALL safe harbors at risk (force push could rewrite history)
- Psychological safety lost (can't experiment freely)
- Entire repository integrity threatened

**The human must control the boundary between:**
- Private (local repo) ← LLM can work here
- Public (remote repo) ← Only human crosses this line

### Rules

- You may stage files (`git add`)
- You may commit files (`git commit`)
- You must ALWAYS ask before running `git push`
- You must NEVER run `git push --force` (EVER)
- Stop after committing and ask: "The changes are committed. Would you like me to push to GitHub now?"
- Wait for explicit "yes" or "push" command from the user before executing any `git push` operation
- This rule applies to ALL branches and ALL remotes
- No exceptions, no shortcuts, no "just this once"

**Push is the irreversible action - human must control it.**

## General Guidelines

- Follow user instructions carefully
- Ask for clarification when uncertain
- Be respectful of the user's workflow and preferences

## Rust Code Quality Rules

**CRITICAL: Run quality checks before committing .rs files.**

### Rule: Pre-Commit Quality Gates

**Before committing any Rust code changes:**

1. **Format code** (required)
   ```bash
   cargo fmt
   ```
   - Ensures consistent code style
   - GitHub CI will fail if formatting is incorrect
   - Run automatically before every commit

2. **Run clippy** (required)
   ```bash
   cargo clippy --all-targets --all-features
   ```
   - Catches common mistakes and anti-patterns
   - Fix all clippy warnings before committing
   - GitHub CI runs this check

3. **Run tests** (required)
   ```bash
   cargo test --lib
   ```
   - Ensures no regressions
   - Must pass (279 tests as of Dec 6, 2024)
   - GitHub CI runs this exact command

**Process:**
```
Before committing .rs files:
→ Run: cargo fmt
→ Run: cargo clippy --all-targets --all-features
→ Run: cargo test --lib
→ Fix any errors/warnings
→ Then commit

If tests fail:
→ Fix the code OR
→ Document why test should be ignored
→ Never commit broken tests
```

**Why this matters:**
- Prevents CI failures
- Maintains code quality
- Catches bugs early
- Ensures consistent style
- Professional development practice

**GitHub CI checks these exact commands:**
- `cargo fmt -- --check` (formatting)
- `cargo clippy --all-targets --all-features -- -D warnings` (linting)
- `cargo test --lib --verbose` (tests)

**Exceptions:**
- Quick documentation-only commits (no .rs files changed): skip
- Clippy warnings in legacy code: can continue-on-error, but fix if possible
- Known test failures: documented in test files with `#[ignore]`

## Parser Development Rules

**CRITICAL: Parser changes must align with formal grammar.**

### Rule: Grammar Consistency Check

**When modifying `src/kleis_parser.rs`:**

1. **Check against formal grammar** in `docs/grammar/kleis_grammar_v03.ebnf` or `docs/grammar/Kleis_v03.g4`
2. **Verify change is valid** according to formal specification
3. **Document any deviations** with rationale
4. **Update grammar if needed** (requires ADR if significant)

**Grammar files:**
- `docs/grammar/kleis_grammar_v03.ebnf` - EBNF specification (source of truth)
- `docs/grammar/Kleis_v03.g4` - ANTLR4 grammar
- `docs/grammar/kleis_grammar_v03.md` - Human-readable explanation

**Process:**
```
Before changing parser:
→ Read relevant grammar section
→ Verify change matches specification
→ If deviation needed, document why

After changing parser:
→ Test with examples from grammar
→ Update grammar docs if specification changed
→ Note any limitations in parser file comments
```

**Why this matters:**
- Parser is ~30% of full grammar (by design, POC)
- Must stay aligned with formal specification
- Prevents drift between implementation and design
- Makes future full parser implementation easier

## Type System Rules

**CRITICAL: Follow ADR-014 (Hindley-Milner Type System) and ADR-016 (Operations in Structures).**

### Rule: Maintain Type System Integrity (ADR-014)

**The type system must follow Hindley-Milner principles.**

**Core Principles:**

1. **Constraint-based inference** - Generate constraints, then unify
2. **Principal types** - Always infer the most general type
3. **No shortcuts** - Don't bypass unification or constraint solving
4. **Context threading** - Pass `context_builder` through call chain

**❌ WRONG - Bypassing type inference:**
```rust
// Hardcoding result type without inference
fn check_multiply(t1: Type, t2: Type) -> Type {
    Type::Matrix(2, 2)  // BAD! Ignores actual dimensions
}

// Skipping constraint generation
let t1 = self.infer(&args[0], context_builder)?;
// Just return without adding constraints  // BAD!
return Ok(Type::Scalar);
```

**✅ CORRECT - Proper HM inference:**
```rust
// Generate constraints
let t1 = self.infer(&args[0], context_builder)?;
let t2 = self.infer(&args[1], context_builder)?;
self.add_constraint(t1.clone(), t2.clone());

// Delegate to context_builder for operation types
if let Some(builder) = context_builder {
    builder.infer_operation_type(name, &[t1, t2])
} else {
    Ok(self.context.fresh_var())
}
```

**When modifying type inference:**
1. **Always generate constraints** - Don't hardcode results
2. **Always delegate operations** - Use `context_builder.infer_operation_type()`
3. **Always thread context** - Pass `context_builder` through recursive calls
4. **Always unify** - Let the solver determine types

**Key Files:**
- `src/type_inference.rs` - Core HM algorithm
- `src/type_context.rs` - Type registry and queries
- `src/type_checker.rs` - Combines inference + registry
- `stdlib/*.kleis` - Type definitions (source of truth)

**Related ADRs:**
- ADR-014: Hindley-Milner Type System (the algorithm)
- ADR-016: Operations in Structures (the architecture)
- ADR-015: Text as Source of Truth (where types are defined)

---

### Rule: No Hardcoding Types (ADR-016)

**Types and operations MUST be defined in Kleis structures, NOT hardcoded in Rust.**

**❌ WRONG - Hardcoded in type_inference.rs:**
```rust
"matrix2x3" => Ok(Type::Matrix(2, 3))  // BAD!
"matmul" => /* hardcoded matrix multiplication logic */  // BAD!
```

**✅ CORRECT - Defined in stdlib/*.kleis:**
```kleis
structure Matrix(m: Nat, n: Nat, T) {
    operation transpose : Matrix(n, m, T)
}

implements Matrix(m, n, ℝ) {
    operation transpose = builtin_transpose
}
```

**Then type inference queries the registry:**
```rust
// Query: What type does "matrix2x3" produce?
let ty = type_checker.infer_from_registry("matrix2x3", args)?;

// Query: Does Matrix(2,3) support multiply with Matrix(3,2)?  
let result_ty = type_checker.check_operation("multiply", &[t1, t2])?;
```

**Why this matters:**
- **Extensibility:** Users can define custom types without changing Rust code
- **Consistency:** Single source of truth (stdlib/*.kleis files)
- **Self-hosting:** Kleis defines itself in Kleis (ADR-003)
- **Maintainability:** Type rules live with their structures

**Exceptions:**
- **Built-in primitives only:** Scalar, basic arithmetic (+, -, *, /)
- **Everything else:** Define in stdlib/*.kleis structures

**When tempted to hardcode:**
1. Stop and ask: "Should this be a structure?"
2. If yes: Create/update stdlib/*.kleis file
3. Make type inference query the registry
4. Document the structure with axioms

**Related ADRs:**
- ADR-016: Operations in Structures (the foundation)
- ADR-015: Text as Source of Truth (applies to types too)
- ADR-003: Self-Hosting Strategy (Kleis defines Kleis)

## Documentation Organization Rules

**When creating documentation during a session:**

1. **Combine overlapping content** - Review documents for redundancy and consolidate
2. **Check for obsolete documents** - Remove or archive documents that are superseded
3. **Organize into subdirectories** - Don't leave many documents in root `docs/`
   - Use `docs/session-YYYY-MM-DD/` for session-specific work
   - Use `docs/notation/`, `docs/parser-implementation/`, `docs/type-system/` etc. for topic-specific docs
   - Keep only ADRs and main reference docs in root
4. **Create session README** - Summarize session work in `docs/session-YYYY-MM-DD/README.md`
5. **Update main README** - Keep `docs/README.md` as the navigation index

**Cleanup checklist before ending session:**
- [ ] Consolidate overlapping documents
- [ ] Move session-specific docs to session folder
- [ ] Move technical docs to appropriate subdirectories  
- [ ] Delete obsolete/temporary documents
- [ ] Update docs/README.md with navigation
- [ ] Create session README summarizing work

## Project Root Organization Rules

**Keep project root clean:**

1. **Generated reports** - Keep in root if they show current state
   - `comparison_report.html` - Test comparison (useful for viewing)
   - `html_gallery.html` - Rendering gallery (useful for viewing)
   - `template_coverage_report.html` - Template coverage (useful for viewing)
   - These are snapshots showing current system state

2. **No loose markdown files in root** - Except:
   - README.md
   - CHANGELOG.md
   - LICENSE
   - CONTRIBUTING.md (if exists)
   - PARSER_TODO.md, SERVER_README.md (project docs)

3. **Temporary files** - Add to .gitignore:
   - `tmp_*.html`, `tmp_*.pdf`
   - Build artifacts
   - Editor temp files

