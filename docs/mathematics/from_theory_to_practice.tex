\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{geometry}
\geometry{margin=1in}

\title{\textbf{From Theory to Practice}\\[4pt]
\large Bridging Kleis Semantics and Rust Implementations}
\author{Kleis Language Project}
\date{}

\begin{document}
\maketitle

\section{From Theory to Practice: Bridging Kleis Semantics and Rust Implementations}

Kleis is defined as a mathematically precise language whose semantics
are given by inference rules, algebraic structures, and type-theoretic
principles.
However, practical implementations---for example, in Rust---must realize
these abstract notions as executable code.
This section explains how each theoretical notion in Kleis corresponds
to a concrete programming construct, showing how abstract semantics
guides low-level implementation decisions.

\subsection{1. Structures as Implementable Interfaces}

In the formalism, a \texttt{structure} is a tuple of operations and
elements together with a collection of axioms:

\[
\frac{
  \forall x,y,z\in M.\ (x\cdot y)\cdot z = x\cdot (y\cdot z)
}{
  \texttt{structure Monoid(M)}\ \{\ \cdots\ \}
}
\]

The semantics treats structures as \emph{records of functions} with
behavioral laws.

In practice, Rust realizes this as:

\begin{itemize}
  \item a \emph{trait} specifying the operations,
  \item one or more \emph{impl blocks} providing concrete functions,
  \item unit and property tests approximating the axioms.
\end{itemize}

Thus, structures move from “semantic entities with axioms” to
“trait interfaces with verifiable behavior.”

\subsection{2. Implementations as Semantic Instantiations}

The formal semantics interprets:

\[
\texttt{implements Monoid}(T)
\]

as:
“Provide the interpretation of each operation of the \texttt{Monoid}
structure for the type $T$, ensuring the axioms hold.”

Rust instantiates this via:

\begin{verbatim}
impl Monoid for i64 { ... }
\end{verbatim}

The compiler verifies:
\begin{itemize}
  \item that all required operations are implemented,
  \item that the signatures match.
\end{itemize}

The axioms---associativity, identity---cannot be encoded in Rust’s type
system; thus, they are validated through:
\begin{itemize}
  \item symbolic property tests,
  \item documentation of lawfulness,
  \item static analysis (e.g.\ dimension checks for matrices).
\end{itemize}

Hence, implementation corresponds to \emph{semantic instantiation}, and
testing corresponds to \emph{axiom validation}.

\subsection{3. Algebraic Data Types and Constructors}

The formal Kleis syntax:

\[
\texttt{data Option(T) = None | Some(T)}
\]

is modeled in the semantics as a disjoint sum type:

\[
\textsf{Option}(T) \cong 1 + T.
\]

Rust realizes this as:

\begin{verbatim}
enum Option<T> { None, Some(T) }
\end{verbatim}

Constructor semantics is preserved exactly:
\begin{itemize}
  \item \texttt{None} is a nullary constructor ($1$),
  \item \texttt{Some} is a unary constructor.
\end{itemize}

The operational semantics rule:

\[
\frac{}{ \rho \vdash C(v_1,\dots,v_k) \Downarrow C(v_1,\dots,v_k) }
\]

maps directly to Rust’s cost-free enum construction.

Thus, data constructors in Kleis correspond to zero-overhead tagged
unions in Rust.

\subsection{4. Pattern Matching and Exhaustiveness}

Kleis pattern matching is defined by a judgment:

\[
\textsf{match}(p, v) = \theta
\]

and an operational rule:

\[
\frac{
  \rho \vdash e \Downarrow v
  \qquad
  \textsf{firstMatch}(v, p_i \Rightarrow e_i) = (\theta, e_k)
}{
  \rho \vdash \texttt{match } e \{ \cdots \} \Downarrow v'
}
\]

Rust implements this directly:

\begin{verbatim}
match x {
    None => 0,
    Some(v) => v,
}
\end{verbatim}

Rust enforces:

\begin{enumerate}
  \item \emph{exhaustiveness}, corresponding to the Kleis judgment
        $\mathsf{Exh}(T,\{p_1,\dots,p_n\})$,
  \item \emph{non-redundancy}, corresponding to the Kleis
        $\mathsf{NR}(T,\vec{p})$ analysis.
\end{enumerate}

In Kleis, these are semantic judgments and algorithmic procedures.
In Rust, they are enforced by the compiler.

Thus, the semantics of pattern matching transitions almost perfectly
into Rust’s \texttt{match} system.

\subsection{5. Parametric Types and Indices}

Index-polymorphic types such as:

\[
\texttt{Matrix}(m,n,T)
\]

formally behave as families indexed by natural numbers:

\[
\mathsf{Matrix} : \mathbb{N} \times \mathbb{N} \times \mathsf{Type} \to \mathsf{Type}.
\]

The Kleis type checker ensures dimension-correct operations:

\[
\texttt{Matrix}(m,n,T) \times \texttt{Matrix}(n,p,T)
          \to \texttt{Matrix}(m,p,T).
\]

Rust implements this via \emph{const generics}:

\begin{verbatim}
struct Matrix<T, const M: usize, const N: usize> {
    data: [[T; N]; M],
}
\end{verbatim}

The Rust compiler enforces dimension correctness:

\begin{verbatim}
fn multiply<const M: usize, const N: usize, const P: usize>(
    a: Matrix<T, M, N>,
    b: Matrix<T, N, P>)
-> Matrix<T, M, P> { ... }
\end{verbatim}

Thus, type-level indices become const generics in Rust.

\subsection{6. Laws and Axioms in Practice}

Kleis includes formal axioms:

\[
\forall x,y,z.\ (x\cdot y)\cdot z = x\cdot (y\cdot z).
\]

The semantics treats axioms as constraints on valid implementations.

Rust cannot encode axioms in its type system, but it bridges the gap by:

\begin{itemize}
  \item property tests (\texttt{proptest}),
  \item fuzzing strategies,
  \item runtime assertions,
  \item documentation stating the “lawful” contract.
\end{itemize}

Thus, axioms move from \emph{logical requirements} to \emph{programmable verification artifacts}.

\subsection{7. Operational Semantics to Executable Code}

A big-step rule such as:

\[
\frac{
  \rho \vdash e_1 \Downarrow \lambda x.e
  \qquad \rho \vdash e_2 \Downarrow v
  \qquad \rho[x\mapsto v] \vdash e \Downarrow v'
}{
  \rho \vdash e_1\,e_2 \Downarrow v'
}
\]

corresponds to Rust’s function-call mechanism:

\begin{verbatim}
let f = |x| x + 1;
let result = f(41);
\end{verbatim}

But unlike Kleis:

\begin{itemize}
  \item Rust is call-by-value only,
  \item Kleis semantics is defined independently of evaluation strategy,
  \item Mathematically, Kleis supports symbolic evaluation through axioms.
\end{itemize}

Still, the mapping is clean:
semantic application $\Downarrow$ concretizes as a Rust function call.

\subsection{8. Summary: A Bidirectional Bridge}

We summarize the connections:

\begin{center}
\begin{tabular}{l|l}
\textbf{Kleis Formal Concept} & \textbf{Rust Implementation} \\ \hline
Structure & Trait \\
Implements & Impl block \\
ADT constructor & Enum variant \\
Pattern match & \texttt{match} expression \\
Indices \((m,n)\) & Const generics \\
Type abstraction & Type parameters \\
Axioms & Property tests \\
Operational semantics & Rust runtime behavior \\
Exhaustiveness & Rust compiler checks \\
Non-redundancy & Rust warning system \\
\end{tabular}
\end{center}

Thus, the theoretical constructs of Kleis admit a clear and faithful
implementation in Rust, preserving the mathematical structure while
remaining fully executable and efficient.
\end{document}
