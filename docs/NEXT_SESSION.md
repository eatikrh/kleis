# Next Session Notes

**Last Updated:** December 25, 2024

---

## ğŸ¯ CRITICAL: Wire DAP to Real Evaluator with DebugHook

### Problem Statement

The DAP server currently **simulates stepping** by incrementing line numbers. It does NOT:
- Set the `DapDebugHook` on the evaluator
- Run actual evaluation
- Support cross-file debugging (stepping into imported files)

### Current State (What Works)

| Component | Status |
|-----------|--------|
| Parser populates `FullSourceLocation` (file + line + column) | âœ… |
| `ExampleStatement` carries location | âœ… |
| Evaluator calls `on_eval_start()` for every expression | âœ… |
| `DapDebugHook` exists with channel-based communication | âœ… |
| DAP returns stack traces with file paths | âœ… |
| VS Code shows debugger UI | âœ… |
| **DAP wires hook to evaluator** | âŒ NOT DONE |
| **Cross-file debugging** | âŒ NOT DONE |

### Architecture (from `REPL_ENHANCEMENTS.md`)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     kleis server                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚   LSP       â”‚â—„â”€â–ºâ”‚  Shared     â”‚â—„â”€â–ºâ”‚   DAP       â”‚       â”‚
â”‚  â”‚  Handler    â”‚   â”‚  Context    â”‚   â”‚  Handler    â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ - Evaluator â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                    â”‚ - Types     â”‚                          â”‚
â”‚                    â”‚ - Structs   â”‚                          â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Design Points:**
- **RefCell** ensures zero overhead when not debugging (hook is `None`)
- **DapDebugHook** blocks in evaluator thread, communicates via channels
- **DapDebugController** held by DAP server, sends commands, receives events
- **DO NOT change RefCell** - it's there for a purpose!

### Implementation Plan

#### Step 1: Update `DapState` to Hold Controller

```rust
struct DapState {
    // ... existing fields ...
    
    /// Controller for channel-based communication with DebugHook
    controller: Option<DapDebugController>,
    
    /// Handle to evaluation thread
    eval_thread: Option<std::thread::JoinHandle<()>>,
    
    /// Parsed program (for finding example blocks)
    program: Option<Program>,
}
```

#### Step 2: Wire `launch` Handler

1. Parse file with `parse_kleis_program_with_file(source, canonical_path)`
2. Find first `ExampleBlock` to debug
3. Create `DapDebugHook` + `DapDebugController` via `DapDebugHook::new()`
4. Store controller in `DapState`
5. **Don't start evaluation yet** (wait for `configurationDone`)

#### Step 3: Wire `setBreakpoints` Handler

1. Create `Breakpoint { file, line, enabled: true }` for each
2. Store in `DapState.breakpoints`
3. Will be added to hook before evaluation starts

#### Step 4: Wire `configurationDone` Handler

1. Lock evaluator, set hook: `evaluator.set_debug_hook(hook)`
2. Spawn evaluation thread:
   ```rust
   thread::spawn(move || {
       evaluator.eval_example_block(&example);
       // Send terminated when done
   });
   ```
3. Wait for first `StopEvent` from `controller.event_rx`
4. Send `stopped` event to VS Code

#### Step 5: Wire Step Commands

| DAP Command | DebugAction |
|-------------|-------------|
| `next` | `StepOver` |
| `stepIn` | `StepInto` |
| `stepOut` | `StepOut` |
| `continue` | `Continue` |

1. Send via `controller.command_tx.send(action)`
2. Wait for `StopEvent` from `controller.event_rx`
3. Update `current_file` and `current_line` from event
4. Send `stopped` event to VS Code

#### Step 6: Wire `stackTrace` Handler

- Get stack from `StopEvent.stack`
- Store latest stack in `DapState`
- Return frames with `source.path` (absolute paths)

#### Step 7: Wire `variables` Handler

- Get bindings from top stack frame
- Return as DAP variables

#### Step 8: Handle Evaluation Complete

- Add `Terminated` variant to `StopEvent` (or use channel close)
- Send `terminated` event to VS Code

### Why This Works for Cross-File Debugging

The evaluator calls `on_eval_start` with whatever `SourceLocation` the AST has.
When stepping into a function from an imported file, the AST node has that file's path.
The hook receives it, checks breakpoints, sends stop event with the correct file.
**No per-construct hardcoding needed.**

### Files to Modify

| File | Changes |
|------|---------|
| `src/bin/kleis.rs` | Update `DapState`, wire handlers |
| `src/debug.rs` | Add `Terminated` event (if needed) |

### Technical Debt to Address

**1. Consolidate DAP Implementations**
- `src/dap.rs` â€” Library version (marked `#[deprecated]`)
- `src/bin/kleis.rs` â€” Used by `kleis server` (the active one)
- **Action:** Remove `src/dap.rs` after confirming `kleis server` works end-to-end

**2. Review DebugHook Implementations**
We have 3 implementations in `src/debug.rs`:
- `NoOpDebugHook` â€” Zero overhead when not debugging (KEEP)
- `InteractiveDebugHook` â€” For REPL `:debug` command (KEEP for REPL)
- `DapDebugHook` â€” For VS Code DAP integration (KEEP for DAP)

**Action:** After wiring is complete, review if `InteractiveDebugHook` and `DapDebugHook` can share more code or if the separation is justified.

**3. Squash Commits Before Merging**
The `feature/debugger-dap` branch has 63+ incremental commits. Before merging to `main`, squash into logical commits:
- "Add example blocks and assert to grammar (v0.93)"
- "Implement REPL :debug command"  
- "Add DAP infrastructure for VS Code debugging"
- "Add source location tracking to parser"
- "Wire DAP to evaluator with DapDebugHook"

**Command:** `git rebase -i origin/main` then squash/fixup related commits.

### Test Plan

1. Set breakpoint in `examples/debug_main.kleis` on line 8
2. Set breakpoint in `examples/debug_helper.kleis` on line 6
3. Start debugging `debug_main.kleis`
4. Should stop at line 8
5. Step over to line 11 (`let doubled = double(x)`)
6. Step into â†’ should jump to `debug_helper.kleis` line 6
7. Step out â†’ should return to `debug_main.kleis`

### Key Documents

1. **`docs/plans/REPL_ENHANCEMENTS.md`** â€” Master plan, Phase 6 (Debugging)
2. **`docs/plans/EXPRESSION_SPANS.md`** â€” Future: spans on all Expressions
3. **`src/debug.rs`** â€” DebugHook trait and DapDebugHook implementation

---

## ğŸ“‹ Previous: Debugger Status Before Wiring

| Feature | Status |
|---------|--------|
| Launch/attach | âœ… |
| Breakpoints (set) | âœ… |
| Breakpoints (hit) | âš ï¸ Simulated, not real |
| Step in/over/out | âš ï¸ Simulated line increment |
| Continue | âš ï¸ Simulated |
| Stack trace | âœ… Correct file paths |
| Variables | âœ… From evaluator |
| Cross-file | âŒ Not working |

### Files to Review

- `src/bin/kleis.rs` â€” Unified binary (DAP implementation here)
- `src/debug.rs` â€” DebugHook trait and DapDebugHook
- `src/evaluator.rs` â€” Calls debug hooks at key points
- `vscode-kleis/src/extension.ts` â€” VS Code integration

---

## âœ… DONE: Matrix Arithmetic Type Inference Fix

**Problem:** `minus(Matrix, Matrix)` was incorrectly returning `Scalar` type.

**Root Cause:** The hardcoded type hierarchy in `type_inference.rs` (lines 1401-1489) checked for Complex, Rational, Scalar, Int, Nat but **never checked for Matrix**. If nothing matched, it defaulted to Scalar.

**Fix:** Added Matrix handling before the default fallback (lines 1474-1485):
```rust
// Check for Matrix - if either arg is Matrix, return that Matrix type
if let Type::Data { constructor, .. } = &t1 {
    if constructor == "Matrix" {
        return Ok(t1.clone());
    }
}
// ... similar for t2
```

**Future Work (TODO #10):** Per ADR-016, all ~400 lines of hardcoded type logic should move to `stdlib/prelude.kleis` structures and be queried from the registry. Current approach works but isn't self-hosting.

---

## âœ… DONE: Equation Editor `let x =` Template

Added `let_simple` template for 2-argument let bindings:
- Button in "Logic & Set Theory" palette
- Template in `std_template_lib/logic.kleist`
- Implemented for â„, Matrix, and Bool types in `stdlib/prelude.kleis`

---

## ğŸ¯ Equation Editor: Add `let x =` Template

The equation editor needs a template for let bindings:

```
let x = [value] in [body]
```

This allows users to define local variables in the visual editor.

**Files to modify:**
- `static/index.html` - Add button/template
- Template structure: `Let { pattern: "x", value: Placeholder, body: Placeholder }`

---

## ğŸ¯ Equation Editor: Set Type Templates

The Equation Editor should support Set operations with proper type inference.

**Current Status:**
- âœ… REPL can infer Set types: `insert(5, empty_set)` â†’ `Set(Int)`
- âŒ Equation Editor doesn't have Set operation templates

**Needed templates:**
- `in_set(x, S)` - membership test (x âˆˆ S)
- `union(A, B)` - set union (A âˆª B)
- `intersect(A, B)` - intersection (A âˆ© B)
- `difference(A, B)` - difference (A \ B)
- `subset(A, B)` - subset test (A âŠ† B)
- `empty_set` - empty set (âˆ…)
- `singleton(x)` - singleton set ({x})
- `insert(x, S)` - add element

**Files to modify:**
- `static/index.html` - Add buttons to palette
- `std_template_lib/sets.kleist` - Template definitions
- `src/render_editor.rs` - Rendering templates
- `patternfly-editor/` - PatternFly integration

**Leave for future branch:** `feature/equation-editor-sets`

---

## âš ï¸ Program Synthesis: Documented Limitation

**The Dream:** `spec â†’ Z3 â†’ program`

**The Reality:** Z3 cannot synthesize recursive programs from grammar. We tried and documented the failure in `feature/program-synthesis` branch.

**What works:**
- Sketch-based synthesis (human provides template, Z3 fills parameters)
- Bounded verification (sort 2-3 elements)
- LLM proposes, Z3 verifies

**Architecture going forward:**
```
LLM â†’ proposes program â†’ Z3 â†’ verifies properties
                              âœ“ or counterexample
```

See `docs/vision/VERIFIED_SOFTWARE_DREAM.md` (in abandoned branch) for full analysis.

---

## âœ… DONE: LISP Interpreter in Kleis

- âœ… Parser (recursive descent, S-expressions)
- âœ… Evaluator (arithmetic, lambda, let, letrec)  
- âœ… Recursion: `fib(10) = 55`, `fact(5) = 120`
- âœ… Documented in manual appendix
- âœ… `:eval` command for concrete execution
- âŒ `(verify ...)` form â€” **CANCELLED** (program synthesis doesn't work as envisioned)

---

## âœ… DONE: LISP Interpreter Uses stdlib Ordering Operations

The LISP interpreter (`docs/grammar/lisp_parser.kleis`) already:
1. âœ… Imports `stdlib/prelude.kleis`
2. âœ… Uses `le`, `lt`, `gt`, `ge`, `eq` from stdlib `Ordered(T)` structure

No changes needed - this was already working correctly.

---

## âœ… DONE: Type Inference for User-Defined Types

Fixed Dec 21, 2024:
- `:load` now registers data types with TypeChecker
- `:type VNum(42)` â†’ `VNum(Scalar)` âœ…
- `:type SAtom("hello")` â†’ `SAtom("hello")` âœ…

---

## ğŸ“ Key Learnings (Dec 21, 2024)

1. **Kleis is Turing complete** â€” proved by implementing LISP interpreter
2. **Data constructors create concrete objects** â€” not just symbols
3. **Z3 cannot unroll recursion over unbounded ADTs** â€” fundamental limitation
4. **`:eval` enables execution** â€” concrete evaluation in Rust
5. **Verification â‰  Synthesis** â€” Z3 verifies, LLMs synthesize

---

## ğŸš« CANCELLED: Implement `(verify ...)` in LISP Interpreter

**Reason:** The program synthesis vision didn't work. Z3 can't evaluate LISP programs symbolically, so `(verify ...)` can't use Z3 the way we hoped.

### What We Have
- âœ… LISP parser (recursive descent, S-expressions)
- âœ… LISP evaluator (arithmetic, comparisons, lambda, let, letrec)
- âœ… Recursion working: `fib(10) = 55`, `fact(5) = 120`
- âœ… Documented in manual appendix

### What We Need to Design
1. **How does `(verify expr)` call Z3?**
   - Option A: Translate LISP â†’ Kleis expression â†’ Z3
   - Option B: Direct LISP â†’ Z3 (bypass Kleis translation)
   - Option C: Add Z3 access to Rust evaluator as a built-in

2. **What syntax for quantifiers?**
   - `(forall (x) (= (+ x 0) x))` - LISP-style
   - How to specify types for quantified variables?

3. **Return value on failure?**
   - `VBool(false)` vs `VSym("Counterexample: x = 42")`

### Why This Matters
See `docs/vision/VERIFIED_SOFTWARE_VISION.md` â€” this enables:
- Programs with embedded proofs
- Design-by-contract with verification
- The path to "correct by construction" software

### Files to Modify
- `docs/grammar/lisp_parser.kleis` - Add verify form
- `src/evaluator.rs` - May need Z3 integration
- `docs/manual/src/appendix/lisp-interpreter.md` - Update with new code

---

## ğŸ¯ PRIORITY: Bourbaki Compliance Roadmap

Based on capability assessment (Dec 19, 2025), here's what's needed to increase Bourbaki coverage from ~15-20% to higher levels.

### Priority 1: Parser Fixes âœ… COMPLETE (Grammar v0.9)

**Status: DONE** (Dec 22, 2025) - All parser issues resolved!

| Issue | Status | Verified By |
|-------|--------|-------------|
| **âˆ€ inside âˆ§** | âœ… Works | `tests/grammar_v09_test.rs::test_quantifier_in_conjunction` |
| **Function types in quantifiers** | âœ… Works | `tests/grammar_v09_test.rs::test_function_type_with_nested_quantifier` |
| **â†’ as implication** | âœ… Works | Used throughout axiom definitions |
| **Îµ-Î´ limit definition** | âœ… Works | `tests/grammar_v09_test.rs::test_epsilon_delta_limit` |

**Impact:** Full Îµ-Î´ analysis definitions, nested quantifiers, and function types in quantifiers all work.

**Next Steps:** Priorities 2-5 are pure Kleis stdlib code (no more Rust changes needed).

### Priority 2: Set Theory in stdlib (Foundation) ğŸ“š

Set(T) exists but operations need defining:

```kleis
// Add to stdlib/sets.kleis:
structure SetTheory(X) {
    operation (âŠ†) : Set(X) Ã— Set(X) â†’ Bool
    operation (âˆª) : Set(X) Ã— Set(X) â†’ Set(X)
    operation (âˆ©) : Set(X) Ã— Set(X) â†’ Set(X)
    operation ğ’« : Set(X) â†’ Set(Set(X))
    element âˆ… : Set(X)
    
    axiom subset_def: âˆ€(A B : Set(X)). A âŠ† B â†” âˆ€(x : X). in_set(x, A) â†’ in_set(x, B)
    axiom union_def: âˆ€(A B : Set(X), x : X). in_set(x, A âˆª B) â†” in_set(x, A) âˆ¨ in_set(x, B)
    axiom power_set_def: âˆ€(S A : Set(X)). in_set(A, ğ’«(S)) â†” A âŠ† S
}
```

**Impact:** Enables Bourbaki Vol I (Set Theory foundations).

### Priority 3: Topology in stdlib ğŸŒ

Now verified to be expressible:

```kleis
// Add to stdlib/topology.kleis:
structure TopologicalSpace(X) {
    element tau : Set(Set(X))
    
    axiom empty_open: in_set(âˆ…, tau)
    axiom full_open: in_set(X, tau)
    axiom union_closed: âˆ€(U V : Set(X)). in_set(U, tau) âˆ§ in_set(V, tau) â†’ in_set(union(U, V), tau)
    axiom intersection_closed: âˆ€(U V : Set(X)). in_set(U, tau) âˆ§ in_set(V, tau) â†’ in_set(intersect(U, V), tau)
}

structure Continuous(X, Y) over TopologicalSpace(X), TopologicalSpace(Y) {
    operation f : X â†’ Y
    axiom continuity: âˆ€(V : Set(Y)). in_set(V, tau_Y) â†’ in_set(preimage(f, V), tau_X)
}
```

**Impact:** Enables Bourbaki Vol III (Topology).

### Priority 4: Analysis Structures ğŸ“ˆ

```kleis
// Add to stdlib/analysis.kleis:
structure MetricSpace(X) {
    operation d : X Ã— X â†’ â„
    
    axiom non_negative: âˆ€(x y : X). d(x, y) >= 0
    axiom identity: âˆ€(x y : X). d(x, y) = 0 â†” x = y
    axiom symmetry: âˆ€(x y : X). d(x, y) = d(y, x)
    axiom triangle: âˆ€(x y z : X). d(x, z) <= d(x, y) + d(y, z)
}

structure Limit {
    // Requires parser fix for nested quantifiers
    axiom epsilon_delta: âˆ€(L a : â„, epsilon : â„) where epsilon > 0.
        âˆƒ(delta : â„). delta > 0
}
```

**Impact:** Enables Bourbaki Vol IV (Analysis), after parser fixes.

### Priority 5: ZFC Axioms (Long-term) ğŸ›ï¸

```kleis
// Add to stdlib/foundations/zfc.kleis:
structure ZFC {
    // Extensionality
    axiom extensionality: âˆ€(A B : Set). (âˆ€(x). in_set(x, A) â†” in_set(x, B)) â†’ A = B
    
    // Pairing
    axiom pairing: âˆ€(a b). âˆƒ(c : Set). in_set(a, c) âˆ§ in_set(b, c)
    
    // Union
    axiom union: âˆ€(F : Set(Set)). âˆƒ(U : Set). âˆ€(x). in_set(x, U) â†” âˆƒ(A : Set). in_set(A, F) âˆ§ in_set(x, A)
    
    // Power Set
    axiom power: âˆ€(A : Set). âˆƒ(P : Set). âˆ€(B : Set). in_set(B, P) â†” B âŠ† A
    
    // Infinity (requires ordinals)
    // axiom infinity: ...
}
```

**Impact:** Full foundational rigor, but Z3 verification may struggle with some axioms.

---

## âš ï¸ Z3 Capabilities (Clarified Dec 19, 2025)

**Z3 CAN verify (no Kleis implementation needed):**
- Arithmetic: `âˆ€(n : â„•). n + 0 = n` âœ…
- Algebra: `âˆ€(a b : â„). (a-b)*(a+b) = aÂ²-bÂ²` âœ…
- Logic: De Morgan, distributivity âœ…
- Most Bourbaki-style axioms about â„, â„‚, topology âœ…

**Z3 struggles with:**

| Limitation | Example | Status |
|------------|---------|--------|
| **Structural induction** | `length(xs ++ ys) = length(xs) + length(ys)` | May timeout |
| **Limits/Convergence** | Îµ-Î´ proofs with nested quantifiers | May timeout |
| **Type-level arithmetic** | `Vec(m+n)` from `Vec(m) ++ Vec(n)` | Not expressible |

**Key insight:** Bourbaki is mostly continuous math (â„, â„‚, topology) where Z3 works well. Structural induction on lists/trees is rare in Bourbaki.

---

## âœ… Recently Completed

### Operator Overloading (Dec 19, 2025)
- Natural arithmetic: `3 + 4*i = complex(3, 4)` âœ…
- Type-directed lowering working
- 17 integration tests

### Capability Assessment (Dec 19, 2025)
- Verified Kleis capabilities against Bourbaki
- Found more works than expected (~15-20% not 5%)
- Documented real limitations

---

## ğŸ“Š Current Stats

| Metric | Value |
|--------|-------|
| Tests | 663+ passing |
| Commits | 840+ |
| ADRs | 23 |
| Grammar | v0.8 |
| Unique Cloners | 505+ |
| Bourbaki Coverage | ~15-20% (axiomatic) |

---

## ğŸ—ï¸ Architecture Notes

### Operator Overloading Pipeline

```
Parser â†’ Type Inference â†’ Lowering â†’ Z3 Backend
                              â†“
              Rewrites: plus(â„‚, â„‚) â†’ complex_add
                        times(â„, â„‚) â†’ complex_mul(lift, _)
```

### Bourbaki Coverage Path

```
Current: Basic Algebra (Groups, Rings, Fields, Vector Spaces)
    â†“ Priority 1-2 (parser + set theory)
Next: Set Theory foundations
    â†“ Priority 3
Next: Topology (open sets, continuity)
    â†“ Priority 4
Next: Analysis (limits, metric spaces)
    â†“ Priority 5
Long-term: ZFC foundations
    â†“ New backend
Ultimate: Induction, transfinite, category theory
```

---

*See `docs/CAPABILITY_ASSESSMENT.md` for full analysis.*
