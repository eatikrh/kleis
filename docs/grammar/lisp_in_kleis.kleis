// ============================================================================
// LISP IN KLEIS - Generic Grammar-Based Parsing
// ============================================================================
//
// This file demonstrates GENERIC parsing using grammar-as-data.
// The same parsing relation works for ANY grammar, not just LISP.
//
// THE ARCHITECTURE:
//   1. Define grammar rules as data types
//   2. Define a grammar as a collection of rules
//   3. Define a generic AST that any grammar produces
//   4. Define parsing as a RELATION that Z3 can solve
//
// ============================================================================

import "stdlib/prelude.kleis"

// ============================================================================
// PART 1: Grammar Rules as Data
// ============================================================================
//
// A grammar is a collection of rules. Each rule is a pattern.

data Rule =
    Terminal(text: String)           // Exact string match: "("
  | CharClass(chars: String)         // Character class: "[0-9]" 
  | AnyChar                          // Any single character: .
  | NonTerminal(name: String)        // Reference to named rule: <expr>
  | Seq(rules: List(Rule))           // Sequence: A B C
  | Alt(rules: List(Rule))           // Alternation: A | B | C
  | Many(rule: Rule)                 // Zero or more: A*
  | Many1(rule: Rule)                // One or more: A+
  | Optional(rule: Rule)             // Zero or one: A?
  | Not(rule: Rule)                  // Negative lookahead: !A
  | And(rule: Rule)                  // Positive lookahead: &A

// A named rule in a grammar
data NamedRule = NamedRule(name: String, rule: Rule)

// A complete grammar: start rule + all rules
data Grammar = Grammar(
    name: String,                    // Grammar name
    start: String,                   // Starting rule name
    rules: List(NamedRule)           // All rule definitions
)

// ============================================================================
// PART 2: Generic AST (Parse Tree)
// ============================================================================
//
// A generic AST that any grammar can produce.
// The structure mirrors the grammar rules that created it.

data AST =
    Leaf(text: String)               // Terminal match
  | Node(rule: String, children: List(AST))  // Non-terminal with children
  | Empty                            // Optional that didn't match

// ============================================================================
// PART 3: LISP Grammar Definition
// ============================================================================
//
// Now we define LISP's grammar using the Rule data type.
// This is just DATA - not code!

// Character classes for LISP
define lisp_digit : Rule = CharClass("0123456789")
define lisp_alpha : Rule = CharClass("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
define lisp_symbol_char : Rule = CharClass("+-*/<>=!?_")
define lisp_whitespace : Rule = CharClass(" \t\n")

// LISP grammar rules
define lisp_rules : List(NamedRule) = [
    // Whitespace: space | tab | newline
    NamedRule("ws", Many(lisp_whitespace)),
    
    // Number: digit+
    NamedRule("number", Many1(lisp_digit)),
    
    // Symbol: (alpha | symbol_char) (alpha | digit | symbol_char)*
    NamedRule("symbol", Seq([
        Alt([lisp_alpha, lisp_symbol_char]),
        Many(Alt([lisp_alpha, lisp_digit, lisp_symbol_char]))
    ])),
    
    // Atom: number | symbol
    NamedRule("atom", Alt([NonTerminal("number"), NonTerminal("symbol")])),
    
    // List: "(" ws (sexpr ws)* ")"
    NamedRule("list", Seq([
        Terminal("("),
        NonTerminal("ws"),
        Many(Seq([NonTerminal("sexpr"), NonTerminal("ws")])),
        Terminal(")")
    ])),
    
    // S-expression: atom | list
    NamedRule("sexpr", Alt([NonTerminal("atom"), NonTerminal("list")])),
    
    // Program: ws sexpr ws
    NamedRule("program", Seq([
        NonTerminal("ws"),
        NonTerminal("sexpr"),
        NonTerminal("ws")
    ]))
]

// The complete LISP grammar
define lisp_grammar : Grammar = Grammar("LISP", "program", lisp_rules)

// ============================================================================
// PART 4: Parsing Relation (The Key Insight!)
// ============================================================================
//
// Parsing is a RELATION between (grammar, source, ast).
// Z3 can SOLVE for the AST given the grammar and source!

structure ParsingRelation {
    // Core parsing relation: does this source parse to this AST under this grammar?
    operation parses : Grammar × String × AST → Bool
    
    // Get the AST (if any) for a source
    operation parse : Grammar × String → Option(AST)
    
    // Convert AST back to source
    operation unparse : Grammar × AST → String

    // --- Fundamental Axioms ---
    
    // Terminal matches exact string
    axiom terminal_match : ∀(g: Grammar, src: String, text: String).
        parses(g, src, Leaf(text)) ↔ src = text
    
    // Sequence matches concatenated parts
    axiom seq_match : ∀(g: Grammar, src: String, r1: Rule, r2: Rule, a1: AST, a2: AST).
        parses(g, src, Node("seq", [a1, a2])) ↔
        ∃(s1: String, s2: String). 
            src = concat(s1, s2) ∧
            matches_rule(g, r1, s1, a1) ∧
            matches_rule(g, r2, s2, a2)
    
    // Alternation matches one of the options
    axiom alt_match : ∀(g: Grammar, src: String, rules: List(Rule), ast: AST).
        matches_alt(g, rules, src, ast) ↔
        ∃(r: Rule). member(r, rules) ∧ matches_rule(g, r, src, ast)
    
    // Many matches zero or more
    axiom many_match : ∀(g: Grammar, src: String, r: Rule, asts: List(AST)).
        parses(g, src, Node("many", asts)) ↔
        (src = "" ∧ asts = []) ∨
        ∃(s1: String, s2: String, a: AST, rest: List(AST)).
            src = concat(s1, s2) ∧
            matches_rule(g, r, s1, a) ∧
            parses(g, s2, Node("many", rest)) ∧
            asts = Cons(a, rest)
    
    // Parse is deterministic
    axiom parse_deterministic : ∀(g: Grammar, src: String, a1: AST, a2: AST).
        parses(g, src, a1) ∧ parses(g, src, a2) → a1 = a2
    
    // Roundtrip: parse then unparse gives equivalent source
    axiom roundtrip : ∀(g: Grammar, src: String, ast: AST).
        parses(g, src, ast) → parses(g, unparse(g, ast), ast)
}

// Helper: does a rule match a source producing an AST?
define matches_rule(g: Grammar, r: Rule, src: String, ast: AST) : Bool =
    match r {
        Terminal(text) => src = text ∧ ast = Leaf(text)
      | CharClass(chars) => strlen(src) = 1 ∧ contains(chars, src) ∧ ast = Leaf(src)
      | AnyChar => strlen(src) = 1 ∧ ast = Leaf(src)
      | NonTerminal(name) => 
            // Look up the rule and match recursively
            matches_named_rule(g, name, src, ast)
      | Seq(rules) => matches_seq(g, rules, src, ast)
      | Alt(rules) => matches_alt(g, rules, src, ast)
      | Many(rule) => matches_many(g, rule, src, ast)
      | Many1(rule) => matches_many1(g, rule, src, ast)
      | Optional(rule) => matches_optional(g, rule, src, ast)
      | Not(rule) => ¬∃(a: AST). matches_rule(g, rule, src, a)
      | And(rule) => ∃(a: AST). matches_rule(g, rule, src, a)
    }

// Look up and match a named rule
define matches_named_rule(g: Grammar, name: String, src: String, ast: AST) : Bool =
    match g {
        Grammar(_, _, rules) => 
            ∃(nr: NamedRule). 
                member(nr, rules) ∧ 
                match nr { NamedRule(n, r) => n = name ∧ matches_rule(g, r, src, ast) }
    }

// Match sequence of rules
define matches_seq(g: Grammar, rules: List(Rule), src: String, ast: AST) : Bool =
    match rules {
        Nil => src = "" ∧ ast = Empty
      | Cons(r, Nil) => matches_rule(g, r, src, ast)
      | Cons(r, rest) => 
            ∃(s1: String, s2: String, a1: AST, a2: AST).
                src = concat(s1, s2) ∧
                matches_rule(g, r, s1, a1) ∧
                matches_seq(g, rest, s2, a2) ∧
                ast = Node("seq", [a1, a2])
    }

// Match alternation
define matches_alt(g: Grammar, rules: List(Rule), src: String, ast: AST) : Bool =
    match rules {
        Nil => false
      | Cons(r, rest) => 
            matches_rule(g, r, src, ast) ∨ matches_alt(g, rest, src, ast)
    }

// Match zero or more
define matches_many(g: Grammar, rule: Rule, src: String, ast: AST) : Bool =
    match ast {
        Node(name, children) => 
            name = "many" ∧
            (src = "" ∧ children = []) ∨
            ∃(s1: String, s2: String, a: AST, rest: List(AST)).
                strlen(s1) > 0 ∧  // Ensure progress
                src = concat(s1, s2) ∧
                matches_rule(g, rule, s1, a) ∧
                matches_many(g, rule, s2, Node("many", rest)) ∧
                children = Cons(a, rest)
      | _ => false
    }

// Match one or more
define matches_many1(g: Grammar, rule: Rule, src: String, ast: AST) : Bool =
    match ast {
        Node(name, children) => 
            name = "many1" ∧
            length(children) >= 1 ∧
            ∃(s1: String, s2: String, a: AST, rest: List(AST)).
                src = concat(s1, s2) ∧
                matches_rule(g, rule, s1, a) ∧
                matches_many(g, rule, s2, Node("many", rest)) ∧
                children = Cons(a, rest)
      | _ => false
    }

// Match optional
define matches_optional(g: Grammar, rule: Rule, src: String, ast: AST) : Bool =
    (src = "" ∧ ast = Empty) ∨ matches_rule(g, rule, src, ast)

// ============================================================================
// PART 5: LispProgram Type (Using the Generic Parser)
// ============================================================================

data LispProgram = 
    Source(code: String)             // The source code
  | Parsed(code: String, ast: AST)   // Source + parsed AST
  | SExpr(ast: AST)                  // Just the AST

// Parse a LISP program using the generic parser
define parse_lisp(src: String) : Option(AST) =
    parse(lisp_grammar, src)

// Build a Parsed LispProgram
define lisp_from_source(src: String) : LispProgram =
    match parse_lisp(src) {
        Some(ast) => Parsed(src, ast)
      | None => Source(src)  // Keep source even if parse fails
    }

// ============================================================================
// PART 6: Z3 Queries - Find AST Given Source
// ============================================================================
//
// The magic: ask Z3 to FIND the AST that parses from a source!

// Example queries (to run in REPL):
//
// :sat ∃(ast: AST). parses(lisp_grammar, "(+ 2 3)", ast)
// 
// Z3 finds: ast = Node("list", [Leaf("("), Node("seq", [...]), Leaf(")")])
//
// :sat ∃(ast: AST). parses(lisp_grammar, "42", ast)
//
// Z3 finds: ast = Node("number", [Leaf("4"), Leaf("2")])

// ============================================================================
// PART 7: Example LISP Programs
// ============================================================================

define add_source : String = "(+ 2 3)"
define nested_source : String = "(* (+ 2 3) 4)"
define factorial_source : String = "(define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))"
define fibonacci_source : String = "(define (fib n) (if (<= n 1) n (+ (fib (- n 1)) (fib (- n 2)))))"

define add_program : LispProgram = Source(add_source)
define nested_program : LispProgram = Source(nested_source)
define factorial_program : LispProgram = Source(factorial_source)
define fibonacci_program : LispProgram = Source(fibonacci_source)

// ============================================================================
// PART 8: Program Analysis (String-Based)
// ============================================================================

// Is this a define form?
define is_define(p: LispProgram) : Bool =
    match p {
        Source(code) => hasPrefix(code, "(define")
      | Parsed(code, _) => hasPrefix(code, "(define")
      | SExpr(_) => false
    }

// Is this an arithmetic expression?
define is_arithmetic(p: LispProgram) : Bool =
    match p {
        Source(code) => 
            hasPrefix(code, "(+") ∨ hasPrefix(code, "(-") ∨ 
            hasPrefix(code, "(*") ∨ hasPrefix(code, "(/")
      | _ => false
    }

// Does this program use recursion?
define uses_recursion(p: LispProgram) : Bool =
    match p {
        Source(code) => 
            (contains(code, "fact") ∧ contains(code, "(define (fact")) ∨
            (contains(code, "fib") ∧ contains(code, "(define (fib"))
      | Parsed(code, _) => uses_recursion(Source(code))
      | _ => false
    }

// Count parentheses depth
define paren_depth(p: LispProgram) : ℕ =
    match p {
        Source(code) => 
            let without_open = replace(code, "(", "") in
            strlen(code) - strlen(without_open)
      | _ => 0
    }

// Check balanced parentheses
define has_balanced_parens(src: String) : Bool =
    let without_open = replace(src, "(", "") in
    let without_close = replace(src, ")", "") in
    let open_count = strlen(src) - strlen(without_open) in
    let close_count = strlen(src) - strlen(without_close) in
    open_count = close_count

// ============================================================================
// PART 9: Verified Properties
// ============================================================================

structure LispGrammarProperties {
    // Our programs have balanced parens
    axiom add_balanced : has_balanced_parens(add_source)
    axiom nested_balanced : has_balanced_parens(nested_source)
    axiom factorial_balanced : has_balanced_parens(factorial_source)
    axiom fibonacci_balanced : has_balanced_parens(fibonacci_source)
    
    // Factorial and Fibonacci use recursion
    axiom factorial_recursive : uses_recursion(factorial_program)
    axiom fibonacci_recursive : uses_recursion(fibonacci_program)
    
    // Add program is arithmetic
    axiom add_is_arithmetic : is_arithmetic(add_program)
    
    // Define programs are defines
    axiom factorial_is_define : is_define(factorial_program)
    axiom fibonacci_is_define : is_define(fibonacci_program)
}

structure LispSyntaxErrors {
    // Unbalanced programs detected
    axiom detect_unbalanced : ¬has_balanced_parens("(+ 2 3")
    axiom detect_extra_close : ¬has_balanced_parens("(+ 2 3))")
    
    // Empty is balanced (vacuously)
    axiom empty_balanced : has_balanced_parens("")
}

// ============================================================================
// PART 10: Other Grammars (Showing Genericity!)
// ============================================================================
//
// The same Rule/Grammar/AST types work for ANY language!

// Simple arithmetic grammar
define arith_grammar : Grammar = Grammar("Arithmetic", "expr", [
    NamedRule("digit", CharClass("0123456789")),
    NamedRule("number", Many1(NonTerminal("digit"))),
    NamedRule("op", Alt([Terminal("+"), Terminal("-"), Terminal("*"), Terminal("/")])),
    NamedRule("expr", Alt([
        NonTerminal("number"),
        Seq([Terminal("("), NonTerminal("expr"), NonTerminal("op"), NonTerminal("expr"), Terminal(")")])
    ]))
])

// JSON-like grammar (subset)
define json_grammar : Grammar = Grammar("JSON", "value", [
    NamedRule("ws", Many(CharClass(" \t\n"))),
    NamedRule("digit", CharClass("0123456789")),
    NamedRule("number", Many1(NonTerminal("digit"))),
    NamedRule("string", Seq([Terminal("\""), Many(Not(Terminal("\""))), Terminal("\"")])),
    NamedRule("null", Terminal("null")),
    NamedRule("bool", Alt([Terminal("true"), Terminal("false")])),
    NamedRule("array", Seq([
        Terminal("["), NonTerminal("ws"),
        Optional(Seq([NonTerminal("value"), Many(Seq([Terminal(","), NonTerminal("ws"), NonTerminal("value")]))])),
        NonTerminal("ws"), Terminal("]")
    ])),
    NamedRule("value", Alt([
        NonTerminal("null"), NonTerminal("bool"), NonTerminal("number"), 
        NonTerminal("string"), NonTerminal("array")
    ]))
])

// ============================================================================
// CONCLUSION
// ============================================================================
//
// This file demonstrates GENERIC parsing:
//
//   1. Grammar rules are DATA (Rule, NamedRule, Grammar types)
//   2. The SAME parsing relation works for ANY grammar
//   3. Z3 can SOLVE for the AST given grammar + source
//   4. LISP, Arithmetic, JSON all use the same mechanism
//
// To parse LISP:
//   :sat ∃(ast: AST). parses(lisp_grammar, "(+ 2 3)", ast)
//
// To parse arithmetic:
//   :sat ∃(ast: AST). parses(arith_grammar, "(1+2)", ast)
//
// The grammar IS data. Parsing IS a relation. Z3 IS the solver.
// ============================================================================
