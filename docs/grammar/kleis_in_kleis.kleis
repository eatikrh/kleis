// ============================================================================
// KLEIS GRAMMAR IN KLEIS - Self-Describing Language Specification
// ============================================================================
//
// This file defines Kleis's grammar using Kleis itself.
// Combined with Kleis's string operations and Z3's string theory,
// this enables SYNTAX VERIFICATION of Kleis programs from within Kleis!
//
// This is a form of META-CIRCULARITY: the language describing itself.
//
// See: ADR-003 (Self-Hosting Strategy)
// ============================================================================

// ============================================================================
// PART 1: Abstract Syntax Tree (AST) Types
// ============================================================================

// --- Expressions ---

data Expression =
    EVariable(name: String)
  | ENumber(value: ℝ)
  | EString(value: String)
  | EBool(value: Bool)
  | EOperation(name: String, args: List(Expression))
  | ELambda(params: List(Param), body: Expression)
  | ELet(pattern: Pattern, value: Expression, body: Expression)
  | EMatch(scrutinee: Expression, cases: List(MatchCase))
  | EIf(cond: Expression, then_expr: Expression, else_expr: Expression)
  | EForAll(vars: List(VarDecl), body: Expression)
  | EExists(vars: List(VarDecl), body: Expression)
  | EList(elements: List(Expression))

data Param = Param(name: String, type_ann: Option(Type))

data VarDecl = VarDecl(name: String, type_ann: Option(Type))

data MatchCase = MatchCase(pattern: Pattern, guard: Option(Expression), body: Expression)

// --- Patterns ---

data Pattern =
    PWildcard
  | PVariable(name: String)
  | PConstructor(name: String, args: List(Pattern))
  | PConstant(expr: Expression)
  | PAs(inner: Pattern, alias: String)
  | PTuple(elements: List(Pattern))

// --- Types ---

data Type =
    TPrimitive(name: String)
  | TVariable(name: String)
  | TParametric(name: String, args: List(Type))
  | TFunction(domain: Type, codomain: Type)
  | TProduct(left: Type, right: Type)

// --- Declarations ---

data Declaration =
    DImport(path: String)
  | DData(name: String, params: List(String), variants: List(DataVariant))
  | DStructure(name: String, params: List(TypeParam), extends: Option(String), members: List(StructMember))
  | DImplements(name: String, args: List(Type), members: List(ImplMember))
  | DDefine(name: String, params: List(Param), return_type: Option(Type), body: Expression)
  | DTypeAlias(name: String, target: Type)

data TypeParam = TypeParam(name: String, kind: Option(String))

data DataVariant = DataVariant(name: String, fields: List(DataField))

data DataField = 
    NamedField(name: String, field_type: Type)
  | PositionalField(field_type: Type)

data StructMember =
    SMOperation(name: String, signature: Type)
  | SMElement(name: String, elem_type: Type)
  | SMAxiom(name: String, proposition: Expression)
  | SMFunction(def: Declaration)

data ImplMember =
    IMElement(name: String, value: Expression)
  | IMOperation(name: String, value: Expression)

// --- Program ---

data Program = Program(declarations: List(Declaration))


// ============================================================================
// PART 2: Lexical Predicates (String → Bool)
// ============================================================================
//
// These predicates use Kleis string operations to recognize tokens.
// Z3's string theory can verify properties about these!

// Is the string a valid identifier?
define is_identifier(s : String) : Bool =
    strlen(s) > 0 ∧ 
    is_alpha_or_underscore(charAt(s, 0)) ∧
    all_alphanum_or_underscore(s, 1)

// Helper: first char must be letter or underscore
define is_alpha_or_underscore(c : String) : Bool =
    isAlpha(c) ∨ c = "_"

// Helper: remaining chars alphanumeric or underscore
define all_alphanum_or_underscore(s : String, start : ℕ) : Bool =
    if start >= strlen(s) then true
    else isAlphaNum(charAt(s, start)) ∨ charAt(s, start) = "_"
         ∧ all_alphanum_or_underscore(s, start + 1)

// Is the string a valid number?
define is_number(s : String) : Bool =
    isDigits(s) ∨ is_decimal(s) ∨ is_scientific(s)

// Is decimal: digits.digits
define is_decimal(s : String) : Bool =
    let dot_pos = indexOf(s, ".") in
    dot_pos > 0 ∧
    isDigits(substr(s, 0, dot_pos)) ∧
    isDigits(substr(s, dot_pos + 1, strlen(s) - dot_pos - 1))

// Is scientific: decimal e [+-]? digits
define is_scientific(s : String) : Bool =
    let e_pos = indexOf(s, "e") in
    if e_pos < 0 then
        let E_pos = indexOf(s, "E") in
        E_pos > 0 ∧ is_decimal(substr(s, 0, E_pos)) ∧ isDigits(substr(s, E_pos + 1, strlen(s) - E_pos - 1))
    else
        e_pos > 0 ∧ is_decimal(substr(s, 0, e_pos)) ∧ isDigits(substr(s, e_pos + 1, strlen(s) - e_pos - 1))

// Is the string a reserved keyword?
define is_keyword(s : String) : Bool =
    s = "if" ∨ s = "then" ∨ s = "else" ∨
    s = "let" ∨ s = "in" ∨
    s = "match" ∨
    s = "lambda" ∨
    s = "define" ∨
    s = "data" ∨ s = "type" ∨
    s = "structure" ∨ s = "implements" ∨
    s = "operation" ∨ s = "element" ∨ s = "axiom" ∨
    s = "forall" ∨ s = "exists" ∨
    s = "and" ∨ s = "or" ∨ s = "not" ∨
    s = "import" ∨ s = "extends" ∨ s = "over" ∨ s = "as"

// Is the string a primitive type name?
define is_primitive_type(s : String) : Bool =
    s = "ℝ" ∨ s = "Real" ∨
    s = "ℂ" ∨ s = "Complex" ∨
    s = "ℤ" ∨ s = "Int" ∨ s = "Integer" ∨
    s = "ℕ" ∨ s = "Nat" ∨
    s = "ℚ" ∨ s = "Rational" ∨
    s = "Bool" ∨ s = "String" ∨ s = "Unit"


// ============================================================================
// PART 3: Syntactic Predicates (Structural Validation)
// ============================================================================

// A program is valid if all declarations are valid
define is_valid_program(p : Program) : Bool =
    match p {
        Program(decls) => all_valid_declarations(decls)
    }

// All declarations must be valid
define all_valid_declarations(decls : List(Declaration)) : Bool =
    match decls {
        Nil => true
      | Cons(d, rest) => is_valid_declaration(d) ∧ all_valid_declarations(rest)
    }

// A declaration is valid based on its kind
define is_valid_declaration(d : Declaration) : Bool =
    match d {
        DImport(path) => strlen(path) > 0
      | DData(name, params, variants) => 
            is_identifier(name) ∧ 
            all_identifiers(params) ∧
            length(variants) > 0
      | DDefine(name, params, ret, body) =>
            is_identifier(name) ∧
            is_valid_expression(body)
      | DTypeAlias(name, target) =>
            is_identifier(name) ∧
            is_valid_type(target)
      | _ => true  // Other cases simplified
    }

// An expression is valid based on its structure
define is_valid_expression(e : Expression) : Bool =
    match e {
        EVariable(name) => is_identifier(name) ∧ ¬is_keyword(name)
      | ENumber(v) => true
      | EString(s) => true
      | EBool(b) => true
      | EOperation(name, args) => 
            is_identifier(name) ∧ 
            all_valid_expressions(args)
      | ELambda(params, body) =>
            length(params) > 0 ∧
            is_valid_expression(body)
      | ELet(pat, val, body) =>
            is_valid_pattern(pat) ∧
            is_valid_expression(val) ∧
            is_valid_expression(body)
      | EIf(cond, then_e, else_e) =>
            is_valid_expression(cond) ∧
            is_valid_expression(then_e) ∧
            is_valid_expression(else_e)
      | EForAll(vars, body) =>
            length(vars) > 0 ∧
            is_valid_expression(body)
      | EExists(vars, body) =>
            length(vars) > 0 ∧
            is_valid_expression(body)
      | _ => true
    }

// A type is valid
define is_valid_type(t : Type) : Bool =
    match t {
        TPrimitive(name) => is_primitive_type(name)
      | TVariable(name) => is_identifier(name)
      | TParametric(name, args) => 
            is_identifier(name) ∧ 
            all_valid_types(args)
      | TFunction(dom, cod) =>
            is_valid_type(dom) ∧ is_valid_type(cod)
      | TProduct(l, r) =>
            is_valid_type(l) ∧ is_valid_type(r)
    }

// A pattern is valid
define is_valid_pattern(p : Pattern) : Bool =
    match p {
        PWildcard => true
      | PVariable(name) => is_identifier(name)
      | PConstructor(name, args) => 
            is_identifier(name) ∧ 
            all_valid_patterns(args)
      | PAs(inner, alias) => 
            is_valid_pattern(inner) ∧ 
            is_identifier(alias)
      | PTuple(elems) => all_valid_patterns(elems)
      | PConstant(_) => true
    }

// Helper: all strings are identifiers
define all_identifiers(ss : List(String)) : Bool =
    match ss {
        Nil => true
      | Cons(s, rest) => is_identifier(s) ∧ all_identifiers(rest)
    }

// Helper: all expressions valid
define all_valid_expressions(es : List(Expression)) : Bool =
    match es {
        Nil => true
      | Cons(e, rest) => is_valid_expression(e) ∧ all_valid_expressions(rest)
    }

// Helper: all types valid
define all_valid_types(ts : List(Type)) : Bool =
    match ts {
        Nil => true
      | Cons(t, rest) => is_valid_type(t) ∧ all_valid_types(rest)
    }

// Helper: all patterns valid
define all_valid_patterns(ps : List(Pattern)) : Bool =
    match ps {
        Nil => true
      | Cons(p, rest) => is_valid_pattern(p) ∧ all_valid_patterns(rest)
    }


// ============================================================================
// PART 4: Grammar Properties (Axioms verifiable by Z3!)
// ============================================================================

structure KleisGrammarProperties {
    // Keywords cannot be identifiers
    axiom keywords_not_identifiers : ∀(s : String).
        is_keyword(s) → ¬is_identifier(s) ∨ is_keyword(s)
    
    // Empty string is not a valid identifier
    axiom empty_not_identifier : ¬is_identifier("")
    
    // "define" is a keyword
    axiom define_is_keyword : is_keyword("define")
    
    // "ℝ" is a primitive type
    axiom real_is_primitive : is_primitive_type("ℝ")
    
    // Wildcard pattern is always valid
    axiom wildcard_valid : is_valid_pattern(PWildcard)
    
    // A let binding requires valid pattern, value, and body
    axiom let_validity : ∀(p : Pattern, v : Expression, b : Expression).
        is_valid_expression(ELet(p, v, b)) ↔ 
        (is_valid_pattern(p) ∧ is_valid_expression(v) ∧ is_valid_expression(b))
}


// ============================================================================
// PART 5: Example Usage
// ============================================================================
//
// These show how to construct Kleis AST values representing Kleis code!

// Example: The expression "x + 1"
define example_plus = EOperation("plus", Cons(EVariable("x"), Cons(ENumber(1), Nil)))

// Example: The expression "λ x . x * x"
define example_square = ELambda(
    Cons(Param("x", None), Nil),
    EOperation("times", Cons(EVariable("x"), Cons(EVariable("x"), Nil)))
)

// Example: The type "ℝ → ℝ"
define example_func_type = TFunction(TPrimitive("ℝ"), TPrimitive("ℝ"))

// Example: The pattern "Some(x)"
define example_pattern = PConstructor("Some", Cons(PVariable("x"), Nil))

// Example: A simple define declaration
define example_define = DDefine(
    "square",
    Cons(Param("x", Some(TPrimitive("ℝ"))), Nil),
    Some(TPrimitive("ℝ")),
    EOperation("times", Cons(EVariable("x"), Cons(EVariable("x"), Nil)))
)


// ============================================================================
// CONCLUSION
// ============================================================================
//
// This file demonstrates that Kleis can describe its own grammar!
//
// Key capabilities enabled:
//   1. AST manipulation in Kleis
//   2. Syntax validation predicates
//   3. Z3-verifiable grammar properties
//   4. Meta-programming foundations
//
// Future possibilities:
//   - Parser combinators in Kleis
//   - Macro expansion
//   - Custom DSL embedding
//   - Verified compiler passes
//
// This is the foundation of TRUE self-hosting!
// ============================================================================

