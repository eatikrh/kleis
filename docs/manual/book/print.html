<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Kleis Manual</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-4MJCXLSP8V"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-4MJCXLSP8V');
        </script>
        

        <meta name="description" content="The official guide to the Kleis mathematical specification language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-71ffb63a.svg">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-21bb5f9a.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-309fc3c5.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Kleis Manual</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/eatikrh/kleis" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="the-kleis-manual"><a class="header" href="#the-kleis-manual">The Kleis Manual</a></h1>
<blockquote>
<p><em>‚ÄúMathematics is the language with which God has written the universe.‚Äù</em> ‚Äî Galileo Galilei</p>
</blockquote>
<p>Welcome to <strong>The Kleis Manual</strong>, the official guide to the Kleis mathematical specification language.</p>
<h2 id="what-is-kleis"><a class="header" href="#what-is-kleis">What is Kleis?</a></h2>
<p>Kleis is a <strong>structure-oriented mathematical formalization language</strong> with Z3 verification and LAPACK numerics.</p>
<blockquote>
<p><strong>Philosophy:</strong> <em>Structures ‚Äî the foundation of everything.</em></p>
</blockquote>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Metric</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td>Grammar</td><td>Fully implemented</td></tr>
<tr><td>Tests</td><td>1,762 Rust unit tests</td></tr>
<tr><td>Examples</td><td>71 Kleis files across 15+ domains</td></tr>
<tr><td>Built-in Functions</td><td>100+ (including LAPACK numerical operations)</td></tr>
</tbody>
</table>
</div>
<h3 id="core-capabilities"><a class="header" href="#core-capabilities">Core Capabilities</a></h3>
<ul>
<li>üèóÔ∏è <strong>Structure-first design</strong> ‚Äî define mathematical objects by their axioms, not just their data</li>
<li>‚úÖ <strong>Z3 verification</strong> ‚Äî prove properties with SMT solving</li>
<li>üî¢ <strong>LAPACK numerics</strong> ‚Äî eigenvalues, SVD, matrix exponentials, and more</li>
<li>üìê <strong>Symbolic mathematics</strong> ‚Äî work with expressions, not just numbers</li>
<li>üî¨ <strong>Scientific computing</strong> ‚Äî differential geometry, tensor calculus, control systems</li>
<li>üîÑ <strong>Turing complete</strong> ‚Äî a full programming language, not just notation</li>
</ul>
<blockquote>
<p><strong>Computational Universality:</strong> Kleis is Turing complete. This was demonstrated by implementing a complete LISP interpreter in Kleis (see <a href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter</a>). The combination of algebraic data types, pattern matching, and recursion enables arbitrary computation.</p>
</blockquote>
<h3 id="domain-coverage"><a class="header" href="#domain-coverage">Domain Coverage</a></h3>
<p>Kleis has been used to formalize:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Domain</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><strong>Mathematics</strong></td><td>Differential forms, tensor algebra, complex analysis, number theory</td></tr>
<tr><td><strong>Physics</strong></td><td>Dimensional analysis, quantum entanglement, orbital mechanics</td></tr>
<tr><td><strong>Control Systems</strong></td><td>LQG controllers, eigenvalue analysis, state-space models</td></tr>
<tr><td><strong>Ontology</strong></td><td>Projected Ontology Theory, spacetime types</td></tr>
<tr><td><strong>Protocols</strong></td><td>IPv4 packets, IP routing, stop-and-wait ARQ</td></tr>
<tr><td><strong>Authorization</strong></td><td>OAuth2 scopes, Google Zanzibar</td></tr>
<tr><td><strong>Formal Methods</strong></td><td>Petri nets, mutex verification</td></tr>
<tr><td><strong>Games</strong></td><td>Chess, Contract Bridge, Sudoku</td></tr>
</tbody>
</table>
</div>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is This For?</a></h2>
<p>Kleis is for anyone who thinks in terms of <strong>structures and axioms</strong>:</p>
<ul>
<li><strong>Mathematicians</strong> ‚Äî formalize theorems, verify properties, explore number theory</li>
<li><strong>Physicists</strong> ‚Äî tensor algebra, differential geometry, dimensional analysis</li>
<li><strong>Engineers</strong> ‚Äî control systems, protocol specifications, verified designs</li>
<li><strong>Security architects</strong> ‚Äî authorization policies (Zanzibar, OAuth2)</li>
<li><strong>Researchers</strong> ‚Äî formalize new theories with Z3 verification</li>
<li><strong>Functional programmers</strong> ‚Äî if you enjoy Haskell or ML, you‚Äôll feel at home</li>
</ul>
<p>If you‚Äôve ever wished you could <em>prove</em> your specifications are consistent, Kleis is for you.</p>
<h2 id="why-kleis-now"><a class="header" href="#why-kleis-now">Why Kleis Now?</a></h2>
<p>Modern systems demand formal verification:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Challenge</th><th>How Kleis Helps</th></tr>
</thead>
<tbody>
<tr><td><strong>Security &amp; Compliance</strong></td><td>Machine-checkable proofs for audit trails across sectors</td></tr>
<tr><td><strong>Complex Systems</strong></td><td>Verify rules across IoT, enterprise, and distributed systems</td></tr>
<tr><td><strong>AI-Generated Content</strong></td><td>Verify AI outputs against formal specifications</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><em>Universal verification</em> ‚Äî same rigor for mathematics, business rules, and beyond.</p>
</blockquote>
<h2 id="how-to-read-this-guide"><a class="header" href="#how-to-read-this-guide">How to Read This Guide</a></h2>
<p>Each chapter builds on the previous ones. We start with the basics:</p>
<ol>
<li><strong>Starting Out</strong> ‚Äî expressions, operators, basic syntax</li>
<li><strong>Types</strong> ‚Äî naming and composing structures</li>
<li><strong>Functions</strong> ‚Äî operations with laws</li>
</ol>
<p>Then we explore core concepts:</p>
<ol start="4">
<li><strong>Algebraic Types</strong> ‚Äî data definitions and constructors</li>
<li><strong>Pattern Matching</strong> ‚Äî elegant case analysis</li>
<li><strong>Let Bindings</strong> ‚Äî local definitions</li>
<li><strong>Quantifiers and Logic</strong> ‚Äî ‚àÄ, ‚àÉ, and logical operators</li>
<li><strong>Conditionals</strong> ‚Äî if-then-else</li>
</ol>
<p>And advanced features:</p>
<ol start="9">
<li><strong>Structures</strong> ‚Äî the foundation of everything</li>
<li><strong>Implements</strong> ‚Äî structure implementations</li>
<li><strong>Z3 Verification</strong> ‚Äî proving things with SMT</li>
</ol>
<blockquote>
<p><strong>Philosophy:</strong> In Kleis, <em>structures</em> define what things <strong>are</strong> through their operations and axioms. Types are names for structures. A metric tensor isn‚Äôt ‚Äúa 2D array‚Äù ‚Äî it‚Äôs ‚Äúsomething satisfying metric axioms.‚Äù</p>
</blockquote>
<h2 id="a-taste-of-kleis"><a class="header" href="#a-taste-of-kleis">A Taste of Kleis</a></h2>
<p>Here‚Äôs what Kleis looks like:</p>
<pre><code class="language-kleis">// Define a function
define square(x) = x * x

// With type annotation
define double(x : ‚Ñù) : ‚Ñù = x + x

// Create a structure with axioms
structure Group(G) {
    operation e : G                    // identity
    operation inv : G ‚Üí G              // inverse
    operation mul : G √ó G ‚Üí G          // multiplication
    
    axiom left_identity : ‚àÄ x : G . mul(e, x) = x
    axiom left_inverse : ‚àÄ x : G . mul(inv(x), x) = e
}

// Numerical computation
example "eigenvalues" {
    let A = Matrix([[1, 2], [3, 4]]) in
    out(eigenvalues(A))  // Pretty-printed output
}
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready? Let‚Äôs dive in!</p>
<p>‚Üí <a href="#starting-out">Start with Chapter 1: Starting Out</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starting-out"><a class="header" href="#starting-out">Starting Out</a></h1>
<h2 id="your-first-kleis-expression"><a class="header" href="#your-first-kleis-expression">Your First Kleis Expression</a></h2>
<p>The simplest things in Kleis are <strong>expressions</strong>. An expression is anything that has a value:</p>
<pre><code class="language-kleis">define answer = 42              // A number
define pi_approx = 3.14159      // A decimal
define sum(x, y) = x + y        // An arithmetic expression
define angle_sin(Œ∏) = sin(Œ∏)    // A function call
</code></pre>
<h2 id="the-repl"><a class="header" href="#the-repl">The REPL</a></h2>
<p>The easiest way to experiment with Kleis is the <strong>REPL</strong> (Read-Eval-Print Loop):</p>
<pre><code class="language-bash">$ cargo run --bin repl
üßÆ Kleis REPL v0.1.0
   Type :help for commands, :quit to exit

Œª&gt; 2 + 2
2 + 2

Œª&gt;  let x = 5 in x * x
times(5, 5)
</code></pre>
<h2 id="basic-arithmetic"><a class="header" href="#basic-arithmetic">Basic Arithmetic</a></h2>
<p>Kleis supports the usual arithmetic operations:</p>
<pre><code class="language-kleis">define add_example = 2 + 3       // Addition: 5
define sub_example = 10 - 4      // Subtraction: 6
define mul_example = 3 * 7       // Multiplication: 21
define div_example = 15 / 3      // Division: 5
define pow_example = 2 ^ 10      // Exponentiation: 1024
</code></pre>
<h2 id="variables-and-definitions"><a class="header" href="#variables-and-definitions">Variables and Definitions</a></h2>
<p>Use <code>define</code> to create named values:</p>
<pre><code class="language-kleis">define pi = 3.14159
define e = 2.71828
define golden_ratio = (1 + sqrt(5)) / 2
</code></pre>
<p>Functions are defined similarly:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define area_circle(r) = pi * r^2
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Kleis uses C-style comments:</p>
<pre><code class="language-kleis">// This is a single-line comment
define x = 42  // Inline comment

/* 
   Multi-line comments
   use slash-star syntax
*/
</code></pre>
<h2 id="unicode-support"><a class="header" href="#unicode-support">Unicode Support</a></h2>
<p>Kleis embraces mathematical notation with full Unicode support:</p>
<pre><code class="language-kleis example">// Greek letters
define Œ± = 0.5
define Œ≤ = 1.0
define Œ∏ = œÄ / 4

// Mathematical symbols in axioms
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x           // Universal quantifier
axiom positive_exists : ‚àÉ(y : ‚Ñù). y &gt; 0       // Existential quantifier
</code></pre>
<p>You can use ASCII alternatives too:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII Alternative</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Now that you can write basic expressions, let‚Äôs learn about the type system!</p>
<p>‚Üí <a href="#types-and-values">Next: Types and Values</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types-and-values"><a class="header" href="#types-and-values">Types and Values</a></h1>
<h2 id="why-types-matter"><a class="header" href="#why-types-matter">Why Types Matter</a></h2>
<p>Types are the foundation of Kleis. Every expression has a type, and the type system catches errors before they become problems.</p>
<pre><code class="language-kleis">define answer = 42                // 42 is an integer
define pi_val = 3.14              // 3.14 is a real number
define flag = True                // True is a boolean
</code></pre>
<h2 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h2>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>ASCII</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Natural</td><td><code>‚Ñï</code></td><td><code>Nat</code></td><td><code>N</code></td><td><code>0</code>, <code>42</code>, <code>100</code></td></tr>
<tr><td>Integer</td><td><code>‚Ñ§</code></td><td><code>Int</code></td><td><code>Z</code></td><td><code>-5</code>, <code>0</code>, <code>17</code></td></tr>
<tr><td>Rational</td><td><code>‚Ñö</code></td><td><code>Rational</code></td><td><code>Q</code></td><td><code>rational(1, 2)</code>, <code>rational(3, 4)</code></td></tr>
<tr><td>Real</td><td><code>‚Ñù</code></td><td><code>Real</code> or <code>Scalar</code></td><td><code>R</code></td><td><code>3.14</code>, <code>-2.5</code>, <code>‚àö2</code></td></tr>
<tr><td>Complex</td><td><code>‚ÑÇ</code></td><td><code>Complex</code></td><td><code>C</code></td><td><code>3 + 4i</code>, <code>i</code></td></tr>
</tbody>
</table>
</div>
<h3 id="other-basic-types"><a class="header" href="#other-basic-types">Other Basic Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td>Boolean</td><td><code>ùîπ</code></td><td><code>Bool</code></td><td><code>True</code>, <code>False</code></td></tr>
<tr><td>String</td><td>‚Äî</td><td><code>String</code></td><td><code>"hello"</code>, <code>"world"</code></td></tr>
<tr><td>Unit</td><td>‚Äî</td><td><code>Unit</code></td><td><code>()</code></td></tr>
</tbody>
</table>
</div>
<h3 id="parameterized-primitive-types"><a class="header" href="#parameterized-primitive-types">Parameterized Primitive Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Bit-Vector</td><td><code>BitVec(n)</code></td><td>n-bit binary vector (e.g., <code>BitVec(8)</code>, <code>BitVec(32)</code>)</td></tr>
<tr><td>Set</td><td><code>Set(T)</code></td><td>Set of elements of type T (e.g., <code>Set(‚Ñ§)</code>, <code>Set(‚Ñù)</code>)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Boolean values
define flag = True
define not_flag = False

// Boolean in quantified expressions (inside structures)
structure BoolExamples {
    axiom reflexive_unicode : ‚àÄ(p : ùîπ). p = p
    axiom reflexive_full    : ‚àÄ(q : Bool). q = q
}
</code></pre>
<h3 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h3>
<p>The <code>Unit</code> type represents ‚Äúno meaningful value‚Äù ‚Äî like <code>void</code> in C or <code>()</code> in Rust/Haskell. It has exactly one value: <code>()</code>.</p>
<p><strong>When to use Unit:</strong></p>
<ol>
<li><strong>Result types that can fail but return nothing on success:</strong></li>
</ol>
<pre><code class="language-kleis">// A validation that succeeds with () or fails with an error message
data ValidationResult = Ok(Unit) | Err(String)

define validate_positive(x : ‚Ñù) : ValidationResult =
    if x &gt; 0 then Ok(()) else Err("must be positive")
</code></pre>
<ol start="2">
<li><strong>Optional values where presence matters, not content:</strong></li>
</ol>
<pre><code class="language-kleis">// Option type - Some(value) or None
data Option(T) = Some(T) | None

// A flag that's either set or not (no associated value)
define flag_set : Option(Unit) = Some(())
define flag_unset : Option(Unit) = None
</code></pre>
<ol start="3">
<li><strong>Proof terms with no computational content:</strong></li>
</ol>
<pre><code class="language-kleis">// A theorem that x = x (the proof itself carries no data)
structure Reflexivity {
    axiom refl : ‚àÄ(x : ‚Ñù). x = x
}
// The "witness" of this axiom would have type Unit
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>You can explicitly annotate types with <code>:</code>:</p>
<pre><code class="language-kleis">// Variable annotation
define typed_let = let x : ‚Ñù = 3.14 in x * 2

// Function parameter and return types
define f(x : ‚Ñù) : ‚Ñù = x * x

// Expression-level annotation (ascription)
define sum_typed(a, b) = (a + b) : ‚Ñù
</code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Type aliases give a new name to an existing type, making your code more readable and self-documenting.</p>
<h3 id="the-type-keyword"><a class="header" href="#the-type-keyword">The <code>type</code> Keyword</a></h3>
<pre><code class="language-kleis">type Probability = ‚Ñù
type Temperature = ‚Ñù
type Velocity = ‚Ñù
</code></pre>
<p>Now you can use <code>Probability</code> instead of <code>‚Ñù</code> to make your intent clear:</p>
<pre><code class="language-kleis">define coin_flip : Probability = 0.5
define boiling_point : Temperature = 100.0
</code></pre>
<h3 id="why-use-type-aliases"><a class="header" href="#why-use-type-aliases">Why Use Type Aliases?</a></h3>
<ol>
<li><strong>Readability</strong> ‚Äî <code>Probability</code> is clearer than <code>‚Ñù</code></li>
<li><strong>Documentation</strong> ‚Äî the type name explains what the value represents</li>
<li><strong>Refactoring</strong> ‚Äî change the underlying type in one place</li>
</ol>
<h3 id="function-type-aliases"><a class="header" href="#function-type-aliases">Function Type Aliases</a></h3>
<p>Type aliases are especially useful for complex function types:</p>
<pre><code class="language-kleis">type RealFunction = ‚Ñù ‚Üí ‚Ñù
type BinaryOp = ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù
type Predicate = ‚Ñù ‚Üí Bool
</code></pre>
<p>Now instead of writing <code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code>, you can write:</p>
<pre><code class="language-kleis">type Integrator = RealFunction ‚Üí ‚Ñù
</code></pre>
<h3 id="parameterized-type-aliases"><a class="header" href="#parameterized-type-aliases">Parameterized Type Aliases</a></h3>
<p>Type aliases can have parameters:</p>
<pre><code class="language-kleis">type Pair(T) = T ‚Üí T ‚Üí T
type Endomorphism(T) = T ‚Üí T
</code></pre>
<h3 id="aliases-for-data-types-and-structures"><a class="header" href="#aliases-for-data-types-and-structures">Aliases for Data Types and Structures</a></h3>
<p>Type aliases work with user-defined types too:</p>
<pre><code class="language-kleis">// Alias for a data type (sum type)
data Option(T) = Some(value : T) | None
type MaybeInt = Option(‚Ñ§)
type MaybeString = Option(String)

// Alias for a structure (product type)
structure Point {
    x : ‚Ñù
    y : ‚Ñù
}
type Coordinate = Point

// Alias for nested ADTs
data Result(T, E) = Ok(value : T) | Err(error : E)
type IntResult = Result(‚Ñ§, String)
</code></pre>
<blockquote>
<p><strong>Note:</strong> Type aliases create a synonym ‚Äî <code>Probability</code> and <code>‚Ñù</code> are interchangeable. They don‚Äôt create a distinct new type.</p>
</blockquote>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Functions have types too! The notation <code>A ‚Üí B</code> means ‚Äúa function from A to B‚Äù:</p>
<pre><code class="language-kleis">// square takes a Real and returns a Real
define square(x : ‚Ñù) : ‚Ñù = x * x
// Type: ‚Ñù ‚Üí ‚Ñù

// add takes two Reals and returns a Real
define add(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = x + y
// Type: ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù (or equivalently: ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù)
</code></pre>
<h3 id="higher-order-function-types"><a class="header" href="#higher-order-function-types">Higher-Order Function Types</a></h3>
<p>Functions can take other functions as arguments or return functions. These are called <strong>higher-order functions</strong>:</p>
<pre><code class="language-kleis">// A function that takes a function as an argument
define apply_twice(f : ‚Ñù ‚Üí ‚Ñù, x : ‚Ñù) : ‚Ñù = f(f(x))
// Type: (‚Ñù ‚Üí ‚Ñù) √ó ‚Ñù ‚Üí ‚Ñù

// A function that returns a function
define make_adder(n : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù = ???
// Type: ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)
</code></pre>
<p>The parentheses matter! Compare:</p>
<ul>
<li><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code> ‚Äî takes a function, returns a number</li>
<li><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code> ‚Äî takes a number, returns a function</li>
<li><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code> ‚Äî curried function (associates right: <code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code>)</li>
</ul>
<h3 id="function-type-examples"><a class="header" href="#function-type-examples">Function Type Examples</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ñù ‚Üí ‚Ñù</code></td><td>Function from real to real</td></tr>
<tr><td><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code></td><td>Curried binary function</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code></td><td>Takes a function, returns a value (e.g., definite integral)</td></tr>
<tr><td><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Returns a function (function factory)</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Function transformer (e.g., derivative operator)</td></tr>
</tbody>
</table>
</div>
<h2 id="set-types"><a class="header" href="#set-types">Set Types</a></h2>
<p>Kleis provides a built-in <code>Set(T)</code> type backed by Z3‚Äôs native set theory. Sets are unordered collections of unique elements:</p>
<pre><code class="language-kleis">// Declare a set type
define S : Set(‚Ñ§)

// Set operations (see stdlib/sets.kleis for full structure)
in_set(x, S)              // Membership: x ‚àà S ‚Üí Bool
union(A, B)               // Union: A ‚à™ B ‚Üí Set(T)
intersect(A, B)           // Intersection: A ‚à© B ‚Üí Set(T)
difference(A, B)          // Difference: A \ B ‚Üí Set(T)
complement(A)             // Complement: ·∂úA ‚Üí Set(T)
subset(A, B)              // Subset test: A ‚äÜ B ‚Üí Bool
insert(x, S)              // Add element: S ‚à™ {x} ‚Üí Set(T)
remove(x, S)              // Remove element: S \ {x} ‚Üí Set(T)
singleton(x)              // Singleton set: {x} ‚Üí Set(T)
empty_set                 // Empty set: ‚àÖ
</code></pre>
<h3 id="set-theory-axioms"><a class="header" href="#set-theory-axioms">Set Theory Axioms</a></h3>
<p>Sets come with a complete axiomatization (see <code>stdlib/sets.kleis</code>):</p>
<pre><code class="language-kleis">structure SetTheory(T) {
    // Core operations
    operation in_set : T ‚Üí Set(T) ‚Üí Bool
    operation union : Set(T) ‚Üí Set(T) ‚Üí Set(T)
    operation intersect : Set(T) ‚Üí Set(T) ‚Üí Set(T)
    element empty_set : Set(T)
    
    // Extensionality: sets are equal iff they have the same elements
    axiom extensionality: ‚àÄ(A B : Set(T)). 
        (‚àÄ(x : T). in_set(x, A) ‚Üî in_set(x, B)) ‚Üí A = B
    
    // Union definition
    axiom union_def: ‚àÄ(A B : Set(T), x : T). 
        in_set(x, union(A, B)) ‚Üî (in_set(x, A) ‚à® in_set(x, B))
    
    // De Morgan's laws
    axiom de_morgan_union: ‚àÄ(A B : Set(T)). 
        complement(union(A, B)) = intersect(complement(A), complement(B))
}
</code></pre>
<h3 id="using-sets-in-verification"><a class="header" href="#using-sets-in-verification">Using Sets in Verification</a></h3>
<p>Sets are particularly useful for specifying properties involving collections:</p>
<pre><code class="language-kleis">structure MetricSpace(X) {
    operation d : X ‚Üí X ‚Üí ‚Ñù
    operation ball : X ‚Üí ‚Ñù ‚Üí Set(X)
    
    // Open ball definition
    axiom ball_def: ‚àÄ(center : X, radius : ‚Ñù, x : X).
        in_set(x, ball(center, radius)) ‚Üî d(x, center) &lt; radius
}
</code></pre>
<h2 id="parametric-types"><a class="header" href="#parametric-types">Parametric Types</a></h2>
<p>Types can have parameters:</p>
<pre><code class="language-kleis">// Parametric type examples:
List(‚Ñ§)           // List of integers
Matrix(3, 3, ‚Ñù)   // 3√ó3 matrix of reals
Vector(4)         // 4-dimensional vector
Set(‚Ñù)            // Set of real numbers
</code></pre>
<h2 id="dimension-expressions"><a class="header" href="#dimension-expressions">Dimension Expressions</a></h2>
<p>When working with parameterized types like <code>Matrix(m, n, ‚Ñù)</code>, the dimension parameters are not just simple numbers ‚Äî they can be <strong>dimension expressions</strong>. This enables type-safe operations where dimensions depend on each other.</p>
<h3 id="supported-dimension-expressions"><a class="header" href="#supported-dimension-expressions">Supported Dimension Expressions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Operators</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Arithmetic</td><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></td><td><code>n+1</code>, <code>2*n</code>, <code>n/2</code></td></tr>
<tr><td>Power</td><td><code>^</code></td><td><code>n^2</code>, <code>2^k</code></td></tr>
<tr><td>Grouping</td><td><code>( )</code></td><td><code>(n+1)*2</code></td></tr>
<tr><td>Functions</td><td><code>min</code>, <code>max</code></td><td><code>min(m, n)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="why-dimension-expressions-matter"><a class="header" href="#why-dimension-expressions-matter">Why Dimension Expressions Matter</a></h3>
<p>Consider the <strong>realification functor</strong> from control theory, which embeds a complex n√ón matrix into a real 2n√ó2n matrix:</p>
<pre><code class="language-kleis">// Complex matrix represented as (real_part, imag_part)
type ComplexMatrix(m: Nat, n: Nat) = (Matrix(m, n, ‚Ñù), Matrix(m, n, ‚Ñù))

// Realification: embed C^(n√ón) into R^(2n√ó2n)
structure Realification(n: Nat) {
    operation realify : ComplexMatrix(n, n) ‚Üí Matrix(2*n, 2*n, ‚Ñù)
    operation complexify : Matrix(2*n, 2*n, ‚Ñù) ‚Üí ComplexMatrix(n, n)
}
</code></pre>
<p>The <code>2*n</code> dimension expression captures the <strong>invariant</strong> that the output dimension is always twice the input dimension.</p>
<h3 id="how-dimension-unification-works"><a class="header" href="#how-dimension-unification-works">How Dimension Unification Works</a></h3>
<p>When Kleis type-checks your code, it must verify that dimension expressions match. This uses a built-in <strong>dimension solver</strong> that can handle common arithmetic constraints.</p>
<h4 id="what-the-solver-can-unify"><a class="header" href="#what-the-solver-can-unify">What the Solver Can Unify</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression 1</th><th>Expression 2</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>2*n</code></td><td><code>2*n</code></td><td>‚úÖ Structurally equal</td></tr>
<tr><td><code>2*n</code></td><td><code>6</code></td><td>‚úÖ Solved: <code>n = 3</code></td></tr>
<tr><td><code>n + 1</code></td><td><code>5</code></td><td>‚úÖ Solved: <code>n = 4</code></td></tr>
<tr><td><code>n^2</code></td><td><code>9</code></td><td>‚úÖ Solved: <code>n = 3</code></td></tr>
<tr><td><code>2^k</code></td><td><code>8</code></td><td>‚úÖ Solved: <code>k = 3</code></td></tr>
</tbody>
</table>
</div>
<h4 id="what-the-solver-rejects"><a class="header" href="#what-the-solver-rejects">What the Solver Rejects</a></h4>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression 1</th><th>Expression 2</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>2*n</code></td><td><code>n</code></td><td>‚ùå Different structure (unless <code>n = 0</code>)</td></tr>
<tr><td><code>n + 1</code></td><td><code>n</code></td><td>‚ùå Different structure</td></tr>
<tr><td><code>n*m</code></td><td><code>6</code></td><td>‚ö†Ô∏è Underdetermined</td></tr>
</tbody>
</table>
</div>
<h3 id="examples-in-practice"><a class="header" href="#examples-in-practice">Examples in Practice</a></h3>
<p><strong>Matrix multiplication</strong> requires matching inner dimensions:</p>
<pre><code class="language-kleis">// Matrix(m, n) √ó Matrix(n, p) ‚Üí Matrix(m, p)
structure MatrixMultiply(m: Nat, n: Nat, p: Nat) {
    operation matmul : Matrix(m, n, ‚Ñù) ‚Üí Matrix(n, p, ‚Ñù) ‚Üí Matrix(m, p, ‚Ñù)
}
</code></pre>
<p>The <code>n</code> dimension must match on both sides ‚Äî the solver verifies this.</p>
<p><strong>SVD decomposition</strong> produces matrices with <code>min(m, n)</code> dimensions:</p>
<pre><code class="language-kleis example">// Illustrative ‚Äî tuple return types in structures are aspirational
structure SVD(m: Nat, n: Nat) {
    // A = U * Œ£ * V·µÄ where Œ£ is min(m,n) √ó min(m,n)
    operation svd : Matrix(m, n, ‚Ñù) ‚Üí 
        (Matrix(m, min(m,n), ‚Ñù), Matrix(min(m,n), min(m,n), ‚Ñù), Matrix(min(m,n), n, ‚Ñù))
}
</code></pre>
<h3 id="simplification"><a class="header" href="#simplification">Simplification</a></h3>
<p>The dimension solver simplifies expressions before comparing them:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Simplified</th></tr>
</thead>
<tbody>
<tr><td><code>0 + n</code></td><td><code>n</code></td></tr>
<tr><td><code>1 * n</code></td><td><code>n</code></td></tr>
<tr><td><code>n^1</code></td><td><code>n</code></td></tr>
<tr><td><code>n^0</code></td><td><code>1</code></td></tr>
<tr><td><code>2 * 3</code></td><td><code>6</code></td></tr>
</tbody>
</table>
</div>
<p>This means <code>Matrix(1*n, n+0, ‚Ñù)</code> correctly unifies with <code>Matrix(n, n, ‚Ñù)</code>.</p>
<h3 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h3>
<p>The dimension solver is <strong>deliberately bounded</strong>:</p>
<ul>
<li>It handles practical cases (linear arithmetic, powers, min/max)</li>
<li>It fails clearly on complex constraints it cannot solve</li>
<li>It doesn‚Äôt require external dependencies (no SMT solver needed for type checking)</li>
</ul>
<p>If you need more advanced constraint solving, use the <code>:verify</code> command with Z3 at the value level.</p>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Kleis often infers types automatically:</p>
<pre><code class="language-kleis">define double(x) = x + x
// Kleis infers: double : ‚Ñù ‚Üí ‚Ñù (or more general)

define square_five = let y = 5 in y * y
// Kleis infers: y : ‚Ñ§
</code></pre>
<p>But explicit types make code clearer and catch errors earlier!</p>
<h2 id="the-type-hierarchy"><a class="header" href="#the-type-hierarchy">The Type Hierarchy</a></h2>
<pre><code>                    Any
         /     |      \       \
     Scalar  String  Collection  Set(T)
     /    \              |
    ‚ÑÇ    Bool          List
    |                 /    \
    ‚Ñù            Vector   Matrix
    |
    ‚Ñö
    |
    ‚Ñ§
    |
    ‚Ñï
</code></pre>
<p>Note: <code>‚Ñï ‚äÇ ‚Ñ§ ‚äÇ ‚Ñö ‚äÇ ‚Ñù ‚äÇ ‚ÑÇ</code> (naturals ‚äÇ integers ‚äÇ rationals ‚äÇ reals ‚äÇ complex)</p>
<p><strong>Set(T)</strong> is parameterized by its element type. <code>Set(‚Ñ§)</code> is a set of integers, <code>Set(‚Ñù)</code> is a set of reals, etc.</p>
<h2 id="type-promotion-embedding"><a class="header" href="#type-promotion-embedding">Type Promotion (Embedding)</a></h2>
<p>When you mix numeric types in an expression, Kleis automatically <strong>promotes</strong> the smaller type to the larger one. This is called <strong>type embedding</strong>, not subtyping.</p>
<h3 id="embedding-vs-subtyping"><a class="header" href="#embedding-vs-subtyping">Embedding vs Subtyping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Meaning</th><th>Kleis Approach</th></tr>
</thead>
<tbody>
<tr><td><strong>Subtyping</strong></td><td><code>S</code> can be used anywhere <code>T</code> is expected, with identical behavior</td><td>Not used</td></tr>
<tr><td><strong>Embedding</strong></td><td><code>S</code> can be converted to <code>T</code> via an explicit <code>lift</code> function</td><td>‚úì Used</td></tr>
</tbody>
</table>
</div>
<p>The difference is subtle but important:</p>
<pre><code class="language-kleis">// Embedding: Integer 3 is lifted to Rational before the operation
rational(1, 2) + 3
// Becomes: rational_add(rational(1, 2), lift(3))
// Result: rational(7, 2) ‚Äî exact!
</code></pre>
<h3 id="how-promotion-works"><a class="header" href="#how-promotion-works">How Promotion Works</a></h3>
<ol>
<li><strong>Type inference</strong> determines the result type (the ‚Äúcommon supertype‚Äù)</li>
<li><strong>Lifting</strong> converts arguments to the target type</li>
<li><strong>Operation</strong> executes at the target type</li>
</ol>
<pre><code>Int + Rational
    ‚Üì find common supertype
  Rational
    ‚Üì lift Int to Rational
  lift(Int) + Rational
    ‚Üì execute operation
  rational_add(Rational, Rational)
    ‚Üì
  Rational result
</code></pre>
<h3 id="the-promotes-structure"><a class="header" href="#the-promotes-structure">The <code>Promotes</code> Structure</a></h3>
<p>Type promotion is defined by the <code>Promotes(From, To)</code> structure:</p>
<pre><code class="language-kleis">structure Promotes(From, To) {
  operation lift : From ‚Üí To
}

// Built-in promotions
implements Promotes(‚Ñï, ‚Ñ§) { operation lift = builtin_nat_to_int }
implements Promotes(‚Ñ§, ‚Ñö) { operation lift = builtin_int_to_rational }
implements Promotes(‚Ñö, ‚Ñù) { operation lift = builtin_rational_to_real }
implements Promotes(‚Ñù, ‚ÑÇ) { operation lift = builtin_real_to_complex }
</code></pre>
<h3 id="defining-your-own-promotions"><a class="header" href="#defining-your-own-promotions">Defining Your Own Promotions</a></h3>
<p>You can define promotions for your own types. Unlike built-in types (which use <code>builtin_*</code> functions), <strong>you must write the conversion function yourself</strong>:</p>
<pre><code class="language-kleis">data Percentage = Pct(value: ‚Ñù)

// Step 1: Define the conversion function
define pct_to_real(p: Percentage) : ‚Ñù =
  match p { Pct(v) =&gt; divide(v, 100) }

// Step 2: Register the promotion, referencing YOUR function
implements Promotes(Percentage, ‚Ñù) {
  operation lift = pct_to_real   // References the function above
}
</code></pre>
<p>Now this works in the REPL:</p>
<pre><code>Œª&gt; :eval 0.5 + pct_to_real(Pct(25))
‚úÖ 0.75
</code></pre>
<p><strong>Key difference from built-in types:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Lift Implementation</th></tr>
</thead>
<tbody>
<tr><td>Built-in (<code>‚Ñ§ ‚Üí ‚Ñö</code>)</td><td><code>operation lift = builtin_int_to_rational</code> (provided by Kleis)</td></tr>
<tr><td>User-defined</td><td><code>operation lift = your_function</code> (you must define it)</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Important</strong>: For concrete execution (<code>:eval</code>), you must provide an actual <code>define</code> for the lift function. Without it:</p>
<ul>
<li><code>:verify</code> (symbolic) ‚Äî Works (Z3 treats <code>lift</code> as uninterpreted)</li>
<li><code>:eval</code> (concrete) ‚Äî <strong>Fails</strong> (‚Äúfunction not found‚Äù)</li>
</ul>
</blockquote>
<h3 id="precision-considerations"><a class="header" href="#precision-considerations">Precision Considerations</a></h3>
<p><strong>Warning</strong>: Promotion can lose precision!</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Promotion</th><th>Precision</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ñï ‚Üí ‚Ñ§</code></td><td>‚úì Exact (integers contain all naturals)</td></tr>
<tr><td><code>‚Ñ§ ‚Üí ‚Ñö</code></td><td>‚úì Exact (rationals contain all integers)</td></tr>
<tr><td><code>‚Ñö ‚Üí ‚Ñù</code></td><td>‚ö†Ô∏è <strong>May lose precision</strong> (floating-point approximation)</td></tr>
<tr><td><code>‚Ñù ‚Üí ‚ÑÇ</code></td><td>‚úì Exact (complex with zero imaginary part)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Exact in Rational
define third : ‚Ñö = rational(1, 3)  // Exactly 1/3

// Approximate in Real (floating-point)
define approx : ‚Ñù = 1.0 / 3.0      // 0.333333...

// If you promote:
define promoted = third + 0.5      // third lifted to ‚Ñù, loses exactness!
</code></pre>
<p><strong>Recommendation</strong>: When precision matters, be explicit about types:</p>
<pre><code class="language-kleis">// Keep it in Rational for exact arithmetic
define exact_sum : ‚Ñö = rational(1, 3) + rational(1, 6)  // Exactly 1/2

// Or use type annotations to prevent accidental promotion
define result(x : ‚Ñö, y : ‚Ñö) : ‚Ñö = x + y
</code></pre>
<h3 id="no-lsp-violations"><a class="header" href="#no-lsp-violations">No LSP Violations</a></h3>
<p>Because Kleis uses embedding (not subtyping), operations are always resolved at the <strong>target type</strong> after lifting. This means:</p>
<ul>
<li><code>Int + Int</code> uses integer addition</li>
<li><code>Int + Rational</code> lifts the Int first, then uses rational addition</li>
<li>You never accidentally get integer truncation when you expected rational division</li>
</ul>
<pre><code class="language-kleis">5 / 3           // Integer division ‚Üí 1 (if both are Int)
rational(5, 1) / rational(3, 1)   // Rational division ‚Üí 5/3 (exact)
</code></pre>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What‚Äôs Next?</a></h2>
<p>Types are the foundation. Now let‚Äôs see how to define functions!</p>
<p>‚Üí <a href="#functions">Next: Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>Functions are defined with <code>define</code>:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define add(x, y) = x + y
</code></pre>
<h2 id="functions-with-type-annotations"><a class="header" href="#functions-with-type-annotations">Functions with Type Annotations</a></h2>
<p>For clarity and safety, add type annotations:</p>
<pre><code class="language-kleis">define square(x : ‚Ñù) : ‚Ñù = x * x

define distance(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = sqrt(x^2 + y^2)

define normalize(v : Vector(3)) : Vector(3) = v / magnitude(v)
</code></pre>
<h2 id="multi-parameter-functions"><a class="header" href="#multi-parameter-functions">Multi-Parameter Functions</a></h2>
<p>Functions can take multiple parameters:</p>
<pre><code class="language-kleis">define add(x, y) = x + y
define volume_box(l, w, h) = l * w * h
define dot_product(a, b, c, x, y, z) = a*x + b*y + c*z
</code></pre>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Functions can call themselves:</p>
<pre><code class="language-kleis">define factorial(n : ‚Ñï) : ‚Ñï =
    if n = 0 then 1
    else n * factorial(n - 1)

define fibonacci(n : ‚Ñï) : ‚Ñï =
    if n ‚â§ 1 then n
    else fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<h2 id="built-in-mathematical-functions"><a class="header" href="#built-in-mathematical-functions">Built-in Mathematical Functions</a></h2>
<p>Kleis includes standard mathematical functions:</p>
<h3 id="trigonometric"><a class="header" href="#trigonometric">Trigonometric</a></h3>
<pre><code class="language-kleis">sin(x)      cos(x)      tan(x)
asin(x)     acos(x)     atan(x)
sinh(x)     cosh(x)     tanh(x)
</code></pre>
<h3 id="exponential-and-logarithmic"><a class="header" href="#exponential-and-logarithmic">Exponential and Logarithmic</a></h3>
<pre><code class="language-kleis">exp(x)      // e^x
ln(x)       // natural log
log(x)      // base-10 log
log(b, x)   // log base b of x
</code></pre>
<h3 id="other"><a class="header" href="#other">Other</a></h3>
<pre><code class="language-kleis">sqrt(x)     // square root
abs(x)      // absolute value
floor(x)    // round down
ceil(x)     // round up
min(x, y)   // minimum
max(x, y)   // maximum
</code></pre>
<h2 id="lambda-expressions-anonymous-functions"><a class="header" href="#lambda-expressions-anonymous-functions">Lambda Expressions (Anonymous Functions)</a></h2>
<p>Lambda expressions allow you to create anonymous functions inline:</p>
<pre><code class="language-kleis">define square_lambda = Œª x . x * x
define increment = lambda x . x + 1
define add_lambda = Œª x . Œª y . x + y
define square_typed = Œª (x : ‚Ñù) . x^2
define curried_add = Œª x . Œª y . x + y
</code></pre>
<p>Lambda expressions are first-class values - you can pass them to functions:</p>
<pre><code class="language-kleis">// Pass lambda to higher-order function
define doubled_list = map(Œª x . x * 2, [1, 2, 3])

// Or define inline
define result = apply(Œª x . x + 1, 5)
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Functions can take functions as arguments:</p>
<pre><code class="language-kleis">// Apply a function twice
define apply_twice(f, x) = f(f(x))

// Example usage:
define inc(x) = x + 1
define result = apply_twice(inc, 5)   // Result: 7
</code></pre>
<h2 id="partial-application-and-currying"><a class="header" href="#partial-application-and-currying">Partial Application and Currying</a></h2>
<p>With lambda expressions, you can create curried functions:</p>
<pre><code class="language-kleis">// Curried addition
define add = Œª x . Œª y . x + y

// Partial application creates specialized functions
define add5 = add(5)           // Œª y . 5 + y
define eight = add5(3)         // Result: 8
</code></pre>
<h2 id="named-arguments-v096"><a class="header" href="#named-arguments-v096">Named Arguments (v0.96)</a></h2>
<p>For plotting and numeric functions, Kleis supports named arguments (keyword arguments):</p>
<pre><code class="language-kleis">// Named arguments come after positional arguments
diagram(
    bar(xs, ys, offset = -0.2, width = 0.4, label = "Data"),
    plot(x, y, color = "blue", yerr = errors),
    width = 10,
    height = 7,
    title = "My Chart"
)
</code></pre>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>Named arguments use <code>=</code> (not <code>==</code>) and must come after all positional arguments:</p>
<pre><code class="language-kleis">// ‚úÖ Valid: positional first, then named
f(a, b, x = 1, y = 2)

// ‚úÖ Valid: all named
f(x = 1, y = 2)

// ‚ùå Invalid: positional after named
f(x = 1, a, b)      // Error!
</code></pre>
<h3 id="parser-transformation"><a class="header" href="#parser-transformation">Parser Transformation</a></h3>
<p>Named arguments are <strong>syntactic sugar</strong>. The parser transforms them into a <code>record</code> expression:</p>
<pre><code class="language-kleis">// You write:
bar(xs, ys, offset = -0.2, width = 0.4)

// Parser produces:
bar(xs, ys, record(
    field("offset", -0.2),
    field("width", 0.4)
))
</code></pre>
<h3 id="limitations-numeric-only"><a class="header" href="#limitations-numeric-only">Limitations: Numeric Only</a></h3>
<blockquote>
<p><strong>Important:</strong> Named arguments are designed for <strong>concrete numeric computation</strong> (plotting, configuration). They cannot be used in:</p>
</blockquote>
<ul>
<li><code>structure</code> definitions</li>
<li><code>axiom</code> declarations</li>
<li><code>implements</code> blocks</li>
<li>Z3 verification proofs</li>
</ul>
<pre><code class="language-kleis">// ‚ùå Does NOT work in axioms
structure Bad {
    axiom wrong: f(x = 1)  // ERROR: named args not for axioms
}

// ‚úÖ Works in plotting/computation
let xs = [0, 1, 2, 3]
let ys = [10, 20, 15, 25]
diagram(bar(xs, ys, color = "blue"))
</code></pre>
<h3 id="why-this-design"><a class="header" href="#why-this-design">Why This Design?</a></h3>
<p>Named arguments are opaque to the type system:</p>
<ol>
<li><strong>Type inference</strong> sees <code>record</code> as an opaque type</li>
<li><strong>Unification</strong> doesn‚Äôt look inside records</li>
<li><strong>Z3</strong> never receives record expressions</li>
<li><strong>Built-in functions</strong> consume records at runtime</li>
</ol>
<p>This ensures named arguments don‚Äôt interfere with symbolic mathematics while providing convenient syntax for plotting and configuration.</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What‚Äôs Next?</a></h2>
<p>Learn about algebraic data types for structured data!</p>
<p>‚Üí <a href="#algebraic-data-types">Next: Algebraic Types</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<h2 id="what-are-adts"><a class="header" href="#what-are-adts">What Are ADTs?</a></h2>
<p>Algebraic Data Types (ADTs) let you define custom data structures by combining simpler types. There are two main kinds:</p>
<ul>
<li><strong>Product types</strong> ‚Äî ‚Äúthis AND that‚Äù (records, tuples)</li>
<li><strong>Sum types</strong> ‚Äî ‚Äúthis OR that‚Äù (variants, enums)</li>
</ul>
<h2 id="product-types"><a class="header" href="#product-types">Product Types</a></h2>
<p>A product type combines multiple values:</p>
<pre><code class="language-kleis">// A point has an x AND a y
structure Point {
    x : ‚Ñù
    y : ‚Ñù
}

// A person has a name AND an age
structure Person {
    name : String
    age : ‚Ñï
}
</code></pre>
<h2 id="sum-types-variants"><a class="header" href="#sum-types-variants">Sum Types (Variants)</a></h2>
<p>A sum type represents alternatives ‚Äî a value that can be <em>one of</em> several different forms.</p>
<h3 id="the-data-keyword"><a class="header" href="#the-data-keyword">The <code>data</code> Keyword</a></h3>
<p>In Kleis, you define sum types using the <code>data</code> keyword:</p>
<pre><code class="language-kleis">data TypeName = Constructor1 | Constructor2 | Constructor3
</code></pre>
<p><strong>Syntax breakdown:</strong></p>
<ul>
<li><code>data</code> ‚Äî keyword that introduces a new type definition</li>
<li><code>TypeName</code> ‚Äî the name of your new type (starts with uppercase)</li>
<li><code>=</code> ‚Äî separates the type name from its constructors</li>
<li><code>Constructor1</code>, <code>Constructor2</code>, etc. ‚Äî the possible variants (each starts with uppercase)</li>
<li><code>|</code> ‚Äî read as ‚Äúor‚Äù ‚Äî separates the alternatives</li>
</ul>
<h3 id="constructors-with-data"><a class="header" href="#constructors-with-data">Constructors with Data</a></h3>
<p>Constructors can carry data (fields):</p>
<pre><code class="language-kleis">data TypeName = Constructor1(field1 : Type1) | Constructor2(field2 : Type2, field3 : Type3)
</code></pre>
<p>Each constructor acts like a function that creates a value of the type.</p>
<h3 id="parameterized-types-generics"><a class="header" href="#parameterized-types-generics">Parameterized Types (Generics)</a></h3>
<p>Types can have parameters, making them work with any type:</p>
<pre><code class="language-kleis">data Option(T) = Some(value : T) | None
</code></pre>
<p>Here <code>T</code> is a <em>type parameter</em>. You can use <code>Option(‚Ñï)</code> for optional natural numbers, <code>Option(String)</code> for optional strings, etc. The type is <em>generic</em> ‚Äî it works for any <code>T</code>.</p>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-kleis">// A shape is a Circle OR a Rectangle OR a Triangle
data Shape = Circle(radius : ‚Ñù) | Rectangle(width : ‚Ñù, height : ‚Ñù) | Triangle(a : ‚Ñù, b : ‚Ñù, c : ‚Ñù)

// An optional value is Some(value) OR None
data Option(T) = Some(value : T) | None

// A result is Ok(value) OR Err(message)
data Result(T, E) = Ok(value : T) | Err(error : E)
</code></pre>
<h2 id="pattern-matching-with-adts"><a class="header" href="#pattern-matching-with-adts">Pattern Matching with ADTs</a></h2>
<p>ADTs shine with pattern matching:</p>
<pre><code class="language-kleis">define area(shape) =
    match shape {
        Circle(r) =&gt; œÄ * r^2
        Rectangle(w, h) =&gt; w * h
        Triangle(a, b, c) =&gt; 
            let s = (a + b + c) / 2 in
            sqrt(s * (s-a) * (s-b) * (s-c))
    }
</code></pre>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<p>Types can refer to themselves:</p>
<pre><code class="language-kleis">// A list is either empty (Nil) or a value followed by another list (Cons)
data List(T) {
    Nil
    Cons(head : T, tail : List(T))
}

// A binary tree
data Tree(T) {
    Leaf(value : T)
    Node(left : Tree(T), value : T, right : Tree(T))
}
</code></pre>
<h2 id="the-mathematical-perspective"><a class="header" href="#the-mathematical-perspective">The Mathematical Perspective</a></h2>
<p>Why ‚Äúalgebraic‚Äù?</p>
<ul>
<li><strong>Product types</strong> correspond to multiplication: <code>Point = ‚Ñù √ó ‚Ñù</code></li>
<li><strong>Sum types</strong> correspond to addition: <code>Option(T) = T + 1</code></li>
</ul>
<p>The number of possible values follows algebra:</p>
<ul>
<li><code>Bool</code> has 2 values</li>
<li><code>Bool √ó Bool</code> has 2 √ó 2 = 4 values</li>
<li><code>Bool + Bool</code> has 2 + 2 = 4 values</li>
</ul>
<h2 id="practical-example-expression-trees"><a class="header" href="#practical-example-expression-trees">Practical Example: Expression Trees</a></h2>
<p>ADTs are perfect for representing mathematical expressions:</p>
<pre><code class="language-kleis">data Expression = 
    ENumber(value : ‚Ñù)
  | EVariable(name : String)
  | EOperation(name : String, args : List(Expression))

// Helper constructors for cleaner syntax
define num(n) = ENumber(n)
define var(x) = EVariable(x)
define e_add(a, b) = EOperation("plus", Cons(a, Cons(b, Nil)))
define e_mul(a, b) = EOperation("times", Cons(a, Cons(b, Nil)))
define e_neg(a) = EOperation("neg", Cons(a, Nil))

define eval_expr(expr, env) =
    match expr {
        ENumber(v) =&gt; v
        EVariable(name) =&gt; lookup(env, name)
        EOperation("plus", Cons(l, Cons(r, Nil))) =&gt; 
            eval_expr(l, env) + eval_expr(r, env)
        EOperation("times", Cons(l, Cons(r, Nil))) =&gt; 
            eval_expr(l, env) * eval_expr(r, env)
        EOperation("neg", Cons(e, Nil)) =&gt; 
            -eval_expr(e, env)
        _ =&gt; 0
    }
</code></pre>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What‚Äôs Next?</a></h2>
<p>Let‚Äôs dive deeper into pattern matching!</p>
<p>‚Üí <a href="#pattern-matching">Next: Pattern Matching</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="the-power-of-match"><a class="header" href="#the-power-of-match">The Power of Match</a></h2>
<p>Pattern matching is one of Kleis‚Äôs most powerful features. It lets you destructure data and handle different cases elegantly:</p>
<pre><code class="language-kleis">define describe(n) =
    match n {
        0 =&gt; 0
        1 =&gt; 1
        _ =&gt; 2
    }
</code></pre>
<h2 id="basic-patterns"><a class="header" href="#basic-patterns">Basic Patterns</a></h2>
<h3 id="literal-patterns"><a class="header" href="#literal-patterns">Literal Patterns</a></h3>
<p>Match exact values:</p>
<pre><code class="language-kleis">define describe_literal(x) =
    match x {
        0 =&gt; "zero"
        1 =&gt; "one"
        42 =&gt; "the answer"
        _ =&gt; "something else"
    }
</code></pre>
<h3 id="variable-patterns"><a class="header" href="#variable-patterns">Variable Patterns</a></h3>
<p>Bind matched values to names:</p>
<pre><code class="language-kleis">define sum_point(point) =
    match point {
        Point(x, y) =&gt; x + y
    }
</code></pre>
<h3 id="wildcard-pattern"><a class="header" href="#wildcard-pattern">Wildcard Pattern</a></h3>
<p>The underscore <code>_</code> matches anything:</p>
<pre><code class="language-kleis">define describe_pair(pair) =
    match pair {
        (_, 0) =&gt; "second is zero"
        (0, _) =&gt; "first is zero"
        _ =&gt; "neither is zero"
    }
</code></pre>
<h2 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h2>
<p>Patterns can be nested arbitrarily:</p>
<pre><code class="language-kleis">define sum_tree(tree) =
    match tree {
        Leaf(v) =&gt; v
        Node(Leaf(l), v, Leaf(r)) =&gt; l + v + r
        Node(left, v, right) =&gt; v + sum_tree(left) + sum_tree(right)
    }
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>Add conditions to patterns with <code>if</code>:</p>
<pre><code class="language-kleis">define sign(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        x if x &gt; 0 =&gt; "positive"
        _ =&gt; "zero"
    }
</code></pre>
<h2 id="as-patterns"><a class="header" href="#as-patterns">As-Patterns</a></h2>
<p>Bind the whole match while also destructuring:</p>
<pre><code class="language-kleis">define filter_head(list) =
    match list {
        Cons(h, t) as whole =&gt; 
            if h &gt; 10 then whole
            else t
        Nil =&gt; Nil
    }
</code></pre>
<h2 id="pattern-matching-in-let"><a class="header" href="#pattern-matching-in-let">Pattern Matching in Let</a></h2>
<p>Destructure directly in let bindings:</p>
<pre><code class="language-kleis">define distance_squared(origin) =
    let Point(x, y) = origin in x^2 + y^2

define sum_first_two(triple) =
    let (first, second, _) = triple in first + second
</code></pre>
<h2 id="pattern-matching-in-function-parameters"><a class="header" href="#pattern-matching-in-function-parameters">Pattern Matching in Function Parameters</a></h2>
<p>With lambda expressions now available, you can combine them with match:</p>
<pre><code class="language-kleis">// Pattern matching with lambdas
define fst = Œª pair . match pair { (a, _) =&gt; a }
define snd = Œª pair . match pair { (_, b) =&gt; b }
</code></pre>
<p><strong>Alternative workaround:</strong></p>
<pre><code class="language-kleis">define fst(pair) = 
    match pair {
        (a, _) =&gt; a
    }
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>Kleis checks that your patterns cover all cases:</p>
<pre><code class="language-kleis">// ‚ö†Ô∏è Warning: non-exhaustive patterns
define incomplete(opt) =
    match opt {
        Some(x) =&gt; x
    }

// ‚úì Complete
define complete(opt) =
    match opt {
        Some(x) =&gt; x
        None =&gt; 0
    }
</code></pre>
<h2 id="real-world-example-symbolic-differentiation"><a class="header" href="#real-world-example-symbolic-differentiation">Real-World Example: Symbolic Differentiation</a></h2>
<p>Pattern matching makes symbolic math elegant:</p>
<pre><code class="language-kleis">define diff(expr, var) =
    match expr {
        Const(_) =&gt; Const(0)
        
        Var(name) =&gt; 
            if name = var then Const(1)
            else Const(0)
        
        Add(f, g) =&gt; 
            Add(diff(f, var), diff(g, var))
        
        Mul(f, g) =&gt;
            Add(Mul(diff(f, var), g), 
                Mul(f, diff(g, var)))
        
        Neg(f) =&gt; 
            Neg(diff(f, var))
    }
</code></pre>
<blockquote>
<p><strong>Note:</strong> This <code>diff</code> function <strong>computes</strong> derivatives by pattern matching on expression trees. Kleis also provides <code>D(f, x)</code> and <code>Dt(f, x)</code> operations in <code>stdlib/calculus.kleis</code> for <strong>verifying</strong> derivative properties with Z3. See <a href="#symbolic-differentiation">Applications: Symbolic Differentiation</a> for a detailed comparison.</p>
</blockquote>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What‚Äôs Next?</a></h2>
<p>Learn about let bindings for local definitions!</p>
<p>‚Üí <a href="#let-bindings">Next: Let Bindings</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="let-bindings"><a class="header" href="#let-bindings">Let Bindings</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Let bindings introduce local variables with limited scope. They‚Äôre essential for breaking complex expressions into readable parts.</p>
<pre><code class="language-kleis">define square_five = let x = 5 in x * x
// Result: 25
</code></pre>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-kleis">let &lt;name&gt; = &lt;value&gt; in &lt;body&gt;
</code></pre>
<p>The variable <code>name</code> is only visible within <code>body</code>:</p>
<pre><code class="language-kleis">define circle_area = let radius = 10 in œÄ * radius^2
// Result: 314.159...
// 'radius' is not visible outside the let binding
</code></pre>
<h2 id="with-type-annotations"><a class="header" href="#with-type-annotations">With Type Annotations</a></h2>
<p>Add explicit types for clarity:</p>
<pre><code class="language-kleis">define typed_example1 = let x : ‚Ñù = 3.14 in x * 2
define typed_example2 = let n : ‚Ñï = 42 in factorial(n)
define typed_example3 = let v : Vector(3) = [1, 2, 3] in magnitude(v)
</code></pre>
<h2 id="nested-let-bindings"><a class="header" href="#nested-let-bindings">Nested Let Bindings</a></h2>
<p>Chain multiple bindings:</p>
<pre><code class="language-kleis">define nested_example =
    let x = 5 in
    let y = 3 in
    let z = x + y in
        x * y * z
// Result: 5 * 3 * 8 = 120
</code></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Inner bindings can shadow outer ones:</p>
<pre><code class="language-kleis">define shadowing_example =
    let x = 1 in
    let x = x + 1 in
    let x = x * 2 in
        x
// Result: 4  (not 1!)
</code></pre>
<p>Each <code>let</code> creates a new scope where <code>x</code> is rebound.</p>
<h2 id="pure-substitution-semantics"><a class="header" href="#pure-substitution-semantics">Pure Substitution Semantics</a></h2>
<p>In Kleis, <code>let x = e in body</code> is equivalent to substituting <code>e</code> for <code>x</code> in <code>body</code>:</p>
<pre><code class="language-kleis">define substitution_demo = let x = 5 in x + x
// is the same as:
define substitution_result = 5 + 5
</code></pre>
<p>This is <strong>pure functional semantics</strong> ‚Äî no mutation, no side effects.</p>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="quadratic-formula"><a class="header" href="#quadratic-formula">Quadratic Formula</a></h3>
<pre><code class="language-kleis">define quadratic_roots(a, b, c) =
    let discriminant = b^2 - 4*a*c in
    let sqrt_d = sqrt(discriminant) in
    let denom = 2 * a in
        ((-b + sqrt_d) / denom, (-b - sqrt_d) / denom)
</code></pre>
<h3 id="herons-formula"><a class="header" href="#herons-formula">Heron‚Äôs Formula</a></h3>
<pre><code class="language-kleis">define triangle_area(a, b, c) =
    let s = (a + b + c) / 2 in
        sqrt(s * (s - a) * (s - b) * (s - c))
</code></pre>
<h3 id="complex-calculations"><a class="header" href="#complex-calculations">Complex Calculations</a></h3>
<pre><code class="language-kleis">define schwarzschild_metric(r, M) =
    let rs = 2 * G * M / c^2 in
    let factor = 1 - rs / r in
        -c^2 * factor
</code></pre>
<h2 id="let-vs-define"><a class="header" href="#let-vs-define">Let vs Define</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>define</code></th><th><code>let ... in</code></th></tr>
</thead>
<tbody>
<tr><td>Top-level, global</td><td>Local scope only</td></tr>
<tr><td>Named function/constant</td><td>Temporary binding</td></tr>
<tr><td>Visible everywhere</td><td>Visible only in body</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Global constant
define pi = 3.14159

// Local temporary in a function
define circumference(radius) = let two_pi = 2 * pi in two_pi * radius
</code></pre>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What‚Äôs Next?</a></h2>
<p>Learn about quantifiers and logic!</p>
<p>‚Üí <a href="#quantifiers-and-logic">Next: Quantifiers and Logic</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quantifiers-and-logic"><a class="header" href="#quantifiers-and-logic">Quantifiers and Logic</a></h1>
<h2 id="universal-quantifier-"><a class="header" href="#universal-quantifier-">Universal Quantifier (‚àÄ)</a></h2>
<p>The universal quantifier expresses ‚Äúfor all‚Äù:</p>
<pre><code class="language-kleis example">// Quantified propositions (used inside axioms)
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x
axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
axiom commutative : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
</code></pre>
<p>ASCII alternative: <code>forall x . ...</code></p>
<h2 id="existential-quantifier-"><a class="header" href="#existential-quantifier-">Existential Quantifier (‚àÉ)</a></h2>
<p>The existential quantifier expresses ‚Äúthere exists‚Äù:</p>
<pre><code class="language-kleis example">// Existential quantifiers
axiom positive_exists : ‚àÉ(x : ‚Ñù). x &gt; 0
axiom sqrt2_exists : ‚àÉ(y : ‚Ñù). y * y = 2
axiom distinct_exists : ‚àÉ(x : ‚Ñù)(y : ‚Ñù). x ‚â† y
</code></pre>
<p>ASCII alternative: <code>exists x . ...</code></p>
<h2 id="combining-quantifiers"><a class="header" href="#combining-quantifiers">Combining Quantifiers</a></h2>
<p>Build complex statements:</p>
<pre><code class="language-kleis example">// Every number has a successor
axiom successor : ‚àÄ(n : ‚Ñï). ‚àÉ(m : ‚Ñï). m = n + 1

// Density of rationals: between any two reals is a rational
axiom density : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x &lt; y ‚Üí ‚àÉ(q : ‚Ñö). x &lt; q ‚àß q &lt; y
</code></pre>
<h2 id="logical-connectives"><a class="header" href="#logical-connectives">Logical Connectives</a></h2>
<h3 id="conjunction---and"><a class="header" href="#conjunction---and">Conjunction (‚àß / and)</a></h3>
<pre><code class="language-kleis">define in_range(x) = x &gt; 0 ‚àß x &lt; 10     // x is between 0 and 10
define false_example = True ‚àß False     // False
</code></pre>
<h3 id="disjunction---or"><a class="header" href="#disjunction---or">Disjunction (‚à® / or)</a></h3>
<pre><code class="language-kleis">define is_binary(x) = x = 0 ‚à® x = 1    // x is 0 or 1
define true_example = True ‚à® False     // True
</code></pre>
<h3 id="implication---implies"><a class="header" href="#implication---implies">Implication (‚Üí / implies)</a></h3>
<pre><code class="language-kleis">define positive_square(x) = x &gt; 0 ‚Üí x * x &gt; 0   // If positive, square is positive
define implication(P, Q) = P ‚Üí Q                // If P then Q
</code></pre>
<h3 id="negation---not"><a class="header" href="#negation---not">Negation (¬¨ / not)</a></h3>
<pre><code class="language-kleis">define nonzero(x) = ¬¨(x = 0)     // x is not zero
define not_true = ¬¨True          // False
</code></pre>
<h3 id="biconditional---iff"><a class="header" href="#biconditional---iff">Biconditional (‚Üî / iff)</a></h3>
<pre><code class="language-kleis">define zero_iff_square_zero(x) = x = 0 ‚Üî x * x = 0  // x is zero iff x¬≤ is zero
</code></pre>
<h2 id="type-constraints-in-quantifiers"><a class="header" href="#type-constraints-in-quantifiers">Type Constraints in Quantifiers</a></h2>
<p>Restrict the domain:</p>
<pre><code class="language-kleis example">axiom naturals_nonneg : ‚àÄ(x : ‚Ñï). x ‚â• 0
axiom det_inverse : ‚àÄ(M : Matrix(n, n)). det(M * M‚Åª¬π) = 1
</code></pre>
<h2 id="the-where-clause"><a class="header" href="#the-where-clause">The <code>where</code> Clause</a></h2>
<p>Add conditions to quantified variables using the <code>where</code> keyword:</p>
<pre><code class="language-kleis">structure Field(F) {
    element zero : F
    element one : F
    operation inverse : F ‚Üí F
    
    // Multiplicative inverse only for non-zero elements
    axiom multiplicative_inverse:
        ‚àÄ(x : F) where x ‚â† zero. inverse(x) * x = one
}
</code></pre>
<p>The <code>where</code> clause restricts the domain before the quantified body is evaluated. This is essential for axioms that don‚Äôt apply universally.</p>
<p><strong>More examples:</strong></p>
<pre><code class="language-kleis">structure Analysis {
    // Division only defined for non-zero denominator
    axiom division: ‚àÄ(a : ‚Ñù)(b : ‚Ñù) where b ‚â† 0. a / b * b = a
    
    // Logarithm only for positive numbers
    axiom log_exp: ‚àÄ(x : ‚Ñù) where x &gt; 0. exp(log(x)) = x
}
</code></pre>
<h2 id="using-quantifiers-in-axioms"><a class="header" href="#using-quantifiers-in-axioms">Using Quantifiers in Axioms</a></h2>
<p>Quantifiers are essential in structure axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G                      // Identity element
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x ‚àß mul(x, e) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h2 id="nested-quantifiers-grammar-v09"><a class="header" href="#nested-quantifiers-grammar-v09">Nested Quantifiers (Grammar v0.9)</a></h2>
<p>Quantifiers can appear inside logical expressions:</p>
<pre><code class="language-kleis">structure Analysis {
    // Quantifier inside conjunction
    axiom bounded_positive: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). abs(y) &lt;= x)
    
    // Quantifier inside implication
    axiom dense_rationals: ‚àÄ(a b : ‚Ñù). a &lt; b ‚Üí (‚àÉ(q : ‚Ñö). a &lt; q ‚àß q &lt; b)
    
    // Deeply nested quantifiers
    axiom limit_def: ‚àÄ(L : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
}
</code></pre>
<h3 id="epsilon-delta-limit-definition"><a class="header" href="#epsilon-delta-limit-definition">Epsilon-Delta Limit Definition</a></h3>
<p>The classic analysis definition now parses correctly:</p>
<pre><code class="language-kleis">structure Limits {
    axiom epsilon_delta: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, L a : ‚Ñù). 
        has_limit(f, a, L) ‚Üî 
        (‚àÄ(Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß 
            (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ)))
}
</code></pre>
<h2 id="function-types-in-quantifiers-grammar-v09"><a class="header" href="#function-types-in-quantifiers-grammar-v09">Function Types in Quantifiers (Grammar v0.9)</a></h2>
<p>Quantify over functions using the arrow type:</p>
<pre><code class="language-kleis">structure FunctionProperties {
    // Quantify over a function ‚Ñù ‚Üí ‚Ñù
    axiom continuous: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, x : ‚Ñù). 
        is_continuous(f, x)
    
    // Quantify over multiple functions
    axiom composition: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, g : ‚Ñù ‚Üí ‚Ñù). 
        compose(f, g) = Œª x . f(g(x))
    
    // Higher-order function types
    axiom curried: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù, a b : ‚Ñù). 
        f = f
}
</code></pre>
<h3 id="topology-with-function-types"><a class="header" href="#topology-with-function-types">Topology with Function Types</a></h3>
<pre><code class="language-kleis">structure Topology {
    axiom continuity: ‚àÄ(f : X ‚Üí Y, V : Set(Y)). 
        is_open(V) ‚Üí is_open(preimage(f, V))
    
    axiom homeomorphism: ‚àÄ(f : X ‚Üí Y, g : Y ‚Üí X). 
        (‚àÄ(x : X). g(f(x)) = x) ‚àß (‚àÄ(y : Y). f(g(y)) = y) ‚Üí 
        bijective(f)
}
</code></pre>
<h2 id="verification-with-z3"><a class="header" href="#verification-with-z3">Verification with Z3</a></h2>
<p>Kleis uses Z3 to check quantified statements:</p>
<pre><code class="language-kleis example">// Z3 can verify this is always true:
axiom add_zero : ‚àÄ(x : ‚Ñù). x + 0 = x

// Z3 can find a counterexample for this:
axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="truth-tables"><a class="header" href="#truth-tables">Truth Tables</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>P</th><th>Q</th><th>P ‚àß Q</th><th>P ‚à® Q</th><th>P ‚Üí Q</th><th>¬¨P</th></tr>
</thead>
<tbody>
<tr><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr>
<tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What‚Äôs Next?</a></h2>
<p>Learn about conditional expressions!</p>
<p>‚Üí <a href="#conditionals">Next: Conditionals</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<h2 id="if-then-else"><a class="header" href="#if-then-else">If-Then-Else</a></h2>
<p>The basic conditional expression:</p>
<pre><code class="language-kleis">if condition then value1 else value2
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">define positive_check(x) = if x &gt; 0 then "positive" else "non-positive"

define factorial(n) = if n = 0 then 1 else n * factorial(n - 1)

define abs(x) = if x ‚â• 0 then x else -x
</code></pre>
<h2 id="conditionals-are-expressions"><a class="header" href="#conditionals-are-expressions">Conditionals Are Expressions</a></h2>
<p>In Kleis, <code>if-then-else</code> is an expression that returns a value:</p>
<pre><code class="language-kleis">define doubled_abs(x) =
    let result = if x &gt; 0 then x else -x in
    result * 2

// Both branches must have compatible types!
// if True then 42 else "hello"  // ‚ùå Type error!
</code></pre>
<h2 id="nested-conditionals"><a class="header" href="#nested-conditionals">Nested Conditionals</a></h2>
<pre><code class="language-kleis">define sign(x) =
    if x &gt; 0 then 1
    else if x &lt; 0 then -1
    else 0

define grade(score) =
    if score ‚â• 90 then "A"
    else if score ‚â• 80 then "B"
    else if score ‚â• 70 then "C"
    else if score ‚â• 60 then "D"
    else "F"
</code></pre>
<h2 id="guards-vs-if-then-else"><a class="header" href="#guards-vs-if-then-else">Guards vs If-Then-Else</a></h2>
<p>Pattern matching with guards is often cleaner:</p>
<pre><code class="language-kleis">// With if-then-else
define classify_if(n) =
    if n &lt; 0 then "negative"
    else if n = 0 then "zero"
    else "positive"

// With pattern matching and guards
define classify_match(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        0 =&gt; "zero"
        _ =&gt; "positive"
    }
</code></pre>
<h2 id="piecewise-functions"><a class="header" href="#piecewise-functions">Piecewise Functions</a></h2>
<p>Mathematicians love piecewise definitions:</p>
<pre><code class="language-kleis">// Absolute value
define abs_fn(x) =
    if x ‚â• 0 then x else -x

// Heaviside step function
define heaviside(x) =
    if x &lt; 0 then 0
    else if x = 0 then 0.5
    else 1

// Piecewise polynomial
define piecewise_f(x) =
    if x &lt; 0 then x^2
    else if x &lt; 1 then x
    else 2 - x
</code></pre>
<h2 id="boolean-expressions"><a class="header" href="#boolean-expressions">Boolean Expressions</a></h2>
<p>Conditions can be complex:</p>
<pre><code class="language-kleis">define quadrant(x, y) =
    if x &gt; 0 ‚àß y &gt; 0 then "first quadrant"
    else if x &lt; 0 ‚àß y &gt; 0 then "second quadrant"
    else if x &lt; 0 ‚àß y &lt; 0 then "third quadrant"
    else if x &gt; 0 ‚àß y &lt; 0 then "fourth quadrant"
    else "on an axis"
</code></pre>
<h2 id="short-circuit-evaluation"><a class="header" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></h2>
<p>Kleis uses short-circuit evaluation for <code>‚àß</code> and <code>‚à®</code>:</p>
<pre><code class="language-kleis">// If x = 0, division is never evaluated
define check_ratio(x, y) =
    if x ‚â† 0 ‚àß y/x &gt; 1 then "big ratio" else "safe"
</code></pre>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What‚Äôs Next?</a></h2>
<p>Learn about structures for defining mathematical objects!</p>
<p>‚Üí <a href="#structures">Next: Structures</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<h2 id="what-are-structures"><a class="header" href="#what-are-structures">What Are Structures?</a></h2>
<p>Structures define mathematical objects with their properties and operations. Think of them as ‚Äúblueprints‚Äù for mathematical concepts.</p>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï) {
    // Operations this structure supports
    operation add : Vector(n) ‚Üí Vector(n)
    operation scale : ‚Ñù ‚Üí Vector(n)
    operation dot : Vector(n) ‚Üí ‚Ñù
    
    // Properties that must hold
    axiom commutative : ‚àÄ(u : Vector(n))(v : Vector(n)).
        add(u, v) = add(v, u)
}
</code></pre>
<h2 id="structure-syntax"><a class="header" href="#structure-syntax">Structure Syntax</a></h2>
<pre><code class="language-kleis">structure Name(parameters) {
    // Elements (constants)
    element1 : Type1
    
    // Operations (functions)  
    operation op1 : InputType ‚Üí OutputType
    
    // Axioms (properties)
    axiom property : logical_statement
}
</code></pre>
<h2 id="structure-members"><a class="header" href="#structure-members">Structure Members</a></h2>
<p>Structures contain three kinds of members:</p>
<h3 id="the-operation-keyword"><a class="header" href="#the-operation-keyword">The <code>operation</code> Keyword</a></h3>
<p>The <code>operation</code> keyword declares a function that the structure provides:</p>
<pre><code class="language-kleis">structure Group(G) {
    operation mul : G √ó G ‚Üí G      // Binary operation
    operation inv : G ‚Üí G          // Unary operation
}
</code></pre>
<p>Operations declare the <em>signature</em> (types), not the implementation. The implementation is provided in an <code>implements</code> block (see Chapter 10).</p>
<h3 id="the-element-keyword"><a class="header" href="#the-element-keyword">The <code>element</code> Keyword</a></h3>
<p>The <code>element</code> keyword declares a distinguished constant of the structure:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    element e : M           // Identity element
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x
}

structure Field(F) {
    element zero : F        // Additive identity
    element one : F         // Multiplicative identity
}
</code></pre>
<p>Elements are constants that satisfy the structure‚Äôs axioms. You can also write elements without the <code>element</code> keyword:</p>
<pre><code class="language-kleis">structure Ring(R) {
    zero : R    // Same as "element zero : R"
    one : R
}
</code></pre>
<h3 id="the-axiom-keyword"><a class="header" href="#the-axiom-keyword">The <code>axiom</code> Keyword</a></h3>
<p>The <code>axiom</code> keyword declares a property that must hold:</p>
<pre><code class="language-kleis">structure Group(G) {
    element e : M
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x ‚àß mul(x, e) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G). mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<p>Axioms are verified by Z3 when you use <code>implements</code> blocks or run <code>kleis verify</code>.</p>
<h2 id="example-complex-numbers"><a class="header" href="#example-complex-numbers">Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">structure Complex {
    re : ‚Ñù  // real part
    im : ‚Ñù  // imaginary part
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex           // conjugate
    operation mag : ‚Ñù                  // magnitude
    
    axiom add_commutative : ‚àÄ(z : Complex)(w : Complex).
        add(z, w) = add(w, z)
        
    axiom magnitude_positive : ‚àÄ(z : Complex).
        mag(z) ‚â• 0
        
    axiom conj_involution : ‚àÄ(z : Complex).
        conj(conj(z)) = z
}
</code></pre>
<h2 id="parametric-structures"><a class="header" href="#parametric-structures">Parametric Structures</a></h2>
<p>Structures can have type parameters:</p>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    
    axiom transpose_involution : ‚àÄ(A : Matrix(m, n, T)).
        transpose(transpose(A)) = A
}

// Square matrices have more operations
structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    
    axiom det_mul : ‚àÄ(A : SquareMatrix(n, T))(B : SquareMatrix(n, T)).
        det(mul(A, B)) = det(A) * det(B)
}
</code></pre>
<h2 id="nested-structures"><a class="header" href="#nested-structures">Nested Structures</a></h2>
<p>Structures can contain other structures. This enables compositional algebra ‚Äî defining complex structures from simpler parts:</p>
<pre><code class="language-kleis">structure Ring(R) {
    // A ring has an additive group
    structure additive : AbelianGroup(R) {
        operation add : R √ó R ‚Üí R
        operation negate : R ‚Üí R
        zero : R
    }
    
    // And a multiplicative monoid
    structure multiplicative : Monoid(R) {
        operation mul : R √ó R ‚Üí R
        one : R
    }
    
    // With distributivity connecting them
    axiom distributive : ‚àÄ(x : R)(y : R)(z : R).
        mul(x, add(y, z)) = add(mul(x, y), mul(x, z))
}
</code></pre>
<p>Nested structures can go arbitrarily deep:</p>
<pre><code class="language-kleis">structure VectorSpace(V, F) {
    structure vectors : AbelianGroup(V) {
        operation add : V √ó V ‚Üí V
        zero : V
    }
    
    structure scalars : Field(F) {
        operation add : F √ó F ‚Üí F
        operation mul : F √ó F ‚Üí F
    }
    
    operation scale : F √ó V ‚Üí V
}
</code></pre>
<p>When using Z3 verification, axioms from nested structures are automatically available.</p>
<h2 id="the-extends-keyword"><a class="header" href="#the-extends-keyword">The <code>extends</code> Keyword</a></h2>
<p>Structures can extend other structures:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
    
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e ‚àß mul(inv(x), x) = e
}

structure AbelianGroup(G) extends Group(G) {
    axiom commutative : ‚àÄ(x : G)(y : G). mul(x, y) = mul(y, x)
}
</code></pre>
<h2 id="the-over-keyword"><a class="header" href="#the-over-keyword">The <code>over</code> Keyword</a></h2>
<p>Many mathematical structures are defined ‚Äúover‚Äù a base structure. A vector space is defined over a field, a module over a ring:</p>
<pre><code class="language-kleis">// Vector space over a field
structure VectorSpace(V) over Field(F) {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    
    axiom scalar_identity : ‚àÄ(v : V). scale(1, v) = v
    axiom distributive : ‚àÄ(a : F)(u : V)(v : V).
        scale(a, add(u, v)) = add(scale(a, u), scale(a, v))
}

// Module over a ring (generalization of vector space)
structure Module(M) over Ring(R) {
    operation add : M √ó M ‚Üí M
    operation scale : R √ó M ‚Üí M
}

// Algebra over a ring
structure Algebra(A) over Ring(R) {
    operation add : A √ó A ‚Üí A
    operation scale : R √ó A ‚Üí A
    operation mul : A √ó A ‚Üí A
    
    axiom bilinear : ‚àÄ(r : R)(a : A)(b : A).
        scale(r, mul(a, b)) = mul(scale(r, a), b)
}
</code></pre>
<p>When you use <code>over</code>, Kleis automatically makes the base structure‚Äôs axioms available for verification. For example, when verifying <code>VectorSpace</code> axioms, Z3 knows that <code>F</code> satisfies all <code>Field</code> axioms.</p>
<h2 id="differential-geometry-structures"><a class="header" href="#differential-geometry-structures">Differential Geometry Structures</a></h2>
<p>Kleis shines for differential geometry:</p>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(M)
    operation metric : M ‚Üí Tensor(0, 2)
    
    axiom metric_symmetric : ‚àÄ(p : M).
        metric(p) = transpose(metric(p))
}

structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Tensor(0, 2)
    operation scalar_curvature : M ‚Üí ‚Ñù
    
    // R^a_{bcd} + R^a_{cdb} + R^a_{dbc} = 0
    axiom first_bianchi : ‚àÄ(p : M).
        cyclic_sum(riemann(p)) = 0
}
</code></pre>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What‚Äôs Next?</a></h2>
<p>Learn how to implement structures!</p>
<p>‚Üí <a href="#implements">Next: Implements</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implements"><a class="header" href="#implements">Implements</a></h1>
<h2 id="from-structure-to-implementation"><a class="header" href="#from-structure-to-implementation">From Structure to Implementation</a></h2>
<p>A <code>structure</code> declares what operations exist. An <code>implements</code> block provides the actual definitions:</p>
<pre><code class="language-kleis">structure Addable(T) {
    operation add : T √ó T ‚Üí T
}

implements Addable(‚Ñù) {
    operation add(x, y) = x + y
}

implements Addable(‚Ñ§) {
    operation add(x, y) = x + y
}
</code></pre>
<h2 id="full-example-complex-numbers"><a class="header" href="#full-example-complex-numbers">Full Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">// Declare the structure
structure Complex {
    re : ‚Ñù
    im : ‚Ñù
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex
    operation mag : ‚Ñù
}

// Implement the operations
implements Complex {
    operation add(z, w) = builtin_complex_add
    operation mul(z, w) = builtin_complex_mul
    operation conj(z) = builtin_complex_conj
    operation mag(z) = sqrt(z.re^2 + z.im^2)
}
</code></pre>
<h2 id="parametric-implementations"><a class="header" href="#parametric-implementations">Parametric Implementations</a></h2>
<p>Implement structures with type parameters:</p>
<pre><code class="language-kleis">structure Stack(T) {
    operation push : T ‚Üí Stack(T)
    operation pop : Stack(T)
    operation top : T
    operation empty : Bool
}

implements Stack(‚Ñ§) {
    operation push = builtin_stack_push
    operation pop = builtin_stack_pop
    operation top = builtin_stack_top
    operation empty = builtin_stack_empty
}
</code></pre>
<h2 id="multiple-implementations"><a class="header" href="#multiple-implementations">Multiple Implementations</a></h2>
<p>The same structure can have multiple implementations:</p>
<pre><code class="language-kleis">structure Orderable(T) {
    operation compare : T √ó T ‚Üí Ordering
}

// Natural ordering
implements Orderable(‚Ñ§) {
    operation compare = builtin_int_compare
}
</code></pre>
<h2 id="implementing-extended-structures"><a class="header" href="#implementing-extended-structures">Implementing Extended Structures</a></h2>
<p>When a structure extends another, implement all operations:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    operation e : M
    operation mul : M √ó M ‚Üí M
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
}

// Must implement both Monoid and Group operations
implements Group(‚Ñ§) {
    operation e = 0
    operation mul(x, y) = x + y
    operation inv(x) = -x
}
</code></pre>
<h2 id="builtin-operations"><a class="header" href="#builtin-operations">Builtin Operations</a></h2>
<p>Some operations can‚Äôt be defined in pure Kleis ‚Äî they need native code. The <code>builtin_</code> prefix connects Kleis to underlying implementations:</p>
<pre><code class="language-kleis">implements Matrix(m, n, ‚Ñù) {
    operation transpose = builtin_transpose
    operation add = builtin_matrix_add
    operation mul = builtin_matrix_mul
}
</code></pre>
<h3 id="how-builtins-work"><a class="header" href="#how-builtins-work">How Builtins Work</a></h3>
<p>When Kleis sees <code>builtin_foo</code>, it:</p>
<ol>
<li>Looks up <code>foo</code> in the native runtime</li>
<li>Calls the Rust/C/hardware implementation</li>
<li>Returns the result to Kleis</li>
</ol>
<p>This enables:</p>
<ul>
<li><strong>Performance</strong>: Native BLAS for matrix operations</li>
<li><strong>Hardware access</strong>: GPUs, network cards, sensors</li>
<li><strong>System calls</strong>: File I/O, networking, threading</li>
<li><strong>FFI</strong>: Calling existing libraries</li>
</ul>
<h3 id="the-vision-hardware-as-structures"><a class="header" href="#the-vision-hardware-as-structures">The Vision: Hardware as Structures</a></h3>
<p>Imagine:</p>
<pre><code class="language-kleis">structure NetworkInterface(N) {
    operation send : Packet ‚Üí Result(Unit, Error)
    operation receive : Unit ‚Üí Result(Packet, Error)
    
    axiom delivery : ‚àÄ(p : Packet).
        connected ‚Üí eventually(delivered(p))
}

implements NetworkInterface(EthernetCard) {
    operation send = builtin_eth_send
    operation receive = builtin_eth_receive
}
</code></pre>
<p>The <strong>axioms</strong> define the contract. The <strong>builtins</strong> provide the implementation. Z3 can verify that higher-level protocols satisfy their specifications <em>given</em> the hardware axioms.</p>
<p>This is how Kleis becomes a <strong>universal verification platform</strong> ‚Äî not just for math, but for any system with verifiable properties.</p>
<h2 id="verification-of-implementations"><a class="header" href="#verification-of-implementations">Verification of Implementations</a></h2>
<p>Kleis + Z3 can verify that implementations satisfy axioms:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

implements Monoid(String) {
    element e = ""
    operation mul = builtin_concat
}

// Kleis can verify:
// 1. concat("", s) = s for all s ‚úì
// 2. concat(s, "") = s for all s ‚úì
// 3. concat(concat(a, b), c) = concat(a, concat(b, c)) ‚úì
</code></pre>
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What‚Äôs Next?</a></h2>
<p>Learn about Z3 verification in depth!</p>
<p>‚Üí <a href="#z3-verification">Next: Z3 Verification</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="z3-verification"><a class="header" href="#z3-verification">Z3 Verification</a></h1>
<h2 id="what-is-z3"><a class="header" href="#what-is-z3">What is Z3?</a></h2>
<p><a href="https://github.com/Z3Prover/z3">Z3</a> is a theorem prover from Microsoft Research. Kleis uses Z3 to:</p>
<ul>
<li><strong>Verify</strong> mathematical statements</li>
<li><strong>Find counterexamples</strong> when statements are false</li>
<li><strong>Check</strong> that implementations satisfy axioms</li>
</ul>
<h2 id="basic-verification"><a class="header" href="#basic-verification">Basic Verification</a></h2>
<p>Use <code>verify</code> to check a statement:</p>
<pre><code class="language-kleis example">axiom commutativity : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
// Z3 verifies: ‚úì Valid

axiom zero_annihilates : ‚àÄ(x : ‚Ñù). x * 0 = 0
// Z3 verifies: ‚úì Valid

axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="verifying-quantified-statements"><a class="header" href="#verifying-quantified-statements">Verifying Quantified Statements</a></h2>
<p>Z3 handles universal and existential quantifiers:</p>
<pre><code class="language-kleis example">axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
// Z3 verifies: ‚úì Valid

axiom squares_nonnegative : ‚àÄ(x : ‚Ñù). x * x ‚â• 0
// Z3 verifies: ‚úì Valid (squares are non-negative)

axiom no_real_sqrt_neg1 : ‚àÉ(x : ‚Ñù). x * x = -1
// Z3: ‚úó Invalid (no real square root of -1)

axiom complex_sqrt_neg1 : ‚àÉ(x : ‚ÑÇ). x * x = -1
// Z3 verifies: ‚úì Valid (x = i works)
</code></pre>
<h2 id="checking-axioms"><a class="header" href="#checking-axioms">Checking Axioms</a></h2>
<p>Verify that definitions satisfy axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

// Define integers with addition
implements Group(‚Ñ§) {
    element e = 0
    operation mul = builtin_add
    operation inv = builtin_negate
}

// Kleis verifies each axiom automatically!
</code></pre>
<h2 id="implication-verification"><a class="header" href="#implication-verification">Implication Verification</a></h2>
<p>Prove that premises imply conclusions:</p>
<pre><code class="language-kleis example">// If x &gt; 0 and y &gt; 0, then x + y &gt; 0
axiom sum_positive : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). (x &gt; 0 ‚àß y &gt; 0) ‚Üí x + y &gt; 0
// Z3 verifies: ‚úì Valid

// Triangle inequality
axiom triangle_ineq : ‚àÄ(x : ‚Ñù)(y : ‚Ñù)(a : ‚Ñù)(b : ‚Ñù).
    (abs(x) ‚â§ a ‚àß abs(y) ‚â§ b) ‚Üí abs(x + y) ‚â§ a + b
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="counterexamples"><a class="header" href="#counterexamples">Counterexamples</a></h2>
<p>When verification fails, Z3 provides counterexamples:</p>
<pre><code class="language-kleis example">axiom square_equals_self : ‚àÄ(x : ‚Ñù). x^2 = x
// Z3: ‚úó Invalid, Counterexample: x = 2 (since 4 ‚â† 2)

axiom positive_greater_than_one : ‚àÄ(n : ‚Ñï). n &gt; 0 ‚Üí n &gt; 1
// Z3: ‚úó Invalid, Counterexample: n = 1
</code></pre>
<h2 id="timeout-and-limits"><a class="header" href="#timeout-and-limits">Timeout and Limits</a></h2>
<p>Complex statements may time out:</p>
<pre><code class="language-kleis">// Very complex statement
verify ‚àÄ M : Matrix(100, 100) . det(M * M') ‚â• 0
// Result: ‚è± Timeout (statement too complex)
</code></pre>
<h2 id="verifying-nested-quantifiers-grammar-v09"><a class="header" href="#verifying-nested-quantifiers-grammar-v09">Verifying Nested Quantifiers (Grammar v0.9)</a></h2>
<p>Grammar v0.9 enables nested quantifiers in logical expressions:</p>
<pre><code class="language-kleis">structure Analysis {
    // Quantifier inside conjunction - Z3 handles this
    axiom bounded: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). y = y)
    
    // Epsilon-delta limit definition
    axiom limit_def: ‚àÄ(L a : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
}
</code></pre>
<h3 id="function-types-in-verification"><a class="header" href="#function-types-in-verification">Function Types in Verification</a></h3>
<p>Quantify over functions and verify their properties:</p>
<pre><code class="language-kleis">structure Continuity {
    // Z3 treats f as an uninterpreted function ‚Ñù ‚Üí ‚Ñù
    axiom continuous_at: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, a : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - f(a)) &lt; Œµ))
}
</code></pre>
<p><strong>Note:</strong> Z3 treats function-typed variables as uninterpreted functions, allowing reasoning about their properties without knowing their implementation.</p>
<h2 id="what-z3-can-and-cannot-do"><a class="header" href="#what-z3-can-and-cannot-do">What Z3 Can and Cannot Do</a></h2>
<h3 id="z3-excels-at"><a class="header" href="#z3-excels-at">Z3 Excels At:</a></h3>
<ul>
<li>Linear arithmetic</li>
<li>Boolean logic</li>
<li>Array reasoning</li>
<li>Simple quantifiers</li>
<li>Algebraic identities</li>
<li>Nested quantifiers (Grammar v0.9)</li>
<li>Function-typed variables</li>
</ul>
<h3 id="z3-struggles-with"><a class="header" href="#z3-struggles-with">Z3 Struggles With:</a></h3>
<ul>
<li>Non-linear real arithmetic (undecidable in general)</li>
<li>Very deep quantifier nesting (may timeout)</li>
<li>Transcendental functions (sin, cos, exp)</li>
<li>Infinite structures</li>
<li>Inductive proofs over recursive data types</li>
</ul>
<h2 id="practical-workflow"><a class="header" href="#practical-workflow">Practical Workflow</a></h2>
<ol>
<li><strong>Write structure with axioms</strong></li>
<li><strong>Implement operations</strong></li>
<li><strong>Kleis auto-verifies</strong> axioms are satisfied</li>
<li><strong>Use <code>verify</code></strong> for additional properties</li>
<li><strong>Examine counterexamples</strong> when verification fails</li>
</ol>
<pre><code class="language-kleis">// Step 1: Define structure
structure Ring(R) {
    zero : R
    one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    axiom add_assoc : ‚àÄ(a : R)(b : R)(c : R).
        add(add(a, b), c) = add(a, add(b, c))
}

// Step 2: Implement for integers
implements Ring(‚Ñ§) {
    element zero = 0
    element one = 1
    operation add = builtin_add
    operation mul = builtin_mul
    operation neg = builtin_negate
}

// Step 3: Auto-verification happens!

// Step 4: Check additional properties
axiom mul_zero : ‚àÄ(x : ‚Ñ§). mul(x, zero) = zero
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="solver-abstraction-layer"><a class="header" href="#solver-abstraction-layer">Solver Abstraction Layer</a></h2>
<p>While this chapter focuses on Z3, Kleis is designed with a <strong>solver abstraction layer</strong> that can interface with multiple proof backends.</p>
<h3 id="architecture"><a class="header" href="#architecture">Architecture</a></h3>
<pre><code>User Code (Kleis Expression)
         ‚îÇ
    SolverBackend Trait
         ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ            ‚îÇ           ‚îÇ              ‚îÇ
Z3Backend  CVC5Backend  IsabelleBackend  CustomBackend
   ‚îÇ            ‚îÇ           ‚îÇ              ‚îÇ
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
  OperationTranslators
         ‚îÇ
   ResultConverter
         ‚îÇ
User Code (Kleis Expression)
</code></pre>
<h3 id="the-solverbackend-trait"><a class="header" href="#the-solverbackend-trait">The SolverBackend Trait</a></h3>
<p>The core abstraction is defined in <code>src/solvers/backend.rs</code>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SolverBackend {
    /// Get solver name (e.g., "Z3", "CVC5")
    fn name(&amp;self) -&gt; &amp;str;

    /// Get solver capabilities (declared upfront, MCP-style)
    fn capabilities(&amp;self) -&gt; &amp;SolverCapabilities;

    /// Verify an axiom (validity check)
    fn verify_axiom(&amp;mut self, axiom: &amp;Expression) 
        -&gt; Result&lt;VerificationResult, String&gt;;

    /// Check if an expression is satisfiable
    fn check_satisfiability(&amp;mut self, expr: &amp;Expression) 
        -&gt; Result&lt;SatisfiabilityResult, String&gt;;

    /// Evaluate an expression to a concrete value
    fn evaluate(&amp;mut self, expr: &amp;Expression) 
        -&gt; Result&lt;Expression, String&gt;;

    /// Simplify an expression
    fn simplify(&amp;mut self, expr: &amp;Expression) 
        -&gt; Result&lt;Expression, String&gt;;

    /// Check if two expressions are equivalent
    fn are_equivalent(&amp;mut self, e1: &amp;Expression, e2: &amp;Expression) 
        -&gt; Result&lt;bool, String&gt;;

    // ... additional methods for scope management, assertions, etc.
}
<span class="boring">}</span></code></pre>
<p><strong>Key design principle:</strong> All public methods work with Kleis <code>Expression</code>, not solver-specific types. Solver internals never escape the abstraction.</p>
<h3 id="mcp-style-capability-declaration"><a class="header" href="#mcp-style-capability-declaration">MCP-Style Capability Declaration</a></h3>
<p>Solvers declare their capabilities upfront (inspired by Model Context Protocol):</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SolverCapabilities {
    pub solver: SolverMetadata,      // name, version, type
    pub capabilities: Capabilities,   // operations, theories, features
}

pub struct Capabilities {
    pub theories: HashSet&lt;String&gt;,              // "arithmetic", "boolean", etc.
    pub operations: HashMap&lt;String, OperationSpec&gt;,
    pub features: FeatureFlags,                 // quantifiers, evaluation, etc.
    pub performance: PerformanceHints,          // timeout, max axioms
}
<span class="boring">}</span></code></pre>
<p>This enables:</p>
<ul>
<li><strong>Coverage analysis</strong> - Know what operations are natively supported</li>
<li><strong>Multi-solver comparison</strong> - Choose the best solver for a program</li>
<li><strong>User extensibility</strong> - Add translators for missing operations</li>
</ul>
<h3 id="verification-results"><a class="header" href="#verification-results">Verification Results</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum VerificationResult {
    Valid,                              // Axiom holds for all inputs
    Invalid { counterexample: String }, // Found a violation
    Unknown,                            // Timeout or too complex
}

pub enum SatisfiabilityResult {
    Satisfiable { example: String },    // Found satisfying assignment
    Unsatisfiable,                      // No solution exists
    Unknown,
}
<span class="boring">}</span></code></pre>
<h3 id="why-multiple-backends"><a class="header" href="#why-multiple-backends">Why Multiple Backends?</a></h3>
<p>Different proof systems have different strengths:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Backend</th><th>Strength</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><strong>Z3</strong></td><td>Fast SMT solving, decidable theories</td><td>Arithmetic, quick checks, counterexamples</td></tr>
<tr><td><strong>CVC5</strong></td><td>Finite model finding, strings</td><td>Bounded verification, string operations</td></tr>
<tr><td><strong>Isabelle</strong></td><td>Structured proofs, automation</td><td>Complex inductive proofs, formalization</td></tr>
<tr><td><strong>Coq/Lean</strong></td><td>Dependent types, program extraction</td><td>Certified programs, mathematical libraries</td></tr>
</tbody>
</table>
</div>
<h3 id="current-implementation"><a class="header" href="#current-implementation">Current Implementation</a></h3>
<p>Currently implemented in <code>src/solvers/</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Component</th><th>Status</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>SolverBackend</code> trait</td><td>‚úÖ Complete</td><td>Core abstraction</td></tr>
<tr><td><code>SolverCapabilities</code></td><td>‚úÖ Complete</td><td>MCP-style capability declaration</td></tr>
<tr><td><code>Z3Backend</code></td><td>‚úÖ Complete</td><td>Full Z3 integration</td></tr>
<tr><td><code>ResultConverter</code></td><td>‚úÖ Complete</td><td>Convert solver results to Kleis expressions</td></tr>
<tr><td><code>discovery</code> module</td><td>‚úÖ Complete</td><td>List available solvers</td></tr>
<tr><td>CVC5Backend</td><td>üîÆ Future</td><td>Alternative SMT solver</td></tr>
<tr><td>IsabelleBackend</td><td>üîÆ Future</td><td>HOL theorem prover</td></tr>
</tbody>
</table>
</div>
<h3 id="solver-discovery"><a class="header" href="#solver-discovery">Solver Discovery</a></h3>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kleis::solvers::discovery;

// List all available backends
let solvers = discovery::list_solvers();  // ["Z3"]

// Check if a specific solver is available
if discovery::is_available("Z3") {
    let backend = Z3Backend::new()?;
}
<span class="boring">}</span></code></pre>
<h3 id="benefits-of-abstraction"><a class="header" href="#benefits-of-abstraction">Benefits of Abstraction</a></h3>
<ol>
<li><strong>Solver independence</strong> - Swap solvers without code changes</li>
<li><strong>Unified API</strong> - Same methods regardless of backend</li>
<li><strong>Capability-aware</strong> - Know what each solver supports before using it</li>
<li><strong>Extensible</strong> - Add custom backends by implementing the trait</li>
<li><strong>Future-proof</strong> - New provers can be integrated without changing Kleis code</li>
</ol>
<p>This architecture makes Kleis a <strong>proof orchestration layer</strong> with beautiful notation, not just another proof assistant.</p>
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What‚Äôs Next?</a></h2>
<p>Try the interactive REPL!</p>
<p>‚Üí <a href="#the-repl-1">Next: The REPL</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-repl-1"><a class="header" href="#the-repl-1">The REPL</a></h1>
<h2 id="what-is-the-repl"><a class="header" href="#what-is-the-repl">What is the REPL?</a></h2>
<p>The REPL (Read-Eval-Print Loop) is an interactive environment for experimenting with Kleis:</p>
<pre><code class="language-bash">$ cargo run --bin repl

üßÆ Kleis REPL v0.1.0
   Type :help for commands, :quit to exit

Œª&gt;
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Enter expressions to evaluate them symbolically:</p>
<pre><code>Œª&gt; 2 + 2
2 + 2

Œª&gt; let x = 5 in x * x
times(5, 5)

Œª&gt; sin(œÄ / 2)
sin(divide(œÄ, 2))
</code></pre>
<blockquote>
<p><strong>Note:</strong> The REPL performs <strong>symbolic evaluation</strong>, not numeric computation. Expressions are simplified symbolically, not calculated to numbers.</p>
</blockquote>
<h2 id="loading-files"><a class="header" href="#loading-files">Loading Files</a></h2>
<p>The REPL prompt evaluates expressions. For definitions (<code>define</code>, <code>structure</code>, etc.), use <code>:load</code>:</p>
<pre><code>Œª&gt; :load examples/protocols/stop_and_wait.kleis
‚úÖ Loaded: 1 files, 5 functions, 0 structures, 0 data types, 0 type aliases

Œª&gt; :env
üìã Defined functions:
  next_seq (seq) = ...
  valid_ack (sent, ack) = ...
  sender_next_state (current_seq, ack_received) = ...
  receiver_accepts (expected, received) = ...
  receiver_next_state (expected, received) = ...
</code></pre>
<p>More examples to load:</p>
<pre><code>Œª&gt; :load examples/business/order_to_cash.kleis
‚úÖ Loaded: 1 files, 21 functions, 0 structures, 4 data types, 0 type aliases

Œª&gt; :load examples/authorization/zanzibar.kleis
‚úÖ Loaded: 1 files, 13 functions, 0 structures, 0 data types, 0 type aliases
</code></pre>
<h2 id="the-import-keyword"><a class="header" href="#the-import-keyword">The <code>import</code> Keyword</a></h2>
<p>In Kleis source files, use <code>import</code> to include definitions from other files:</p>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"
import "stdlib/matrices.kleis"

// Now you can use definitions from those files
define my_matrix = identity(3)
</code></pre>
<p><strong>Import syntax:</strong></p>
<ul>
<li><code>import "path/to/file.kleis"</code> ‚Äî includes all definitions from that file</li>
</ul>
<p>Imports are processed at parse time. Relative paths are resolved from the importing file‚Äôs directory.</p>
<p><strong>Common imports:</strong></p>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"     // Basic types and operations
import "stdlib/matrices.kleis"    // Matrix operations
import "stdlib/complex.kleis"     // Complex number support
</code></pre>
<h3 id="standard-library-resolution"><a class="header" href="#standard-library-resolution">Standard Library Resolution</a></h3>
<p>Imports starting with <code>stdlib/</code> are handled specially:</p>
<ol>
<li><strong><code>KLEIS_ROOT</code> environment variable</strong> ‚Äî If set, Kleis looks for <code>$KLEIS_ROOT/stdlib/...</code> first</li>
<li><strong>Project directory</strong> ‚Äî Kleis walks up from the current file looking for a <code>stdlib/</code> folder</li>
<li><strong>Current working directory</strong> ‚Äî Falls back to <code>./stdlib/...</code></li>
</ol>
<p><strong>Setting <code>KLEIS_ROOT</code>:</strong></p>
<pre><code class="language-bash"># Add to your shell profile (~/.bashrc, ~/.zshrc, etc.)
export KLEIS_ROOT=/path/to/kleis

# Now stdlib imports work from anywhere
kleis run my_project/main.kleis
</code></pre>
<p>This is useful when:</p>
<ul>
<li>Working on projects outside the Kleis repository</li>
<li>Running Kleis from arbitrary directories</li>
<li>Sharing code that uses the standard library</li>
</ul>
<blockquote>
<p><strong>Note:</strong> In the REPL, use <code>:load</code> instead of <code>import</code>. The <code>:load</code> command loads a file interactively, while <code>import</code> is for use inside <code>.kleis</code> source files.</p>
</blockquote>
<h2 id="verification-with-z3-1"><a class="header" href="#verification-with-z3-1">Verification with Z3</a></h2>
<p>Run verifications interactively with <code>:verify</code>:</p>
<pre><code>Œª&gt; :verify x + y = y + x
‚úÖ Valid

Œª&gt; :verify x &gt; 0
‚ùå Invalid - Counterexample: x!2 -&gt; 0
</code></pre>
<h2 id="satisfiability-with-z3"><a class="header" href="#satisfiability-with-z3">Satisfiability with Z3</a></h2>
<p>Use <code>:sat</code> to find solutions (equation solving):</p>
<pre><code>Œª&gt; :sat ‚àÉ(z : ‚ÑÇ). z * z = complex(-1, 0)
‚úÖ Satisfiable
   Witness: z_re = 0, z_im = -1

Œª&gt; :sat ‚àÉ(x : ‚Ñù). x * x = 4
‚úÖ Satisfiable
   Witness: x = -2

Œª&gt; :sat ‚àÉ(x : ‚Ñù). x * x = -1
‚ùå Unsatisfiable (no solution exists)

Œª&gt; :sat ‚àÉ(x : ‚Ñù)(y : ‚Ñù). x + y = 10 ‚àß x - y = 4
‚úÖ Satisfiable
   Witness: x = 7, y = 3
</code></pre>
<p><strong><code>:verify</code> vs <code>:sat</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Question</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>:verify</code></td><td>Is it always true? (‚àÄ)</td><td>Prove theorems</td></tr>
<tr><td><code>:sat</code></td><td>Does a solution exist? (‚àÉ)</td><td>Solve equations</td></tr>
</tbody>
</table>
</div>
<h2 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h2>
<p>Lambda expressions work at the prompt:</p>
<pre><code>Œª&gt; Œª x . x * 2
Œª x . times(x, 2)

Œª&gt; Œª x y . x + y
Œª x y . x + y
</code></pre>
<h2 id="type-inference-1"><a class="header" href="#type-inference-1">Type Inference</a></h2>
<p>Check types with <code>:type</code>:</p>
<pre><code>Œª&gt; :type 42
üìê Type: Int

Œª&gt; :type 3.14
üìê Type: Scalar

Œª&gt; :type sin
üìê Type: Œ±0
</code></pre>
<blockquote>
<p><strong>Note:</strong> Integer literals (<code>42</code>) type as <code>Int</code>, real literals (<code>3.14</code>) type as <code>Scalar</code>. This enables proper type promotion (e.g., <code>Int + Rational ‚Üí Rational</code>).</p>
</blockquote>
<h2 id="concrete-evaluation-with-eval"><a class="header" href="#concrete-evaluation-with-eval">Concrete Evaluation with <code>:eval</code></a></h2>
<p>The <code>:eval</code> command performs <strong>concrete evaluation</strong> ‚Äî it actually computes results, including recursive functions:</p>
<pre><code>Œª&gt; :load examples/meta-programming/lisp_parser.kleis
‚úÖ Loaded: 60 functions

Œª&gt; :eval run("(+ 2 3)")
VNum(5)

Œª&gt; :eval run("(letrec ((fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))) (fact 5))")
VNum(120)
</code></pre>
<p><strong><code>:eval</code> vs <code>:sat</code> vs <code>:verify</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Execution</th><th>Handles Recursion</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>:eval</code></td><td><strong>Concrete</strong> (Rust)</td><td>‚úÖ Yes</td><td>Compute actual values</td></tr>
<tr><td><code>:sat</code></td><td>Symbolic (Z3)</td><td>‚ùå No (may timeout)</td><td>Find solutions</td></tr>
<tr><td><code>:verify</code></td><td>Symbolic (Z3)</td><td>‚ùå No (may timeout)</td><td>Prove theorems</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Key insight:</strong> Z3 cannot symbolically unroll recursive functions over unbounded data types. Use <code>:eval</code> for concrete computation, <code>:sat</code>/<code>:verify</code> for symbolic reasoning.</p>
</blockquote>
<p>This is what makes Kleis <strong>Turing complete</strong> ‚Äî the combination of ADTs, pattern matching, recursion, and concrete evaluation enables arbitrary computation. See <a href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter</a> for a complete example.</p>
<h2 id="the-verification-gap-important"><a class="header" href="#the-verification-gap-important">The Verification Gap (Important!)</a></h2>
<p><strong>Users must understand this fundamental limitation.</strong></p>
<p>The three REPL modes operate on <strong>different systems</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Executes On</th><th>Axiom Checking</th></tr>
</thead>
<tbody>
<tr><td><code>:eval</code></td><td>Rust builtins / pattern matching</td><td>‚ùå None</td></tr>
<tr><td><code>:verify</code></td><td>Z3‚Äôs mathematical model</td><td>‚úÖ Symbolic</td></tr>
<tr><td><code>:sat</code></td><td>Z3‚Äôs mathematical model</td><td>‚úÖ Symbolic</td></tr>
</tbody>
</table>
</div>
<p><strong>The gap:</strong></p>
<p>When you run <code>:verify ‚àÄ(a b : ‚Ñï). a + b = b + a</code>, Z3 proves this using its built-in integer arithmetic theory.</p>
<p>When you run <code>:eval 2 + 3</code>, Rust‚Äôs <code>+</code> operator computes <code>5</code>.</p>
<p><strong>We never verify that Rust‚Äôs <code>+</code> matches Z3‚Äôs <code>+</code>.</strong></p>
<p><strong>The Trusted Computing Base:</strong></p>
<p>These components are assumed correct, never verified:</p>
<ul>
<li>Rust compiler</li>
<li>Builtin implementations (<code>builtin_add</code>, <code>builtin_mul</code>, etc.)</li>
<li>LAPACK (for matrix operations)</li>
<li>IEEE 754 floating point</li>
</ul>
<p><strong>What Kleis provides:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Capability</th><th>Provided?</th></tr>
</thead>
<tbody>
<tr><td>Verify mathematical properties symbolically</td><td>‚úÖ Yes</td></tr>
<tr><td>Compute concrete results efficiently</td><td>‚úÖ Yes</td></tr>
<tr><td>Prove computation matches specification</td><td>‚ùå No</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-kleis">structure AdditiveMonoid(M) {
    operation add : M ‚Üí M ‚Üí M
    axiom add_comm: ‚àÄ(a b : M). add(a, b) = add(b, a)
}

implements AdditiveMonoid(‚Ñï) {
    operation add = builtin_add  // Rust's + operator
}
</code></pre>
<ul>
<li><code>:verify add_comm</code> ‚Üí Z3 checks its integer model ‚úÖ</li>
<li><code>:eval 2 + 3</code> ‚Üí Rust‚Äôs <code>builtin_add</code> runs ‚úÖ</li>
<li>Connection between them ‚Üí <strong>Trusted, not verified</strong> ‚ö†Ô∏è</li>
</ul>
<p>This is the pragmatic trade-off Kleis makes: trust the implementation, verify the mathematics.</p>
<h2 id="value-bindings-with-let"><a class="header" href="#value-bindings-with-let">Value Bindings with <code>:let</code></a></h2>
<p>Use <code>:let</code> to bind values to names that persist across REPL commands:</p>
<pre><code>Œª&gt; :let x = 2 + 3
x = 5

Œª&gt; :eval x * 2
‚úÖ 10

Œª&gt; :let matrix = Matrix(2, 2, [1, 2, 3, 4])
matrix = Matrix(2, 2, [1, 2, 3, 4])

Œª&gt; :eval det(matrix)
‚úÖ -2
</code></pre>
<p><strong><code>:let</code> vs <code>:define</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Creates</th><th>Persistence</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>:let x = expr</code></td><td><strong>Value binding</strong></td><td>REPL session</td><td>Store computed values</td></tr>
<tr><td><code>:define f(x) = expr</code></td><td><strong>Function</strong></td><td>REPL session</td><td>Define reusable functions</td></tr>
</tbody>
</table>
</div>
<h2 id="the-it-magic-variable"><a class="header" href="#the-it-magic-variable">The <code>it</code> Magic Variable</a></h2>
<p>After each <code>:eval</code>, the result is stored in <code>it</code> for quick chaining:</p>
<pre><code>Œª&gt; :eval 2 + 3
‚úÖ 5

Œª&gt; :eval it * 2
‚úÖ 10

Œª&gt; :eval it + 1
‚úÖ 11
</code></pre>
<p>This is inspired by GHCi and OCaml REPLs. Use <code>:env</code> to see all bindings including <code>it</code>:</p>
<pre><code>Œª&gt; :env
üìå Value bindings:
  x = 5

üìç Last result (it):
  it = 11

üìã Defined functions:
  double (x) = ...
</code></pre>
<h2 id="repl-commands"><a class="header" href="#repl-commands">REPL Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>:help</code></td><td>Show all commands</td></tr>
<tr><td><code>:load &lt;file&gt;</code></td><td>Load a .kleis file</td></tr>
<tr><td><code>:env</code></td><td>Show defined functions and bindings</td></tr>
<tr><td><code>:eval &lt;expr&gt;</code></td><td><strong>Concrete evaluation</strong> (computes actual values)</td></tr>
<tr><td><code>:let x = &lt;expr&gt;</code></td><td>Bind value to variable (persists in session)</td></tr>
<tr><td><code>:define f(x) = &lt;expr&gt;</code></td><td>Define a function</td></tr>
<tr><td><code>:verify &lt;expr&gt;</code></td><td>Verify with Z3 (is it always true?)</td></tr>
<tr><td><code>:sat &lt;expr&gt;</code></td><td>Check satisfiability (does a solution exist?)</td></tr>
<tr><td><code>:type &lt;expr&gt;</code></td><td>Show inferred type</td></tr>
<tr><td><code>:ast &lt;expr&gt;</code></td><td>Show parsed AST</td></tr>
<tr><td><code>:symbols</code></td><td>Unicode math symbols palette</td></tr>
<tr><td><code>:syntax</code></td><td>Complete syntax reference</td></tr>
<tr><td><code>:examples</code></td><td>Show example expressions</td></tr>
<tr><td><code>:quit</code></td><td>Exit REPL</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Tip:</strong> Use <code>it</code> in any expression to refer to the last <code>:eval</code> result.</p>
</blockquote>
<h2 id="multi-line-input"><a class="header" href="#multi-line-input">Multi-line Input</a></h2>
<p>For complex expressions, end lines with <code>\</code> or use block mode:</p>
<pre><code>Œª&gt; :verify ‚àÄ(a : R, b : R). \
   (a + b) * (a - b) = a * a - b * b
‚úÖ Valid
</code></pre>
<p>Or use <code>:{ ... :}</code> for blocks:</p>
<pre><code>Œª&gt; :{
   :verify ‚àÄ(x : R, y : R, z : R).
     (x + y) + z = x + (y + z)
   :}
‚úÖ Valid
</code></pre>
<h2 id="example-session"><a class="header" href="#example-session">Example Session</a></h2>
<pre><code>Œª&gt; :load examples/authorization/zanzibar.kleis
‚úÖ Loaded: 1 files, 13 functions, 0 structures, 0 data types, 0 type aliases

Œª&gt; :env
üìã Defined functions:
  can_share (perm) = ...
  can_edit (perm) = ...
  can_delete (perm) = ...
  effective_permission (direct, group) = ...
  inherited_permission (child_perm, parent_perm) = ...
  can_comment (perm) = ...
  is_allowed (perm, action) = ...
  doc_access (doc_perm, folder_perm, action) = ...
  has_at_least (user_perm, required_perm) = ...
  can_read (perm) = ...
  multi_group_permission (perm1, perm2, perm3) = ...
  can_grant (granter_perm, grantee_perm) = ...
  can_transfer_ownership (perm) = ...

Œª&gt; :verify ‚àÄ(x : ‚Ñù). x * x ‚â• 0
‚úÖ Valid

Œª&gt; :quit
Goodbye! üëã
</code></pre>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ol>
<li>Press <strong>Ctrl+C</strong> to cancel input</li>
<li>Press <strong>Ctrl+D</strong> or type <code>:quit</code> to exit</li>
<li>Use <code>:symbols</code> to copy-paste Unicode math symbols</li>
<li>Use <code>:help &lt;topic&gt;</code> for detailed help (e.g., <code>:help quantifiers</code>)</li>
</ol>
<h2 id="whats-next-11"><a class="header" href="#whats-next-11">What‚Äôs Next?</a></h2>
<p>For a richer interactive experience with plots and visualizations:</p>
<p>‚Üí <a href="#jupyter-notebook">Jupyter Notebook</a></p>
<p>Or explore practical applications:</p>
<p>‚Üí <a href="#applications">Applications</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="jupyter-notebook"><a class="header" href="#jupyter-notebook">Jupyter Notebook</a></h1>
<p>Kleis provides Jupyter kernel support, allowing you to write and execute Kleis code in Jupyter notebooks. This is ideal for:</p>
<p><img src="images/jupyter-kleis-launcher.png" alt="JupyterLab Launcher showing Kleis kernels"></p>
<p><em>JupyterLab launcher with Kleis and Kleis Numeric kernels</em></p>
<ul>
<li><strong>Interactive exploration</strong> of mathematical concepts</li>
<li><strong>Teaching</strong> mathematical foundations</li>
<li><strong>Documenting</strong> proofs and derivations</li>
<li><strong>Numerical computation</strong> with LAPACK operations</li>
<li><strong>Publication-quality plotting</strong> with Lilaq/Typst integration</li>
</ul>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<pre><code class="language-bash">cd kleis-notebook
./start-jupyter.sh
</code></pre>
<p>This will:</p>
<ol>
<li>Create a Python virtual environment (if needed)</li>
<li>Install JupyterLab and the Kleis kernel</li>
<li>Launch JupyterLab in your browser</li>
</ol>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ol>
<li><strong>Python 3.8+</strong> with pip</li>
<li><strong>Kleis binary</strong> compiled with numerical features:</li>
</ol>
<pre><code class="language-bash">cd /path/to/kleis
export Z3_SYS_Z3_HEADER=/opt/homebrew/opt/z3/include/z3.h  # macOS Apple Silicon
cargo install --path . --features numerical
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <code>--features numerical</code> flag enables LAPACK operations for eigenvalues, SVD, matrix inversion, and more.</p>
</blockquote>
<h3 id="install-the-kernel"><a class="header" href="#install-the-kernel">Install the Kernel</a></h3>
<pre><code class="language-bash">cd kleis-notebook

# Option 1: Use the launcher script (recommended)
./start-jupyter.sh install

# Option 2: Manual installation
python3 -m venv venv
source venv/bin/activate
pip install -e .
pip install jupyterlab
python -m kleis_kernel.install
python -m kleis_kernel.install_numeric
</code></pre>
<h2 id="using-kleis-in-jupyter"><a class="header" href="#using-kleis-in-jupyter">Using Kleis in Jupyter</a></h2>
<h3 id="creating-a-notebook"><a class="header" href="#creating-a-notebook">Creating a Notebook</a></h3>
<ol>
<li>Start JupyterLab: <code>./start-jupyter.sh</code></li>
<li>Click <strong>New Notebook</strong></li>
<li>Select <strong>Kleis</strong> or <strong>Kleis Numeric</strong> kernel</li>
</ol>
<h3 id="example-defining-a-group"><a class="header" href="#example-defining-a-group">Example: Defining a Group</a></h3>
<pre><code class="language-kleis">structure Group(G) {
    operation (*) : G √ó G ‚Üí G
    element e : G
    
    axiom left_identity: ‚àÄ(a : G). e * a = a
    axiom right_identity: ‚àÄ(a : G). a * e = a
    axiom associativity: ‚àÄ(a b c : G). (a * b) * c = a * (b * c)
}
</code></pre>
<h3 id="example-testing-properties"><a class="header" href="#example-testing-properties">Example: Testing Properties</a></h3>
<pre><code class="language-kleis">example "group identity" {
    assert(e * e = e)
}
</code></pre>
<p>Output:</p>
<pre><code>‚úÖ group identity passed
</code></pre>
<h3 id="example-numerical-computation"><a class="header" href="#example-numerical-computation">Example: Numerical Computation</a></h3>
<pre><code class="language-kleis">eigenvalues([[1.0, 2.0], [3.0, 4.0]])
</code></pre>
<p>Output:</p>
<pre><code>[-0.3722813232690143, 5.372281323269014]
</code></pre>
<h2 id="repl-commands-1"><a class="header" href="#repl-commands-1">REPL Commands</a></h2>
<p>Use REPL commands directly in notebook cells:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>:type &lt;expr&gt;</code></td><td>Show inferred type</td><td><code>:type 1 + 2</code></td></tr>
<tr><td><code>:eval &lt;expr&gt;</code></td><td>Evaluate concretely</td><td><code>:eval det([[1,2],[3,4]])</code></td></tr>
<tr><td><code>:verify &lt;expr&gt;</code></td><td>Verify with Z3</td><td><code>:verify ‚àÄ(x : ‚Ñù). x + 0 = x</code></td></tr>
<tr><td><code>:ast &lt;expr&gt;</code></td><td>Show parsed AST</td><td><code>:ast sin(x)</code></td></tr>
<tr><td><code>:env</code></td><td>Show session context</td><td><code>:env</code></td></tr>
<tr><td><code>:load &lt;file&gt;</code></td><td>Load .kleis file</td><td><code>:load stdlib/prelude.kleis</code></td></tr>
</tbody>
</table>
</div>
<h2 id="jupyter-magic-commands"><a class="header" href="#jupyter-magic-commands">Jupyter Magic Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>%reset</code></td><td>Clear session context (forget all definitions)</td></tr>
<tr><td><code>%context</code></td><td>Show accumulated definitions</td></tr>
<tr><td><code>%version</code></td><td>Show Kleis and kernel versions</td></tr>
</tbody>
</table>
</div>
<h2 id="numerical-operations"><a class="header" href="#numerical-operations">Numerical Operations</a></h2>
<p>When Kleis is compiled with <code>--features numerical</code>, these LAPACK-powered operations are available:</p>
<h3 id="eigenvalue-decomposition"><a class="header" href="#eigenvalue-decomposition">Eigenvalue Decomposition</a></h3>
<pre><code class="language-kleis">// Compute eigenvalues
eigenvalues([[4.0, 2.0], [1.0, 3.0]])
// ‚Üí [5.0, 2.0]

// Full decomposition (eigenvalues + eigenvectors)
eig([[4.0, 2.0], [1.0, 3.0]])
// ‚Üí [[5.0, 2.0], [[0.894, 0.707], [-0.447, 0.707]]]
</code></pre>
<h3 id="matrix-factorizations"><a class="header" href="#matrix-factorizations">Matrix Factorizations</a></h3>
<pre><code class="language-kleis">// Singular Value Decomposition
svd([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])
// ‚Üí (U, S, Vt)

// QR Decomposition
qr([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí (Q, R)

// Cholesky Decomposition (symmetric positive definite)
cholesky([[4.0, 2.0], [2.0, 5.0]])
// ‚Üí Lower triangular L where A = L * L^T

// Schur Decomposition
schur([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí (U, T, eigenvalues)
</code></pre>
<h3 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h3>
<pre><code class="language-kleis">// Matrix inverse
inv([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí Matrix(2, 2, [-2, 1, 1.5, -0.5])

// Determinant
det([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí -2

// Solve linear system Ax = b
solve([[3.0, 1.0], [1.0, 2.0]], [9.0, 8.0])
// ‚Üí [2.0, 3.0]

// Matrix rank
rank([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
// ‚Üí 2

// Condition number
cond([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí 14.933...

// Matrix norms
norm([[1.0, 2.0], [3.0, 4.0]])
// ‚Üí Frobenius norm
</code></pre>
<h3 id="matrix-exponential"><a class="header" href="#matrix-exponential">Matrix Exponential</a></h3>
<pre><code class="language-kleis">// e^A (useful for differential equations)
expm([[0.0, 1.0], [-1.0, 0.0]])
// ‚Üí rotation matrix
</code></pre>
<h2 id="built-in-functions-reference"><a class="header" href="#built-in-functions-reference">Built-in Functions Reference</a></h2>
<blockquote>
<p><strong>Important:</strong> These functions perform <strong>concrete numeric computation</strong>. They cannot be used in symbolic contexts such as <code>structure</code> definitions, <code>axiom</code> declarations, or abstract proofs. They are designed for interactive exploration, plotting, and numerical analysis.</p>
</blockquote>
<h3 id="math-functions"><a class="header" href="#math-functions">Math Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>sin(x)</code></td><td>Sine (radians)</td><td><code>sin(3.14159)</code> ‚Üí <code>0.0</code></td></tr>
<tr><td><code>cos(x)</code></td><td>Cosine (radians)</td><td><code>cos(0)</code> ‚Üí <code>1.0</code></td></tr>
<tr><td><code>sqrt(x)</code></td><td>Square root</td><td><code>sqrt(2)</code> ‚Üí <code>1.414...</code></td></tr>
<tr><td><code>pi()</code></td><td>œÄ constant</td><td><code>pi()</code> ‚Üí <code>3.14159...</code></td></tr>
<tr><td><code>radians(deg)</code></td><td>Degrees to radians</td><td><code>radians(180)</code> ‚Üí <code>3.14159...</code></td></tr>
<tr><td><code>mod(a, b)</code></td><td>Modulo operation</td><td><code>mod(7, 3)</code> ‚Üí <code>1</code></td></tr>
</tbody>
</table>
</div>
<h3 id="sequence-generation"><a class="header" href="#sequence-generation">Sequence Generation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>range(n)</code></td><td>Integers 0 to n-1</td><td><code>range(5)</code> ‚Üí <code>[0, 1, 2, 3, 4]</code></td></tr>
<tr><td><code>range(start, end)</code></td><td>Integers start to end-1</td><td><code>range(2, 5)</code> ‚Üí <code>[2, 3, 4]</code></td></tr>
<tr><td><code>linspace(start, end)</code></td><td>50 evenly spaced values</td><td><code>linspace(0, 1)</code> ‚Üí <code>[0, 0.02, ...]</code></td></tr>
<tr><td><code>linspace(start, end, n)</code></td><td>n evenly spaced values</td><td><code>linspace(0, 1, 5)</code> ‚Üí <code>[0, 0.25, 0.5, 0.75, 1]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="random-number-generation"><a class="header" href="#random-number-generation">Random Number Generation</a></h3>
<p>These use a deterministic pseudo-random number generator (LCG) for reproducibility.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>random(n)</code></td><td>n uniform random values in [0,1]</td><td><code>random(5)</code> ‚Üí <code>[0.25, 0.08, ...]</code></td></tr>
<tr><td><code>random(n, seed)</code></td><td>With explicit seed</td><td><code>random(5, 42)</code> ‚Üí reproducible</td></tr>
<tr><td><code>random_normal(n)</code></td><td>n values from N(0,1)</td><td><code>random_normal(5)</code></td></tr>
<tr><td><code>random_normal(n, seed)</code></td><td>With explicit seed</td><td><code>random_normal(5, 33)</code></td></tr>
<tr><td><code>random_normal(n, seed, scale)</code></td><td>N(0, scale)</td><td><code>random_normal(50, 33, 0.1)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="vector-operations"><a class="header" href="#vector-operations">Vector Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>vec_add(a, b)</code></td><td>Element-wise addition</td><td><code>vec_add([1,2,3], [4,5,6])</code> ‚Üí <code>[5, 7, 9]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="list-manipulation"><a class="header" href="#list-manipulation">List Manipulation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>list_map(f, xs)</code></td><td>Apply f to each element</td><td><code>list_map(Œª x . x*2, [1,2,3])</code> ‚Üí <code>[2, 4, 6]</code></td></tr>
<tr><td><code>list_filter(p, xs)</code></td><td>Keep elements where p(x) is true</td><td><code>list_filter(Œª x . x &gt; 1, [1,2,3])</code> ‚Üí <code>[2, 3]</code></td></tr>
<tr><td><code>list_fold(f, init, xs)</code></td><td>Left fold/reduce</td><td><code>list_fold(Œª a b . a + b, 0, [1,2,3])</code> ‚Üí <code>6</code></td></tr>
<tr><td><code>list_zip(xs, ys)</code></td><td>Pair corresponding elements</td><td><code>list_zip([1,2], ["a","b"])</code> ‚Üí <code>[Pair(1,"a"), ...]</code></td></tr>
<tr><td><code>list_nth(xs, i)</code></td><td>Element at index i (0-based)</td><td><code>list_nth([10,20,30], 1)</code> ‚Üí <code>20</code></td></tr>
<tr><td><code>list_length(xs)</code></td><td>Number of elements</td><td><code>list_length([1,2,3])</code> ‚Üí <code>3</code></td></tr>
<tr><td><code>list_concat(xs, ys)</code></td><td>Concatenate two lists</td><td><code>list_concat([1,2], [3,4])</code> ‚Üí <code>[1, 2, 3, 4]</code></td></tr>
<tr><td><code>list_flatten(xss)</code></td><td>Flatten nested lists</td><td><code>list_flatten([[1,2], [3,4]])</code> ‚Üí <code>[1, 2, 3, 4]</code></td></tr>
<tr><td><code>list_slice(xs, start, end)</code></td><td>Sublist [start, end)</td><td><code>list_slice([0,1,2,3,4], 1, 3)</code> ‚Üí <code>[1, 2]</code></td></tr>
<tr><td><code>list_rotate(xs, n)</code></td><td>Rotate left by n</td><td><code>list_rotate([1,2,3,4], 1)</code> ‚Üí <code>[2, 3, 4, 1]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="pair-operations"><a class="header" href="#pair-operations">Pair Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>Pair(a, b)</code></td><td>Create a pair/tuple</td><td><code>Pair(1, "x")</code></td></tr>
<tr><td><code>fst(p)</code></td><td>First element of pair</td><td><code>fst(Pair(1, 2))</code> ‚Üí <code>1</code></td></tr>
<tr><td><code>snd(p)</code></td><td>Second element of pair</td><td><code>snd(Pair(1, 2))</code> ‚Üí <code>2</code></td></tr>
</tbody>
</table>
</div>
<h3 id="why-numeric-only"><a class="header" href="#why-numeric-only">Why Numeric-Only?</a></h3>
<p>These functions are implemented in Rust for performance and produce concrete values:</p>
<pre><code class="language-kleis">// ‚úÖ Works: Concrete computation
let xs = linspace(0, 6.28, 10)
let ys = list_map(Œª x . sin(x), xs)
diagram(plot(xs, ys))

// ‚ùå Does NOT work: Cannot use in axioms
structure MyStructure(T) {
    axiom bad: sin(x) = cos(x - pi()/2)  // ERROR: sin/cos/pi are numeric
}
</code></pre>
<p>For symbolic mathematics, define your own abstract operations:</p>
<pre><code class="language-kleis">// ‚úÖ Correct: Define sin symbolically
structure Trigonometry(T) {
    operation sin : T ‚Üí T
    operation cos : T ‚Üí T
    constant œÄ : T
    
    axiom shift: ‚àÄ(x : T). sin(x) = cos(x - œÄ/2)
}
</code></pre>
<h2 id="matrix-syntax"><a class="header" href="#matrix-syntax">Matrix Syntax</a></h2>
<p>Matrices can be specified using nested list syntax:</p>
<pre><code class="language-kleis">// 2√ó2 matrix (row-major order)
[[1, 2], [3, 4]]

// 3√ó3 identity matrix concept
[[1, 0, 0], [0, 1, 0], [0, 0, 1]]

// Column vector as 3√ó1 matrix
[[1], [2], [3]]

// Row vector as 1√ó3 matrix
[[1, 2, 3]]
</code></pre>
<h2 id="session-persistence"><a class="header" href="#session-persistence">Session Persistence</a></h2>
<p>Definitions persist across cells within a session:</p>
<p><strong>Cell 1:</strong></p>
<pre><code class="language-kleis">define square(x) = x * x
</code></pre>
<p><strong>Cell 2:</strong></p>
<pre><code class="language-kleis">example "use square" {
    assert(square(3) = 9)
}
</code></pre>
<p>Output:</p>
<pre><code>‚úÖ use square passed
</code></pre>
<p>Use <code>%reset</code> to clear all definitions and start fresh.</p>
<h2 id="tips-for-effective-notebooks"><a class="header" href="#tips-for-effective-notebooks">Tips for Effective Notebooks</a></h2>
<ol>
<li><strong>Start with imports and definitions</strong> at the top</li>
<li><strong>Use example blocks</strong> for testable assertions</li>
<li><strong>Use <code>:eval</code></strong> for quick numerical calculations</li>
<li><strong>Use <code>:verify</code></strong> for Z3-backed proofs</li>
<li><strong>Document with markdown cells</strong> between code</li>
<li><strong>Save frequently</strong> - Kleis notebooks are standard <code>.ipynb</code> files</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="kleis-binary-not-found"><a class="header" href="#kleis-binary-not-found">‚Äúkleis binary not found‚Äù</a></h3>
<p>Install Kleis with:</p>
<pre><code class="language-bash">cd /path/to/kleis
export Z3_SYS_Z3_HEADER=/opt/homebrew/opt/z3/include/z3.h
cargo install --path . --features numerical
</code></pre>
<h3 id="numerical-operations-return-symbolic-expressions"><a class="header" href="#numerical-operations-return-symbolic-expressions">Numerical operations return symbolic expressions</a></h3>
<p>Make sure Kleis was compiled with <code>--features numerical</code>:</p>
<pre><code class="language-bash">cargo install --path . --features numerical
</code></pre>
<h3 id="kernel-dies-unexpectedly"><a class="header" href="#kernel-dies-unexpectedly">Kernel dies unexpectedly</a></h3>
<p>Check the terminal for error messages. Common causes:</p>
<ul>
<li>Z3 timeout on complex verification</li>
<li>Memory issues with large matrices</li>
</ul>
<h3 id="imports-fail-stdlib-not-found"><a class="header" href="#imports-fail-stdlib-not-found">Imports fail (stdlib not found)</a></h3>
<p>When running Jupyter from a directory other than the Kleis project root, stdlib imports may fail:</p>
<pre><code>Error: Cannot find file: stdlib/prelude.kleis
</code></pre>
<p><strong>Solution:</strong> Set the <code>KLEIS_ROOT</code> environment variable to point to your Kleis installation:</p>
<pre><code class="language-bash">export KLEIS_ROOT=/path/to/kleis
jupyter lab
</code></pre>
<p>Or add it to your shell profile (<code>~/.bashrc</code>, <code>~/.zshrc</code>):</p>
<pre><code class="language-bash">export KLEIS_ROOT="$HOME/git/cee/kleis"
</code></pre>
<p>The Kleis kernel automatically searches for stdlib in:</p>
<ol>
<li><code>$KLEIS_ROOT/stdlib/</code> (if KLEIS_ROOT is set)</li>
<li>Current working directory</li>
<li>Parent directories (up to 10 levels)</li>
</ol>
<h3 id="unicode-input"><a class="header" href="#unicode-input">Unicode input</a></h3>
<p>Use standard Kleis Unicode shortcuts:</p>
<ul>
<li><code>\forall</code> ‚Üí <code>‚àÄ</code></li>
<li><code>\exists</code> ‚Üí <code>‚àÉ</code></li>
<li><code>\in</code> ‚Üí <code>‚àà</code></li>
<li><code>\R</code> ‚Üí <code>‚Ñù</code></li>
<li><code>\N</code> ‚Üí <code>‚Ñï</code></li>
<li><code>\Z</code> ‚Üí <code>‚Ñ§</code></li>
</ul>
<h2 id="example-notebook"><a class="header" href="#example-notebook">Example Notebook</a></h2>
<p>Here‚Äôs a complete example exploring matrix properties:</p>
<p><strong>Cell 1: Setup</strong></p>
<pre><code class="language-kleis">// Define a 2√ó2 matrix
let A = [[1.0, 2.0], [3.0, 4.0]]
</code></pre>
<p><strong>Cell 2: Basic properties</strong></p>
<pre><code class="language-kleis">det(A)        // ‚Üí -2
trace(A)      // ‚Üí 5 (not yet implemented, use 1+4)
</code></pre>
<p><strong>Cell 3: Eigenvalues</strong></p>
<pre><code class="language-kleis">eigenvalues(A)
// ‚Üí [-0.372..., 5.372...]
</code></pre>
<p><strong>Cell 4: Verify Cayley-Hamilton</strong></p>
<pre><code class="language-kleis">// A matrix satisfies its characteristic polynomial
// For 2√ó2: A¬≤ - trace(A)*A + det(A)*I = 0
// This is verified numerically by the eigenvalue product
</code></pre>
<p><strong>Cell 5: Matrix inverse</strong></p>
<pre><code class="language-kleis">let Ainv = inv(A)
// Verify: A * Ainv should be identity
// (Matrix multiplication coming soon!)
</code></pre>
<h2 id="plotting"><a class="header" href="#plotting">Plotting</a></h2>
<p>Kleis integrates with <strong>Lilaq</strong> (Typst‚Äôs plotting library) to generate publication-quality plots directly in Jupyter notebooks. The API mirrors Lilaq‚Äôs compositional design, making it easy to create complex visualizations.</p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<ul>
<li><strong>Typst CLI</strong> must be installed: <code>brew install typst</code> (macOS) or see <a href="https://typst.app">typst.app</a></li>
<li>Lilaq 0.5.0+ is automatically imported</li>
</ul>
<h3 id="compositional-api"><a class="header" href="#compositional-api">Compositional API</a></h3>
<p>Kleis uses a compositional plotting API where:</p>
<ul>
<li>Individual functions (<code>plot</code>, <code>scatter</code>, <code>bar</code>, etc.) create <strong>PlotElement</strong> objects</li>
<li>The <code>diagram()</code> function combines elements and renders to SVG</li>
<li>Named arguments (<code>key = value</code>) configure options</li>
</ul>
<pre><code class="language-kleis">diagram(
    plot(xs, ys, color = "blue"),
    scatter(xs, ys, mark = "s"),
    bar(xs, heights, label = "Data"),
    title = "My Chart",
    xlabel = "X-axis",
    theme = "moon"
)
</code></pre>
<h3 id="plot-functions"><a class="header" href="#plot-functions">Plot Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>plot(x, y, ...)</code></td><td>Line plot</td><td><code>plot([0,1,2], [0,1,4], color = "blue")</code></td></tr>
<tr><td><code>scatter(x, y, ...)</code></td><td>Scatter with colormaps</td><td><code>scatter(x, y, colors = vals, map = "turbo")</code></td></tr>
<tr><td><code>bar(x, heights, ...)</code></td><td>Vertical bars</td><td><code>bar([1,2,3], [10,25,15], label = "Data")</code></td></tr>
<tr><td><code>hbar(y, widths, ...)</code></td><td>Horizontal bars</td><td><code>hbar([1,2,3], [10,25,15])</code></td></tr>
<tr><td><code>stem(x, y)</code></td><td>Stem plot</td><td><code>stem([0,1,2], [0,1,1])</code></td></tr>
<tr><td><code>fill_between(x, y, ...)</code></td><td>Area under curve</td><td><code>fill_between(x, y1, y2 = y2)</code></td></tr>
<tr><td><code>stacked_area(x, y1, y2, ...)</code></td><td>Stacked areas</td><td><code>stacked_area(x, y1, y2, y3)</code></td></tr>
<tr><td><code>boxplot(d1, d2, ...)</code></td><td>Box and whisker</td><td><code>boxplot([1,2,3], [4,5,6])</code></td></tr>
<tr><td><code>heatmap(matrix)</code></td><td>2D color grid</td><td><code>heatmap([[1,2],[3,4]])</code></td></tr>
<tr><td><code>contour(matrix)</code></td><td>Contour lines</td><td><code>contour([[1,2],[3,4]])</code></td></tr>
<tr><td><code>path(points, ...)</code></td><td>Arbitrary polygon</td><td><code>path(pts, fill = "blue", closed = true)</code></td></tr>
<tr><td><code>place(x, y, text, ...)</code></td><td>Text annotation</td><td><code>place(1, 5, "Peak", align = "top")</code></td></tr>
<tr><td><code>yaxis(elements, ...)</code></td><td>Secondary y-axis</td><td><code>yaxis(bar(...), position = "right")</code></td></tr>
<tr><td><code>xaxis(...)</code></td><td>Secondary x-axis</td><td><code>xaxis(position = "top", functions = ...)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="data-generation-functions"><a class="header" href="#data-generation-functions">Data Generation Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>linspace(start, end, n)</code></td><td>Evenly spaced values</td><td><code>linspace(0, 6.28, 50)</code></td></tr>
<tr><td><code>range(n)</code></td><td>Integers 0 to n-1</td><td><code>range(10)</code></td></tr>
<tr><td><code>random(n, seed)</code></td><td>Uniform random [0,1]</td><td><code>random(50, 42)</code></td></tr>
<tr><td><code>random_normal(n, seed, scale)</code></td><td>Normal distribution</td><td><code>random_normal(50, 33, 0.1)</code></td></tr>
<tr><td><code>vec_add(a, b)</code></td><td>Element-wise addition</td><td><code>vec_add(xs, noise)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="example-grouped-bar-chart-with-error-bars"><a class="header" href="#example-grouped-bar-chart-with-error-bars">Example: Grouped Bar Chart with Error Bars</a></h3>
<p><img src="images/plot_grouped_bars.png" alt="Grouped bar chart"></p>
<pre><code class="language-kleis">let xs = [0, 1, 2, 3]
let ys1 = [1.35, 3, 2.1, 4]
let ys2 = [1.4, 3.3, 1.9, 4.2]
let yerr1 = [0.2, 0.3, 0.5, 0.4]
let yerr2 = [0.3, 0.3, 0.4, 0.7]

let xs_left = list_map(Œª x . x - 0.2, xs)
let xs_right = list_map(Œª x . x + 0.2, xs)

diagram(
    bar(xs, ys1, offset = -0.2, width = 0.4, label = "Left"),
    bar(xs, ys2, offset = 0.2, width = 0.4, label = "Right"),
    plot(xs_left, ys1, yerr = yerr1, color = "black", stroke = "none"),
    plot(xs_right, ys2, yerr = yerr2, color = "black", stroke = "none"),
    width = 5,
    legend_position = "left + top"
)
</code></pre>
<h3 id="example-bar-chart-with-dynamic-annotations"><a class="header" href="#example-bar-chart-with-dynamic-annotations">Example: Bar Chart with Dynamic Annotations</a></h3>
<p><img src="images/plot_bar_annotations.png" alt="Bar chart with annotations"></p>
<pre><code class="language-kleis">let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8]
let ys = [12, 51, 23, 36, 38, 15, 10, 22, 86]

// Dynamic annotations using list_map and conditionals
let annotations = list_map(Œª p . 
    let x = fst(p) in
    let y = snd(p) in
    let align = if y &gt; 12 then "top" else "bottom" in
    place(x, y, y, align = align, padding = "0.2em")
, list_zip(xs, ys))

diagram(
    bar(xs, ys),
    annotations,
    width = 9,
    xaxis_subticks = "none"
)
</code></pre>
<h3 id="example-climograph-with-twin-axes"><a class="header" href="#example-climograph-with-twin-axes">Example: Climograph with Twin Axes</a></h3>
<p><img src="images/plot_climograph.png" alt="Climograph"></p>
<pre><code class="language-kleis">let months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", 
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
let precipitation = [56, 41, 53, 42, 60, 67, 81, 62, 56, 49, 48, 54]
let temperature = [0.5, 1.4, 4.4, 9.7, 14.4, 17.8, 19.8, 19.5, 15.5, 10.4, 5.6, 2.2]
let xs = range(12)

diagram(
    yaxis(
        bar(xs, precipitation, fill = "blue.lighten(40%)", label = "Precipitation"),
        position = "right",
        axis_label = "Precipitation in mm"
    ),
    plot(xs, temperature, label = "Temperature", color = "red", stroke = "1pt", mark_size = 6),
    width = 8,
    title = "Climate of Berlin",
    ylabel = "Temperature in ¬∞C",
    xlabel = "Month",
    xaxis_ticks = months,
    xaxis_tick_rotate = -90,
    xaxis_subticks = "none"
)
</code></pre>
<h3 id="example-koch-snowflake-fractal"><a class="header" href="#example-koch-snowflake-fractal">Example: Koch Snowflake Fractal</a></h3>
<p><img src="images/plot_koch_snowflake.png" alt="Koch Snowflake"></p>
<pre><code class="language-kleis">// Complex number operations
define complex_add(c1, c2) = Pair(fst(c1) + fst(c2), snd(c1) + snd(c2))
define complex_sub(c1, c2) = Pair(fst(c1) - fst(c2), snd(c1) - snd(c2))
define complex_mul(c1, c2) = Pair(
    (fst(c1)*fst(c2)) - (snd(c1)*snd(c2)),
    (fst(c1)*snd(c2)) + (snd(c1)*fst(c2))
)

define triangle_vertex(angle) = Pair(cos(radians(angle)), sin(radians(angle)))
define base_triangle() = [triangle_vertex(90), triangle_vertex(210), triangle_vertex(330)]

define koch_edge(p1, p2) = 
    let d = complex_sub(p2, p1) in
    [p1, complex_add(p1, complex_mul(d, Pair(1/3, 0))),
     complex_add(p1, complex_mul(d, Pair(0.5, 0 - sqrt(3)/6))),
     complex_add(p1, complex_mul(d, Pair(2/3, 0)))]

define koch_iter(pts) = 
    let n = list_length(pts) in
    list_flatten(list_map(Œª i . 
        koch_edge(list_nth(pts, i), list_nth(pts, mod(i + 1, n)))
    , range(n)))

let n0 = base_triangle()
let n3 = koch_iter(koch_iter(koch_iter(n0)))  // 192 vertices

diagram(
    path(n3, fill = "blue", closed = true),
    width = 6, height = 7,
    xaxis_ticks_none = true,
    yaxis_ticks_none = true
)
</code></pre>
<h3 id="example-scatter-plot-with-colormap"><a class="header" href="#example-scatter-plot-with-colormap">Example: Scatter Plot with Colormap</a></h3>
<p><img src="images/plot_styled_scatter.png" alt="Styled scatter"></p>
<pre><code class="language-kleis">let xs = linspace(0, 12.566370614, 50)  // 0 to 4œÄ
let ys = list_map(lambda x . sin(x), xs)
let noise = random_normal(50, 33, 0.1)
let xs_noisy = vec_add(xs, noise)
let colors = random(50, 42)

diagram(
    plot(xs, ys, mark = "none"),
    scatter(xs_noisy, ys, 
        mark = "s",
        colors = colors,
        map = "turbo",
        stroke = "0.5pt + black"
    ),
    theme = "moon"
)
</code></pre>
<h3 id="example-stacked-area-chart"><a class="header" href="#example-stacked-area-chart">Example: Stacked Area Chart</a></h3>
<p><img src="images/plot_stacked_area.png" alt="Stacked area"></p>
<pre><code class="language-kleis">let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
let y1 = [0, 1, 3, 9, 5, 4, 2, 2, 1, 0]
let y2 = [5, 3, 2, 0, 1, 2, 2, 2, 3, 2]
let y3 = [0, 0, 0, 0, 1, 2, 4, 5, 5, 9]

diagram(
    stacked_area(xs, y1, y2, y3),
    theme = "moon"
)
</code></pre>
<h3 id="themes"><a class="header" href="#themes">Themes</a></h3>
<p>Kleis supports Lilaq‚Äôs built-in themes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Theme</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>schoolbook</code></td><td>Math textbook style with axes at origin</td></tr>
<tr><td><code>moon</code></td><td>Dark theme for presentations</td></tr>
<tr><td><code>ocean</code></td><td>Blue-tinted theme</td></tr>
<tr><td><code>misty</code></td><td>Soft, muted colors</td></tr>
<tr><td><code>skyline</code></td><td>Clean, modern look</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">diagram(
    plot(xs, ys),
    theme = "moon"
)
</code></pre>
<h3 id="axis-customization"><a class="header" href="#axis-customization">Axis Customization</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>xlim</code>, <code>ylim</code></td><td>Axis limits</td><td><code>xlim = [-6.28, 6.28]</code></td></tr>
<tr><td><code>xaxis_tick_unit</code></td><td>Tick spacing unit</td><td><code>xaxis_tick_unit = 3.14159</code></td></tr>
<tr><td><code>xaxis_tick_suffix</code></td><td>Tick label suffix</td><td><code>xaxis_tick_suffix = "pi"</code></td></tr>
<tr><td><code>xaxis_tick_rotate</code></td><td>Rotate labels</td><td><code>xaxis_tick_rotate = -90</code></td></tr>
<tr><td><code>xaxis_ticks_none</code></td><td>Hide ticks</td><td><code>xaxis_ticks_none = true</code></td></tr>
</tbody>
</table>
</div>
<h3 id="complete-example-notebook"><a class="header" href="#complete-example-notebook">Complete Example Notebook</a></h3>
<p><strong>Cell 1: Import stdlib</strong></p>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"
</code></pre>
<p><strong>Cell 2: Generate data with linspace</strong></p>
<pre><code class="language-kleis">let xs = linspace(0, 6.28, 50)
let ys = list_map(lambda x . sin(x), xs)
</code></pre>
<p><strong>Cell 3: Plot with theme</strong></p>
<pre><code class="language-kleis">diagram(
    plot(xs, ys, color = "blue", stroke = "2pt"),
    title = "Sine Wave",
    xlabel = "x",
    ylabel = "sin(x)",
    theme = "moon"
)
</code></pre>
<h3 id="logarithmic-scales"><a class="header" href="#logarithmic-scales">Logarithmic Scales</a></h3>
<p>For exponential or power-law data, use logarithmic scales:</p>
<pre><code class="language-kleis">// Semi-log plot (linear x, logarithmic y)
diagram(
    plot([0, 1, 2, 3, 4], [1, 10, 100, 1000, 10000]),
    title = "Exponential Growth",
    yscale = "log"   // "linear", "log", or "symlog"
)

// Log-log plot (both axes logarithmic)
diagram(
    plot([1, 10, 100, 1000], [1, 100, 10000, 1000000]),
    title = "Power Law",
    xscale = "log",
    yscale = "log"
)
</code></pre>
<p>Available scales:</p>
<ul>
<li><code>"linear"</code> - Default linear scale</li>
<li><code>"log"</code> - Logarithmic scale (base 10)</li>
<li><code>"symlog"</code> - Symmetric log (linear near 0, log elsewhere; handles negative values)</li>
</ul>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Learn to create PDFs, theses, and papers: <a href="#creating-documents-with-kleis">Document Generation</a></li>
<li>Explore the <a href="#the-repl-1">REPL chapter</a> for more interactive features</li>
<li>See <a href="#matrices">Matrices</a> for symbolic matrix operations</li>
<li>Check <a href="#z3-verification">Z3 Verification</a> for formal proofs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="creating-documents-with-kleis"><a class="header" href="#creating-documents-with-kleis">Creating Documents with Kleis</a></h1>
<p>Kleis provides a complete document generation system for creating publication-quality theses, dissertations, and papers. Unlike traditional approaches where documents are separate from code, in Kleis <strong>your document IS a program</strong>.</p>
<h2 id="the-philosophy-document--program"><a class="header" href="#the-philosophy-document--program">The Philosophy: Document = Program</a></h2>
<p>Traditional academic writing separates:</p>
<ul>
<li><strong>Code</strong> (Jupyter notebooks, Python scripts)</li>
<li><strong>Equations</strong> (LaTeX, copy-pasted)</li>
<li><strong>Plots</strong> (matplotlib, exported as images)</li>
<li><strong>Document</strong> (Word, LaTeX, Google Docs)</li>
</ul>
<p>This separation causes problems:</p>
<ul>
<li>Copy-paste errors between code and paper</li>
<li>Equations that can‚Äôt be re-edited</li>
<li>Plots that can‚Äôt be regenerated</li>
<li>No verification of mathematical claims</li>
</ul>
<p><strong>Kleis unifies everything into a single program:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               Your Document (.kleis file)                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Template Import   ‚îÇ import "stdlib/templates/mit_thesis"   ‚îÇ
‚îÇ  Metadata          ‚îÇ Title, author, date, abstract          ‚îÇ
‚îÇ  Equations         ‚îÇ MITEquation("label", "$ E = mc^2 $")   ‚îÇ
‚îÇ  Diagrams          ‚îÇ MITDiagram("fig1", "caption", code)    ‚îÇ
‚îÇ  Tables            ‚îÇ MITTable("tab1", "caption", typst)     ‚îÇ
‚îÇ  Chapters          ‚îÇ MITChapter(1, "Introduction", "...")   ‚îÇ
‚îÇ  Compile Function  ‚îÇ compile_mit_thesis(my_thesis)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚Üì
                   kleis test my_thesis.kleis
                              ‚Üì
                        Typst Output
                              ‚Üì
                   typst compile ‚Üí PDF
</code></pre>
<h2 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h2>
<h3 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h3>
<ol>
<li><strong>Kleis</strong> compiled and in PATH</li>
<li><strong>Typst</strong> for PDF generation: <code>brew install typst</code></li>
</ol>
<h3 id="your-first-document-5-minutes"><a class="header" href="#your-first-document-5-minutes">Your First Document (5 minutes)</a></h3>
<p>Create a file <code>my_paper.kleis</code>:</p>
<pre><code class="language-kleis">import "stdlib/templates/arxiv_paper.kleis"

// Define your paper
define my_paper = arxiv_paper(
    "My Amazing Research",                    // title
    ["Alice Smith", "Bob Jones"],             // authors
    ["MIT", "Stanford"],                      // affiliations
    "We present groundbreaking results...",   // abstract
    ["machine learning", "verification"],     // keywords
    [
        ArxivSection("Introduction", "We begin by..."),
        ArxivEquation("eq:main", "$ f(x) = x^2 + 1 $"),
        ArxivSection("Methods", "Our approach uses..."),
        ArxivSection("Conclusion", "We have shown...")
    ]
)

// Compile and output
example "compile" {
    let typst = compile_arxiv_paper(my_paper)
    // REQUIRED: typst_raw() makes output unquoted (no "..." around strings)
    // Without it, Typst would see quoted strings and fail to parse
    out(typst_raw(typst))
}
</code></pre>
<p>Generate PDF:</p>
<pre><code class="language-bash"># --raw-output suppresses banners (‚úÖ/‚ùå), typst_raw() in code produces unquoted output
kleis test --raw-output --example compile my_paper.kleis &gt; my_paper.typ
typst compile my_paper.typ my_paper.pdf
open my_paper.pdf
</code></pre>
<p><strong>That‚Äôs it!</strong> Your document is a Kleis program.</p>
<h3 id="emit-clean-typst-no-quotes-no-banners"><a class="header" href="#emit-clean-typst-no-quotes-no-banners">Emit clean Typst (no quotes, no banners)</a></h3>
<ul>
<li><strong>Required:</strong> Wrap your compiled document in <code>typst_raw(...)</code> before calling <code>out(...)</code>. This is what makes the output unquoted - without it, strings are printed with quotes (<code>"..."</code>) which breaks Typst parsing.</li>
<li>Use <code>table_typst_raw(...)</code> for tables so Typst code is emitted directly (no ASCII boxes).</li>
<li>Run <code>kleis test --raw-output --example &lt;compile_example&gt; your_doc.kleis</code> to suppress test banners (<code>‚úÖ</code>/<code>‚ùå</code>) and summary lines.</li>
<li>Then pipe to <code>typst compile</code>.</li>
</ul>
<p><strong>Important:</strong> The <code>--raw-output</code> flag only suppresses banners. The <code>typst_raw()</code> wrapper is what produces unquoted output suitable for Typst.</p>
<h3 id="what---raw-output-suppresses"><a class="header" href="#what---raw-output-suppresses">What <code>--raw-output</code> Suppresses</a></h3>
<p>The <code>--raw-output</code> flag suppresses all test framework output:</p>
<ul>
<li>Per-example status lines (passed/failed/skipped)</li>
<li>Error messages after failed examples</li>
<li>The summary line (‚ÄúN examples passed‚Äù or ‚ÄúN/M examples passed‚Äù)</li>
</ul>
<p>It does <strong>not</strong> suppress:</p>
<ul>
<li>Output from <code>out()</code> calls in your example blocks (this is what you want to capture)</li>
<li>Exit code 1 on failure (so CI pipelines still detect errors)</li>
</ul>
<h2 id="available-templates"><a class="header" href="#available-templates">Available Templates</a></h2>
<p>Kleis includes three professionally-styled templates:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Template</th><th>File</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><strong>MIT Thesis</strong></td><td><code>stdlib/templates/mit_thesis.kleis</code></td><td>MIT PhD dissertations</td></tr>
<tr><td><strong>UofM Rackham</strong></td><td><code>stdlib/templates/uofm_thesis.kleis</code></td><td>University of Michigan dissertations</td></tr>
<tr><td><strong>arXiv Paper</strong></td><td><code>stdlib/templates/arxiv_paper.kleis</code></td><td>arXiv preprints, conference papers</td></tr>
</tbody>
</table>
</div>
<p>Each template includes:</p>
<ul>
<li>Proper page margins and fonts per institution guidelines</li>
<li>Title page, abstract, table of contents</li>
<li>Chapter/section formatting</li>
<li>Figure, table, and equation support</li>
<li>Bibliography formatting</li>
<li>Appendices</li>
</ul>
<h3 id="template-gallery"><a class="header" href="#template-gallery">Template Gallery</a></h3>
<p><strong>MIT Thesis:</strong></p>
<p><img src="images/mit_thesis_title.png" alt="MIT Thesis Title Page"></p>
<p><strong>University of Michigan Dissertation:</strong></p>
<p><img src="images/uofm_thesis_title.png" alt="UofM Dissertation Title Page"></p>
<p><strong>arXiv Paper:</strong></p>
<p><img src="images/arxiv_paper_title.png" alt="arXiv Paper"></p>
<h2 id="mit-thesis-template"><a class="header" href="#mit-thesis-template">MIT Thesis Template</a></h2>
<p>The MIT thesis template follows the official <a href="https://libraries.mit.edu/distinctive-collections/thesis-specs/">MIT Libraries thesis specifications</a>.</p>
<h3 id="document-structure"><a class="header" href="#document-structure">Document Structure</a></h3>
<pre><code class="language-kleis">import "stdlib/templates/mit_thesis.kleis"

// Define thesis metadata
define my_thesis = mit_thesis(
    "Formal Verification of Knowledge Production Systems",  // title
    "Jane Smith",                                            // author
    "Department of EECS",                                    // department
    "May 2026",                                              // date
    PhD,                                                     // degree: SB, SM, or PhD
    "This thesis presents Kleis, a formal verification...", // abstract
    "Prof. Alice Chen",                                      // supervisor
    "Professor of Computer Science",                         // supervisor title
    "I thank my advisor...",                                 // acknowledgments
    "To my family...",                                       // dedication
    all_elements                                             // document content
)
</code></pre>
<h3 id="content-elements"><a class="header" href="#content-elements">Content Elements</a></h3>
<pre><code class="language-kleis">// Chapters
define ch1 = MITChapter(1, "Introduction", "Knowledge production relies on...")

// Sections within chapters
define sec1 = MITSection("Motivation", "The need for formal verification...")

// Subsections
define subsec1 = MITSubsection("Historical Context", "Early work in...")

// Equations
define eq_einstein = MITEquation("eq:einstein", "$ E = m c^2 $")

// Figures (with Typst code)
define fig_arch = MITFigure("fig:arch", "System architecture",
    "#rect(width: 80%, height: 3cm, fill: luma(240))[Architecture diagram]")

// Diagrams using NATIVE KLEIS data
define iterations = [1.0, 2.0, 3.0, 4.0, 5.0]
define accuracy = [10.0, 25.0, 40.0, 55.0, 70.0]
define fig_perf = MITDiagram("fig:perf", "Performance comparison",
    export_typst_fragment(plot(iterations, accuracy, mark = "o"),
        xlabel = "Iterations", ylabel = "Accuracy (%)"))

// Tables using NATIVE KLEIS data
define headers = ["Method", "Accuracy", "Runtime"]
define rows = [["Baseline", "72%", "1.2s"], ["Ours", "89%", "0.8s"]]
define tab_results = MITTable("tab:results", "Experimental results",
    table_typst_raw(headers, rows))

// References
define ref1 = MITReference("demoura2008", 
    "de Moura, L. Z3: An Efficient SMT Solver. TACAS 2008.")

// Appendices
define app_a = MITAppendix("Proofs", "Detailed proofs of theorems...")

// Acknowledgments and dedication
define ack = MITAcknowledgments("I thank my advisor...")
define ded = MITDedication("To my family...")
</code></pre>
<h3 id="complete-mit-thesis-example"><a class="header" href="#complete-mit-thesis-example">Complete MIT Thesis Example</a></h3>
<p>See the full working example: <code>examples/documents/jane_smith_thesis.kleis</code></p>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"
import "stdlib/templates/mit_thesis.kleis"

// ============================================================================
// JANE SMITH'S PHD THESIS
// ============================================================================

// Chapter 1: Introduction
define ch1 = MITChapter(1, "Introduction", 
    "Knowledge production in science relies on precise notation and rigorous 
    verification. Traditional approaches separate these concerns...")

// Key equation
define eq_einstein = MITEquation("eq:einstein", "$ E = m c^2 $")

// Performance diagram using NATIVE KLEIS data
define loc = [100.0, 500.0, 1000.0, 5000.0, 10000.0]
define kleis_time = [0.1, 0.3, 0.5, 1.2, 2.1]
define other_time = [0.2, 0.8, 2.0, 12.0, 45.0]

define fig_performance = MITDiagram("fig:perf", "Type inference performance",
    export_typst_fragment(plot(loc, kleis_time, mark = "o", label = "Kleis"),
        xlabel = "Lines of Code", ylabel = "Time (seconds)"))

// Results table using NATIVE KLEIS data
define feature_headers = ["Feature", "Kleis", "Lean", "Coq"]
define feature_rows = [
    ["SMT Integration", "‚úì", "Partial", "‚úó"],
    ["Type Inference", "‚úì", "‚úì", "‚úì"],
    ["Typst Export", "‚úì", "‚úó", "‚úó"]
]
define table_features = MITTable("tab:features", "Feature comparison",
    table_typst_raw(feature_headers, feature_rows))

// Assemble all elements in order
define all_elements = [
    ack,           // Acknowledgments (front matter)
    ded,           // Dedication (front matter)
    ch1,           // Chapter 1
    eq_einstein,
    fig_performance,
    ch2,           // Chapter 2
    table_features,
    ch3,           // Chapter 3
    ref1, ref2,    // References
    app_a          // Appendix
]

// Create the thesis
define my_thesis = mit_thesis_full(
    "Formal Verification of Knowledge Production Systems",
    "Jane Smith",
    "Department of Electrical Engineering and Computer Science",
    "May 2026",
    PhD,
    "This thesis presents Kleis, a formal verification system...",
    "Prof. Alice Chen",
    "Professor of Computer Science",
    "I thank my advisor Prof. Chen for her guidance...",
    "To my parents, who taught me to question everything.",
    all_elements
)

// Compile to Typst
example "compile_thesis" {
    let typst = compile_mit_thesis(my_thesis)
    // Emit raw Typst so there are no quotes/escapes
    out(typst_raw(typst))
}
</code></pre>
<p><strong>Running the example without banners/quotes:</strong> use the raw output mode so the Typst
stream is clean and can be piped directly to <code>typst compile</code>:</p>
<pre><code class="language-bash">./target/release/kleis test examples/documents/jane_smith_thesis.kleis &gt; /tmp/mit_thesis.typ
typst compile /tmp/mit_thesis.typ /tmp/mit_thesis.pdf
</code></pre>
<h3 id="what-the-mit-template-produces"><a class="header" href="#what-the-mit-template-produces">What the MIT Template Produces</a></h3>
<p>The compiled thesis includes:</p>
<ol>
<li><strong>Title Page</strong> - Centered title, author, department, degree, date</li>
<li><strong>Signature Page</strong> - For PhD: supervisor signature block</li>
<li><strong>Abstract</strong> - Formatted per MIT specifications</li>
<li><strong>Acknowledgments</strong> - Optional dedication to advisors, family</li>
<li><strong>Dedication</strong> - Optional short dedication</li>
<li><strong>Table of Contents</strong> - Auto-generated from chapters</li>
<li><strong>List of Figures</strong> - Auto-generated from figures</li>
<li><strong>List of Tables</strong> - Auto-generated from tables</li>
<li><strong>Chapters</strong> - Numbered chapters with sections</li>
<li><strong>References</strong> - Bibliography section</li>
<li><strong>Appendices</strong> - Lettered appendices (A, B, C‚Ä¶)</li>
</ol>
<p><strong>Table of Contents (auto-generated):</strong></p>
<p><img src="images/mit_thesis_toc.png" alt="MIT Thesis Table of Contents"></p>
<p><strong>Chapter Content with Equations and Diagrams:</strong></p>
<p><img src="images/mit_thesis_chapter.png" alt="MIT Thesis Chapter"></p>
<h2 id="university-of-michigan-rackham-template"><a class="header" href="#university-of-michigan-rackham-template">University of Michigan Rackham Template</a></h2>
<p>The UofM template follows <a href="https://rackham.umich.edu/navigating-your-degree/formatting-guidelines/">Rackham Graduate School formatting guidelines</a>.</p>
<h3 id="document-structure-1"><a class="header" href="#document-structure-1">Document Structure</a></h3>
<pre><code class="language-kleis">import "stdlib/templates/uofm_thesis.kleis"

// Committee members
define committee = [
    committee_member("Prof. Alice Chen", "Computer Science"),
    committee_member("Prof. Bob Smith", "Mathematics"),
    committee_member("Prof. Carol Davis", "Statistics")
]

// Define dissertation
define my_dissertation = umich_dissertation(
    "Deep Learning Theory and Applications",      // title
    "Alex Chen",                                  // author
    "Computer Science and Engineering",           // program
    "2026",                                       // year
    PhD,                                          // degree
    "This dissertation investigates...",          // abstract
    "Prof. Alice Chen",                           // committee chair
    "Computer Science and Engineering",           // chair affiliation
    committee,                                    // committee list
    "achen@umich.edu",                           // email
    "0000-0001-2345-6789",                       // ORCID
    "I thank the Rackham Graduate School...",    // acknowledgments
    "To my mentors...",                          // dedication
    "This work began as...",                     // preface
    all_elements                                 // content
)
</code></pre>
<h3 id="uofm-specific-features"><a class="header" href="#uofm-specific-features">UofM-Specific Features</a></h3>
<ul>
<li><strong>Double spacing</strong> throughout (Rackham requirement)</li>
<li><strong>Identifier page</strong> with ORCID and email</li>
<li><strong>Committee page</strong> with full committee list</li>
<li><strong>Preface</strong> section (optional)</li>
<li><strong>2-inch top margin</strong> on chapter openings</li>
<li><strong>Roman numerals</strong> for front matter pages</li>
</ul>
<h3 id="complete-uofm-example"><a class="header" href="#complete-uofm-example">Complete UofM Example</a></h3>
<p>See: <code>examples/documents/alex_chen_dissertation.kleis</code></p>
<p>Run the provided compile block with raw output to get Typst ready for <code>typst compile</code>:</p>
<pre><code class="language-bash">./target/release/kleis test examples/documents/alex_chen_dissertation.kleis &gt; /tmp/umich.typ
typst compile /tmp/umich.typ /tmp/umich.pdf
</code></pre>
<h2 id="arxiv-paper-template"><a class="header" href="#arxiv-paper-template">arXiv Paper Template</a></h2>
<p>The arXiv template follows common academic paper conventions for preprints.</p>
<h3 id="document-structure-2"><a class="header" href="#document-structure-2">Document Structure</a></h3>
<pre><code class="language-kleis">import "stdlib/templates/arxiv_paper.kleis"

define my_paper = arxiv_paper_full(
    "Attention Is All You Need",                          // title
    ["Ashish Vaswani", "Noam Shazeer", "Niki Parmar"],   // authors
    ["Google Brain", "Google Brain", "Google Research"], // affiliations
    "The dominant sequence transduction models...",       // abstract
    ["transformers", "attention", "neural networks"],    // keywords
    all_elements                                          // content
)
</code></pre>
<h3 id="arxiv-content-elements"><a class="header" href="#arxiv-content-elements">arXiv Content Elements</a></h3>
<pre><code class="language-kleis">// Sections (no chapters in papers)
ArxivSection("Introduction", "Recent advances in...")
ArxivSection("Related Work", "Prior work includes...")

// Equations
ArxivEquation("eq:attention", "$ \\text{Attention}(Q, K, V) = \\text{softmax}(QK^T / \\sqrt{d_k})V $")

// Algorithms (using Typst's algo package)
ArxivAlgorithm("alg:train", "Training procedure", "
#import \"@preview/algorithmic:0.1.0\"
#algorithmic.algorithm({
  algorithmic.For(cond: [epoch in 1..N])[
    algorithmic.For(cond: [batch in data])[
      Compute loss and update
    ]
  ]
})
")

// Figures, tables, diagrams (same as MIT)
ArxivFigure("fig:model", "Model architecture", "...")
define result_headers = ["Method", "Accuracy", "Runtime"]
define result_rows = [["Baseline", "72%", "1.2s"], ["Ours", "89%", "0.8s"]]
ArxivTable("tab:results", "Experimental results",
    table_typst_raw(result_headers, result_rows))
ArxivDiagram("fig:loss", "Training loss", "...")

// Acknowledgments
ArxivAcknowledgments("We thank the Google Brain team...")

// References
ArxivReference("vaswani2017", "Vaswani et al. Attention Is All You Need. NeurIPS 2017.")

// Appendices
ArxivAppendix("Implementation Details", "We used PyTorch...")
</code></pre>
<h3 id="complete-arxiv-example"><a class="header" href="#complete-arxiv-example">Complete arXiv Example</a></h3>
<p>See: <code>examples/documents/sample_arxiv_paper.kleis</code></p>
<h2 id="diagrams-and-plots"><a class="header" href="#diagrams-and-plots">Diagrams and Plots</a></h2>
<p>Kleis integrates with the <a href="https://typst.app/universe/package/lilaq">Lilaq</a> plotting library for creating beautiful diagrams directly in your document.</p>
<h3 id="native-kleis-data-recommended"><a class="header" href="#native-kleis-data-recommended">Native Kleis Data (Recommended)</a></h3>
<p>The most powerful approach uses native Kleis lists with <code>export_typst_fragment()</code>:</p>
<pre><code class="language-kleis">// Define your data as Kleis lists
define epochs = [1.0, 2.0, 3.0, 4.0, 5.0]
define accuracy = [10.0, 25.0, 45.0, 70.0, 90.0]

// Create a plot using Kleis's native plot() function
define my_plot = plot(epochs, accuracy, mark = "o", label = "Training")

// Convert to Typst code for embedding in a figure
define typst_code = export_typst_fragment(my_plot,
    title = "Model Performance",
    xlabel = "Epoch",
    ylabel = "Accuracy (%)"
)

// Use in your thesis/paper
define fig_training = MITDiagram("fig:training", "Training curves", typst_code)
</code></pre>
<p><strong>Note:</strong> When piping to <code>typst</code>:</p>
<ol>
<li>Use <code>--raw-output</code> to suppress test banners (<code>‚úÖ</code>/<code>‚ùå</code>)</li>
<li>Use <code>--example compile</code> to run only the compile example</li>
<li>Ensure your example uses <code>out(typst_raw(...))</code> for unquoted output</li>
</ol>
<pre><code class="language-bash">./target/release/kleis test --raw-output --example compile examples/documents/sample_arxiv_paper.kleis &gt; /tmp/paper.typ
typst compile /tmp/paper.typ /tmp/paper.pdf
</code></pre>
<p><strong>Why use native data?</strong></p>
<ul>
<li>Your data is Kleis‚Äîit can be computed, verified, and reused</li>
<li>No manual Typst syntax errors</li>
<li>Data can flow from experiments to figures seamlessly</li>
<li>Easier to update when results change</li>
</ul>
<h3 id="available-plot-functions"><a class="header" href="#available-plot-functions">Available Plot Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>plot(xs, ys)</code></td><td>Line plot</td></tr>
<tr><td><code>scatter(xs, ys)</code></td><td>Scatter plot</td></tr>
<tr><td><code>bar(xs, heights)</code></td><td>Vertical bar chart</td></tr>
<tr><td><code>hbar(xs, widths)</code></td><td>Horizontal bar chart</td></tr>
</tbody>
</table>
</div>
<p>Each function accepts optional parameters: <code>label</code>, <code>mark</code>, <code>stroke</code>, etc.</p>
<h3 id="example-complete-workflow"><a class="header" href="#example-complete-workflow">Example: Complete Workflow</a></h3>
<pre><code class="language-kleis">// Raw experimental data
define x_data = [0.1, 0.5, 1.0, 5.0, 10.0, 25.0]
define method_a = [150.0, 120.0, 100.0, 80.0, 60.0, 40.0]
define method_b = [180.0, 140.0, 110.0, 85.0, 65.0, 45.0]

// Create plots
define plot_a = plot(x_data, method_a, mark = "o", label = "Method A")
define plot_b = plot(x_data, method_b, mark = "x", label = "Method B")

// Combine into diagram
define comparison_typst = export_typst_fragment(plot_a,
    title = "Performance Comparison",
    xlabel = "Problem Size",
    ylabel = "Time (ms)"
)

// Embed in thesis
define fig_comparison = MITDiagram("fig:comparison",
    "Performance comparison between methods",
    comparison_typst
)
</code></pre>
<h3 id="fallback-raw-typst-strings"><a class="header" href="#fallback-raw-typst-strings">Fallback: Raw Typst Strings</a></h3>
<p>For complex diagrams not yet supported by native functions, you can use raw Typst strings:</p>
<pre><code class="language-kleis">define fig_complex = MITDiagram("fig:complex", "Complex diagram", "
import \"@preview/lilaq:0.5.0\" as lq
lq.diagram(
    lq.plot((1, 2, 3, 4), (10, 20, 35, 50), stroke: blue, mark: \"o\"),
    lq.plot((1, 2, 3, 4), (15, 30, 42, 55), stroke: red, mark: \"x\"),
    xlabel: \"Iteration\",
    ylabel: \"Value\"
)")
</code></pre>
<h2 id="tables"><a class="header" href="#tables">Tables</a></h2>
<h3 id="native-kleis-data-with-table_typst_raw-recommended"><a class="header" href="#native-kleis-data-with-table_typst_raw-recommended">Native Kleis Data with <code>table_typst_raw()</code> (Recommended)</a></h3>
<p>The cleanest approach uses Kleis lists with <code>table_typst_raw()</code>, which emits Typst directly (no quotes, no ASCII boxes):</p>
<pre><code class="language-kleis">// Define table data as Kleis lists
define headers = ["Method", "Accuracy", "F1 Score"]
define rows = [
    ["Baseline", "72.3%", "0.71"],
    ["Ours", "89.7%", "0.88"],
    ["SOTA", "87.1%", "0.86"]
]

// Generate Typst table code (raw Typst)
define table_code = table_typst_raw(headers, rows)

// Use in your thesis/paper
define tab_results = MITTable("tab:results", "Benchmark results", table_code)
</code></pre>
<p><strong>Why use <code>table_typst_raw()</code>?</strong></p>
<ul>
<li>Data as Kleis lists‚Äîcan be computed, imported, or transformed</li>
<li>No manual Typst table syntax</li>
<li>Rows can come from experiments or external data</li>
<li>Easy to add/remove rows programmatically</li>
<li>Produces clean Typst for piping to <code>typst compile</code></li>
</ul>
<h3 id="example-complete-workflow-1"><a class="header" href="#example-complete-workflow-1">Example: Complete Workflow</a></h3>
<pre><code class="language-kleis">// Data from experiments
define methods = ["CNN", "ResNet", "Transformer", "Kleis-Net"]
define accuracy = ["72.3%", "85.1%", "87.4%", "89.7%"]
define f1_scores = ["0.71", "0.84", "0.86", "0.88"]
define memory = ["128 MB", "256 MB", "512 MB", "192 MB"]

// Build table from data
define headers = ["Method", "Accuracy", "F1", "Memory"]
define rows = [
    ["CNN", "72.3%", "0.71", "128 MB"],
    ["ResNet", "85.1%", "0.84", "256 MB"],
    ["Transformer", "87.4%", "0.86", "512 MB"],
    ["Kleis-Net", "89.7%", "0.88", "192 MB"]
]

define tab_comparison = MITTable("tab:comparison",
    "Comparison of deep learning methods",
    table_typst_raw(headers, rows)
)
</code></pre>
<h3 id="fallback-raw-typst-strings-1"><a class="header" href="#fallback-raw-typst-strings-1">Fallback: Raw Typst Strings</a></h3>
<p>For styled tables, you can use raw Typst syntax:</p>
<pre><code class="language-kleis">define tab_styled = MITTable("tab:styled", "Styled table", "
#table(
    columns: 4,
    stroke: 0.5pt,
    fill: (col, row) =&gt; if row == 0 { luma(230) },
    [Feature], [Kleis], [Lean], [Coq],
    [SMT], [‚úì], [Partial], [‚úó],
    [Types], [HM], [Dependent], [Dependent]
)")
</code></pre>
<h2 id="equations"><a class="header" href="#equations">Equations</a></h2>
<p>Equations use Typst math syntax (similar to LaTeX):</p>
<pre><code class="language-kleis">// Simple equation
MITEquation("eq:simple", "$ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $")

// Multi-line equation
MITEquation("eq:multi", "$
\\nabla \\cdot E &amp;= \\frac{\\rho}{\\epsilon_0} \\
\\nabla \\cdot B &amp;= 0 \\
\\nabla \\times E &amp;= -\\frac{\\partial B}{\\partial t} \\
\\nabla \\times B &amp;= \\mu_0 J + \\mu_0 \\epsilon_0 \\frac{\\partial E}{\\partial t}
$")

// Inline math in text - just use $...$
MITSection("Methods", "A function $f: RR^n -&gt; RR^m$ maps inputs to outputs.")

// Literal dollar sign - use \$
MITSection("Cost", "The price is \\$100 per unit.")
</code></pre>
<h3 id="common-math-symbols"><a class="header" href="#common-math-symbols">Common Math Symbols</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Symbol</th><th>Typst</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Fraction</td><td><code>frac(a, b)</code></td><td>$ \frac{a}{b} $</td></tr>
<tr><td>Square root</td><td><code>sqrt(x)</code></td><td>$ \sqrt{x} $</td></tr>
<tr><td>Summation</td><td><code>sum_(i=0)^n</code></td><td>$ \sum_{i=0}^n $</td></tr>
<tr><td>Integral</td><td><code>integral_a^b</code></td><td>$ \int_a^b $</td></tr>
<tr><td>Greek</td><td><code>alpha, beta, gamma</code></td><td>Œ±, Œ≤, Œ≥</td></tr>
<tr><td>Subscript</td><td><code>x_i</code></td><td>$ x_i $</td></tr>
<tr><td>Superscript</td><td><code>x^2</code></td><td>$ x^2 $</td></tr>
<tr><td>Partial</td><td><code>partial</code></td><td>‚àÇ</td></tr>
<tr><td>Nabla</td><td><code>nabla</code></td><td>‚àá</td></tr>
</tbody>
</table>
</div>
<h3 id="-tip-use-the-equation-editor"><a class="header" href="#-tip-use-the-equation-editor">üí° Tip: Use the Equation Editor</a></h3>
<p><strong>You don‚Äôt have to type Typst syntax manually!</strong></p>
<p>The Kleis Equation Editor is a visual, WYSIWYG tool for building equations. Instead of memorizing <code>frac(a, b)</code> or <code>mat(delim: "[", ...)</code>, you:</p>
<ol>
<li><strong>Build visually</strong> ‚Äî Click buttons to create fractions, matrices, integrals</li>
<li><strong>See live preview</strong> ‚Äî The equation renders as you build (powered by Typst)</li>
<li><strong>Copy and paste</strong> ‚Äî Click ‚Äúüìã Copy Typst‚Äù and paste into your thesis</li>
</ol>
<p><img src="images/equation_editor_matrices.png" alt="Equation Editor with matrix multiplication"></p>
<p><em>The Equation Editor showing a type-checked matrix multiplication with rotation matrix. The type indicator confirms: Matrix(2, 2, Scalar).</em></p>
<p><strong>The workflow:</strong></p>
<pre><code>Visual Editor ‚Üí üìã Copy Typst ‚Üí Paste into thesis.kleis ‚Üí PDF
</code></pre>
<p><strong>Example:</strong> Building <code>let A = [1 2 3; 4 5 6] √ó R_z(Œ∏) √ó [1 0; 2 1; 2 1]</code> takes seconds visually ‚Äî versus minutes of typing and debugging Typst syntax.</p>
<blockquote>
<p><strong>Note:</strong> The Equation Editor requires <code>kleis server</code> running:</p>
<pre><code class="language-bash">kleis server
# Server running at http://localhost:3000
</code></pre>
<p>Then open <a href="http://localhost:3000">http://localhost:3000</a> in your browser. Full documentation coming in a future chapter.</p>
</blockquote>
<h2 id="generating-pdfs"><a class="header" href="#generating-pdfs">Generating PDFs</a></h2>
<h3 id="command-line"><a class="header" href="#command-line">Command Line</a></h3>
<pre><code class="language-bash"># Compile Kleis to Typst
# --raw-output: suppresses ‚úÖ/‚ùå banners
# --example compile: runs only the "compile" example block
# Your example must use out(typst_raw(...)) for unquoted output
kleis test --raw-output --example compile my_thesis.kleis &gt; my_thesis.typ

# Compile Typst to PDF  
typst compile my_thesis.typ my_thesis.pdf

# Open PDF (macOS)
open my_thesis.pdf
</code></pre>
<h3 id="one-liner"><a class="header" href="#one-liner">One-liner</a></h3>
<pre><code class="language-bash">kleis test --raw-output --example compile my_thesis.kleis &gt; my_thesis.typ &amp;&amp; typst compile my_thesis.typ &amp;&amp; open my_thesis.pdf
</code></pre>
<h3 id="from-jupyter"><a class="header" href="#from-jupyter">From Jupyter</a></h3>
<p>Jupyter is the recommended environment for writing your thesis. Here‚Äôs a complete workflow:</p>
<h4 id="cell-1-setup-and-check-templates"><a class="header" href="#cell-1-setup-and-check-templates">Cell 1: Setup and check templates</a></h4>
<pre><code class="language-python">from kleis_kernel import compile_to_pdf, compile_to_typst, list_templates, validate

# See available templates
print("Available templates:", list_templates())
# Output: ['mit_thesis', 'uofm_thesis', 'arxiv_paper']
</code></pre>
<h4 id="cell-2-validate-your-document"><a class="header" href="#cell-2-validate-your-document">Cell 2: Validate your document</a></h4>
<pre><code class="language-python"># Check for parse errors before compiling
validate("my_thesis.kleis")
# Output: ‚úì my_thesis.kleis is valid
</code></pre>
<h4 id="cell-3-generate-pdf"><a class="header" href="#cell-3-generate-pdf">Cell 3: Generate PDF</a></h4>
<pre><code class="language-python"># Compile Kleis ‚Üí Typst ‚Üí PDF
compile_to_pdf("my_thesis.kleis", "my_thesis.pdf")
# Output: ‚úì PDF created: my_thesis.pdf
</code></pre>
<h4 id="cell-4-display-in-notebook"><a class="header" href="#cell-4-display-in-notebook">Cell 4: Display in notebook</a></h4>
<pre><code class="language-python">from IPython.display import IFrame
IFrame("my_thesis.pdf", width=800, height=600)
</code></pre>
<h4 id="alternative-view-typst-output"><a class="header" href="#alternative-view-typst-output">Alternative: View Typst output</a></h4>
<pre><code class="language-python"># See the generated Typst code (useful for debugging)
typst_code = compile_to_typst("my_thesis.kleis")
print(typst_code[:500])  # First 500 chars
</code></pre>
<h3 id="complete-jupyter-workflow-example"><a class="header" href="#complete-jupyter-workflow-example">Complete Jupyter Workflow Example</a></h3>
<pre><code class="language-python"># ============================================================
# Thesis Writing Workflow in Jupyter
# ============================================================

from kleis_kernel import compile_to_pdf, validate
from IPython.display import IFrame
import os

# 1. Your thesis file (edit this in VS Code or any text editor)
THESIS_FILE = "my_thesis.kleis"

# 2. Validate before compiling
if validate(THESIS_FILE):
    
    # 3. Generate PDF
    compile_to_pdf(THESIS_FILE, "thesis_draft.pdf")
    
    # 4. Display inline
    display(IFrame("thesis_draft.pdf", width=800, height=600))
    
else:
    print("Fix the errors above, then re-run this cell")
</code></pre>
<h3 id="tips-for-jupyter-users"><a class="header" href="#tips-for-jupyter-users">Tips for Jupyter Users</a></h3>
<ol>
<li><strong>Edit <code>.kleis</code> files externally</strong> - Use VS Code with syntax highlighting</li>
<li><strong>Use Jupyter for compilation</strong> - Quick feedback loop</li>
<li><strong>Version control</strong> - Git works great with <code>.kleis</code> files (they‚Äôre plain text)</li>
<li><strong>Hot reload</strong> - Re-run the cell after editing your <code>.kleis</code> file</li>
</ol>
<h2 id="creating-custom-templates"><a class="header" href="#creating-custom-templates">Creating Custom Templates</a></h2>
<p>To create a new template (e.g., for IEEE or Nature), create a <code>.kleis</code> file:</p>
<pre><code class="language-kleis">// stdlib/templates/ieee_paper.kleis

import "stdlib/prelude.kleis"

// Template metadata
define template_name = "IEEE Paper"
define template_version = "1.0"
define template_type = "paper"

// Data types for document elements
data IEEEDocExpr = 
    IEEESection(title: String, content: String)
  | IEEEEquation(label: String, typst_code: String)
  | IEEEFigure(label: String, caption: String, typst_code: String)
  | IEEETable(label: String, caption: String, typst_code: String)
  | IEEEReference(key: String, citation: String)

// Document container
data IEEEPaper = IEEEPaper(
    title: String,
    authors: List(String),
    affiliations: List(String),
    abstract_text: String,
    keywords: List(String),
    elements: List(IEEEDocExpr)
)

// Typst styling
define typst_ieee_page_setup = "#set page(
    paper: \"us-letter\",
    margin: (top: 0.75in, bottom: 1in, left: 0.625in, right: 0.625in),
    columns: 2
)"

define typst_ieee_text_setup = "#set text(
    font: \"Times New Roman\",
    size: 10pt
)"

// ... more styling definitions ...

// Compile function
define compile_ieee_paper(paper) = 
    match paper {
        IEEEPaper(title, authors, affiliations, abstract_text, keywords, elements) =&gt;
            concat(typst_ieee_page_setup,
            concat(typst_ieee_text_setup,
            // ... assemble document ...
            ))
    }
</code></pre>
<p><strong>No Rust code changes needed!</strong> Just add the template file.</p>
<h2 id="tips-for-thesis-writing"><a class="header" href="#tips-for-thesis-writing">Tips for Thesis Writing</a></h2>
<ol>
<li><strong>Save frequently</strong> ‚Äî Your <code>.kleis</code> file is the source of truth</li>
<li><strong>Use version control</strong> ‚Äî <code>.kleis</code> files are text, perfect for git</li>
<li><strong>Label everything</strong> ‚Äî Use meaningful labels for cross-references</li>
<li><strong>Test incrementally</strong> ‚Äî Compile often to catch errors early</li>
<li><strong>Use Lilaq for plots</strong> ‚Äî Regenerable, not static images</li>
<li><strong>Store in one file</strong> ‚Äî Keep related content together</li>
</ol>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="typst-not-found"><a class="header" href="#typst-not-found">‚ÄúTypst not found‚Äù</a></h3>
<pre><code class="language-bash"># macOS
brew install typst

# Linux
curl -fsSL https://typst.app/install.sh | sh
</code></pre>
<h3 id="parse-error-in-kleis-file"><a class="header" href="#parse-error-in-kleis-file">‚ÄúParse error in .kleis file‚Äù</a></h3>
<p>Check for:</p>
<ul>
<li>Unescaped quotes in strings (use <code>\"</code>)</li>
<li>Missing commas in lists</li>
<li>Unclosed parentheses</li>
</ul>
<h3 id="figure-not-rendering"><a class="header" href="#figure-not-rendering">‚ÄúFigure not rendering‚Äù</a></h3>
<p>Ensure Lilaq import is correct in your diagram code:</p>
<pre><code class="language-typst">import "@preview/lilaq:0.5.0" as lq
</code></pre>
<h3 id="cross-reference-not-found"><a class="header" href="#cross-reference-not-found">‚ÄúCross-reference not found‚Äù</a></h3>
<p>Labels must match exactly:</p>
<pre><code class="language-kleis">MITEquation("eq:main", "...")  // Define
"See Equation @eq:main"         // Reference
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>See how documents combine with verification: <a href="#applications">Applications</a></li>
<li>See full examples in <code>examples/documents/</code></li>
<li>Explore Typst documentation: <a href="https://typst.app/docs">typst.app/docs</a></li>
<li>Learn Lilaq plotting: <a href="https://typst.app/universe/package/lilaq">Lilaq on Typst Universe</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>Kleis is designed for mathematical verification, but its power extends far beyond pure mathematics. This chapter showcases applications across multiple domains.</p>
<blockquote>
<p><strong>Note:</strong> Many examples in this chapter use <code>example</code> blocks with <code>assert</code> statements for testing and verification. See <a href="#example-blocks-v093">Example Blocks</a> for details on this syntax.</p>
</blockquote>
<h2 id="aiml-verification"><a class="header" href="#aiml-verification">AI/ML Verification</a></h2>
<p>Kleis aligns with the research agenda outlined in <strong>‚ÄúToward Verified Artificial Intelligence‚Äù</strong> (Seshia et al., Communications of the ACM, 2022) ‚Äî a seminal paper from UC Berkeley on using formal methods to verify AI systems.</p>
<h3 id="the-verified-ai-challenge"><a class="header" href="#the-verified-ai-challenge">The Verified AI Challenge</a></h3>
<p>The paper identifies five key challenges for AI verification:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Challenge</th><th>Description</th><th>Kleis Approach</th></tr>
</thead>
<tbody>
<tr><td><strong>Environment Modeling</strong></td><td>Formally specify the world</td><td><code>structure</code> with <code>axiom</code>s</td></tr>
<tr><td><strong>Specification</strong></td><td>Define ‚Äúcorrect‚Äù behavior</td><td>First-order logic assertions</td></tr>
<tr><td><strong>Computational Engines</strong></td><td>SAT/SMT solving</td><td>Z3 backend</td></tr>
<tr><td><strong>Correct-by-Construction</strong></td><td>Build verified from start</td><td>Axiom-first development</td></tr>
<tr><td><strong>Compositional Reasoning</strong></td><td>Modular proofs</td><td><code>implements</code> contracts</td></tr>
</tbody>
</table>
</div>
<h3 id="neural-network-properties"><a class="header" href="#neural-network-properties">Neural Network Properties</a></h3>
<p>Kleis can express and verify properties of neural networks:</p>
<pre><code class="language-kleis">// Robustness: Small input changes ‚Üí small output changes
structure RobustnessProperty {
    axiom local_robustness: ‚àÄ x : Input . ‚àÄ Œ¥ : Input .
        norm(Œ¥) &lt; Œµ ‚Üí 
        abs(network(x + Œ¥) - network(x)) &lt; bound
}

// Monotonicity: Larger input ‚Üí larger output (for certain features)
structure MonotonicityProperty {
    axiom monotonic_feature: ‚àÄ x1 : Input . ‚àÄ x2 : Input .
        x1.feature ‚â§ x2.feature ‚Üí 
        network(x1) ‚â§ network(x2)
}

// Safety envelope: Output always in safe region
structure SafetyProperty {
    axiom output_bounded: ‚àÄ x : Input .
        valid_input(x) ‚Üí 
        min_safe ‚â§ network(x) ‚àß network(x) ‚â§ max_safe
}
</code></pre>
<h3 id="safe-reinforcement-learning"><a class="header" href="#safe-reinforcement-learning">Safe Reinforcement Learning</a></h3>
<pre><code class="language-kleis">// Safety envelope for learning-based controllers
structure SafeController(state_dim: Nat, action_dim: Nat) {
    // Pre-computed safety region
    element safe_set : Set(State)
    
    // Learned policy
    operation policy : State ‚Üí Action
    
    // Safety invariant: policy never leaves safe set
    axiom safety_invariant: ‚àÄ s : State .
        s ‚àà safe_set ‚Üí 
        next_state(s, policy(s)) ‚àà safe_set
    
    // Backup controller for edge cases
    operation backup : State ‚Üí Action
    
    axiom backup_safe: ‚àÄ s : State .
        next_state(s, backup(s)) ‚àà safe_set
}
</code></pre>
<h3 id="compositional-verification"><a class="header" href="#compositional-verification">Compositional Verification</a></h3>
<p>The paper emphasizes <strong>assume-guarantee reasoning</strong> ‚Äî exactly what Kleis structures provide:</p>
<pre><code class="language-kleis">// Perception module contract
structure PerceptionContract {
    operation detect : Image ‚Üí List(BoundingBox)
    
    // Guarantee: no false negatives within sensor range
    axiom no_miss_close: ‚àÄ img : Image . ‚àÄ obj : Object .
        distance(obj) &lt; sensor_range ‚àß visible(obj, img) ‚Üí
        ‚àÉ box : BoundingBox . box ‚àà detect(img) ‚àß contains(box, obj)
}

// Planning module contract
structure PlanningContract {
    // Assume: perception is correct within range
    // Guarantee: plan avoids all detected obstacles
    axiom collision_free: ‚àÄ boxes : List(BoundingBox) . ‚àÄ plan : Trajectory .
        plan = plan_path(boxes) ‚Üí
        ‚àÄ t : Time . ‚àÄ box : BoundingBox . 
            box ‚àà boxes ‚Üí ¬¨intersects(plan(t), box)
}

// System-level property emerges from composition
structure SystemSafety {
    axiom no_collision: ‚àÄ img : Image .
        let boxes = PerceptionContract.detect(img) in
        let plan = PlanningContract.plan_path(boxes) in
        collision_free(plan)
}
</code></pre>
<h3 id="why-kleis-for-ai-verification"><a class="header" href="#why-kleis-for-ai-verification">Why Kleis for AI Verification?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Limitation</th><th>Kleis Advantage</th></tr>
</thead>
<tbody>
<tr><td>Testing</td><td>Samples finite cases</td><td>Proves ‚àÄ inputs</td></tr>
<tr><td>Fuzzing</td><td>Random, no guarantees</td><td>Exhaustive (for decidable)</td></tr>
<tr><td>Static analysis</td><td>Over-approximates</td><td>Precise via Z3</td></tr>
<tr><td>Runtime monitoring</td><td>Reactive only</td><td>Proactive verification</td></tr>
</tbody>
</table>
</div>
<h3 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h3>
<ul>
<li><strong>Paper</strong>: <a href="https://cacm.acm.org/research/toward-verified-artificial-intelligence/">Toward Verified Artificial Intelligence</a> (CACM 2022)</li>
<li><strong>VerifAI</strong>: Toolkit for formal AI verification (same authors)</li>
<li><strong>Scenic</strong>: Domain-specific language for scenario specification</li>
</ul>
<p>Kleis provides a <strong>general-purpose substrate</strong> for expressing the same verification concepts in a unified, mathematically rigorous framework.</p>
<hr>
<h2 id="hardware-verification"><a class="header" href="#hardware-verification">Hardware Verification</a></h2>
<p>Kleis can formally verify hardware designs using Z3‚Äôs bitvector theory. This section explains how Kleis compares to the industry-standard <strong>Universal Verification Methodology (UVM)</strong> defined in IEEE 1800.2-2020.</p>
<h3 id="kleis-vs-uvm-different-approaches-to-the-same-goal"><a class="header" href="#kleis-vs-uvm-different-approaches-to-the-same-goal">Kleis vs UVM: Different Approaches to the Same Goal</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Aspect</th><th>UVM (IEEE 1800.2)</th><th>Kleis</th></tr>
</thead>
<tbody>
<tr><td><strong>Verification method</strong></td><td>Simulation (random sampling)</td><td>Formal proof (Z3)</td></tr>
<tr><td><strong>Coverage</strong></td><td>Statistical: ‚Äúdid we test this?‚Äù</td><td>Exhaustive: ‚Äúis this state reachable?‚Äù</td></tr>
<tr><td><strong>Assertions</strong></td><td>SVA (temporal, simulation-checked)</td><td>First-order logic (mathematically proven)</td></tr>
<tr><td><strong>Language</strong></td><td>SystemVerilog class library</td><td>Native Kleis</td></tr>
<tr><td><strong>Cost</strong></td><td>Requires commercial simulators</td><td>Open source</td></tr>
</tbody>
</table>
</div>
<h3 id="what-kleis-proves"><a class="header" href="#what-kleis-proves">What Kleis Proves</a></h3>
<p>Kleis can <strong>formally prove</strong> properties for ALL possible inputs:</p>
<pre><code class="language-kleis">// Bitvector operations (maps to SystemVerilog bit[7:0])
operation bvadd : BitVec8 √ó BitVec8 ‚Üí BitVec8
operation bvxor : BitVec8 √ó BitVec8 ‚Üí BitVec8
operation bv_zero : BitVec8

// PROVE: Addition is commutative for ALL 2^16 input pairs
example "ADD is commutative" {
    assert(‚àÄ a : BitVec8 . ‚àÄ b : BitVec8 . bvadd(a, b) = bvadd(b, a))
}

// PROVE: XOR of same value always yields zero
example "XOR self is zero" {
    assert(‚àÄ a : BitVec8 . bvxor(a, a) = bv_zero)
}

// PROVE: Subtraction inverts addition
example "SUB inverts ADD" {
    assert(‚àÄ a : BitVec8 . ‚àÄ b : BitVec8 . bvsub(bvadd(a, b), b) = a)
}
</code></pre>
<p>A UVM testbench would run random tests and <strong>hope</strong> to find bugs. Kleis <strong>proves</strong> correctness mathematically.</p>
<h3 id="reachability-analysis-related-to-coverage"><a class="header" href="#reachability-analysis-related-to-coverage">Reachability Analysis (Related to Coverage)</a></h3>
<p>UVM coverage answers: ‚ÄúDid our tests exercise this state?‚Äù</p>
<p>Kleis reachability answers: ‚ÄúIs this state possible at all?‚Äù</p>
<pre><code class="language-kleis">// Can ADD ever produce zero? (Yes: 0+0, or 128+128 with overflow)
example "Zero is reachable via ADD" {
    assert(‚àÉ a : BitVec8 . ‚àÉ b : BitVec8 . bvadd(a, b) = bv_zero)
}

// Can ADD produce non-zero? (Yes: 1+0, etc.)
example "Non-zero is reachable via ADD" {
    assert(‚àÉ a : BitVec8 . ‚àÉ b : BitVec8 . bvadd(a, b) ‚â† bv_zero)
}
</code></pre>
<h3 id="kleis-complements-uvm-not-replaces-it"><a class="header" href="#kleis-complements-uvm-not-replaces-it">Kleis Complements UVM, Not Replaces It</a></h3>
<p>Kleis and UVM solve <strong>related but different problems</strong>:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    VERIFICATION WORKFLOW                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ   KLEIS (Pre-RTL)              UVM (With RTL)               ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ   ‚îÇ Define ALU     ‚îÇ           ‚îÇ Verilog ALU    ‚îÇ           ‚îÇ
‚îÇ   ‚îÇ specification  ‚îÇ    ‚Üí      ‚îÇ implementation ‚îÇ           ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ          ‚Üì                            ‚Üì                     ‚îÇ
‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ   ‚îÇ PROVE correct  ‚îÇ           ‚îÇ SIMULATE with  ‚îÇ           ‚îÇ
‚îÇ   ‚îÇ for ALL inputs ‚îÇ           ‚îÇ random tests   ‚îÇ           ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ          ‚Üì                            ‚Üì                     ‚îÇ
‚îÇ   Mathematical                 "Probably correct"           ‚îÇ
‚îÇ   certainty                    (statistical)                ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<p><strong>Use Kleis FIRST:</strong> Prove your algorithm is correct before writing HDL.</p>
<p><strong>Use UVM AFTER:</strong> Validate your Verilog/VHDL implements the algorithm correctly.</p>
<h3 id="what-uvm-has-that-kleis-doesnt"><a class="header" href="#what-uvm-has-that-kleis-doesnt">What UVM Has That Kleis Doesn‚Äôt</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>UVM Feature</th><th>Kleis Status</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>DUT connection</td><td>Not applicable</td><td>Kleis doesn‚Äôt connect to HDL</td></tr>
<tr><td>Timing/clocks</td><td>Different paradigm</td><td>Model time explicitly if needed</td></tr>
<tr><td>Sequences over time</td><td>Not needed</td><td>Kleis proves for all states</td></tr>
<tr><td>Transaction-level modeling</td><td>Can model</td><td>Use <code>data</code> types</td></tr>
<tr><td>Waveform output</td><td>Not applicable</td><td>No simulation</td></tr>
</tbody>
</table>
</div>
<h3 id="example-alu-verification"><a class="header" href="#example-alu-verification">Example: ALU Verification</a></h3>
<p>See <code>examples/hardware/alu_verification.kleis</code> for a complete example that proves:</p>
<ul>
<li>ADD/AND/OR/XOR commutativity</li>
<li>Addition associativity</li>
<li>Subtraction inverts addition</li>
<li>AND idempotence</li>
<li>XOR self produces zero</li>
<li>Additive inverse</li>
<li>Reachability of zero and non-zero results</li>
</ul>
<p>All properties are proven for <strong>all 65,536 possible 8-bit input pairs</strong> ‚Äî not sampled, but exhaustively verified.</p>
<h3 id="when-to-use-kleis-for-hardware"><a class="header" href="#when-to-use-kleis-for-hardware">When to Use Kleis for Hardware</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Kleis?</th><th>Why</th></tr>
</thead>
<tbody>
<tr><td>Algorithm correctness before RTL</td><td>Yes</td><td>Prove before you code</td></tr>
<tr><td>Property verification</td><td>Yes</td><td>Mathematical proof</td></tr>
<tr><td>Bug hunting in existing RTL</td><td>No</td><td>Use UVM/formal tools</td></tr>
<tr><td>Coverage closure</td><td>Partial</td><td>Reachability, not statistical</td></tr>
<tr><td>Integration with HDL flow</td><td>No</td><td>Standalone verification</td></tr>
</tbody>
</table>
</div>
<h2 id="business-process-modeling"><a class="header" href="#business-process-modeling">Business Process Modeling</a></h2>
<p>Model and verify business workflows with formal guarantees:</p>
<pre><code class="language-kleis">// Order-to-Cash (O2C) Business Process
// Models the complete lifecycle from order to payment

// Order lifecycle states
data OrderStatus = 
    Draft | Pending | CreditApproved | CreditDenied 
  | Allocated | Fulfilled | Shipped | Invoiced 
  | Paid | Complete | Cancelled

// Credit check decision based on utilization
define credit_check_decision(utilization) =
    if utilization &lt;= 100 then 1      // Approved
    else if utilization &lt; 125 then 2  // PendingReview
    else 0                            // Denied

// Can order be cancelled from current state?
define can_cancel(status) = match status {
    Draft =&gt; 1
  | Pending =&gt; 1
  | CreditApproved =&gt; 1
  | Allocated =&gt; 1
  | _ =&gt; 0  // Can't cancel after fulfillment
}

// INVARIANT: No shipment without credit approval
define shipment_requires_credit(order_status, credit_approved) =
    if order_status = 6 then credit_approved = 1 else true

// INVARIANT: Order completion requires full payment
define completion_requires_payment(order_status, payment_status) =
    if order_status = 9 then payment_status &gt;= 2 else true
</code></pre>
<h2 id="network-protocol-verification"><a class="header" href="#network-protocol-verification">Network Protocol Verification</a></h2>
<p>Verify protocol correctness with formal methods:</p>
<pre><code class="language-kleis">// Stop-and-Wait Protocol - Reliable Data Transfer

// Sequence numbers alternate between 0 and 1
define next_seq(seq) = if seq = 0 then 1 else 0

// ACK is valid if it matches sent sequence
define valid_ack(sent, ack) = if ack = sent then 1 else 0

// Sender advances state only on valid ACK
define sender_next_state(current_seq, ack_received) = 
    if valid_ack(current_seq, ack_received) = 1 
    then next_seq(current_seq) 
    else current_seq

// VERIFIED: Double alternation returns to original
// next_seq(next_seq(0)) = 0  ‚úì
// next_seq(next_seq(1)) = 1  ‚úì

// SAFETY: No duplicate delivery when synchronized
// LIVENESS: Progress guaranteed when channel delivers
</code></pre>
<h3 id="ipv4-packet-validation"><a class="header" href="#ipv4-packet-validation">IPv4 Packet Validation</a></h3>
<pre><code class="language-kleis">// IPv4 Header Validation (RFC 791)

// Version must be 4 for IPv4
define valid_version(v) = if v = 4 then 1 else 0

// IHL (Internet Header Length): 5-15 words
define valid_ihl(ihl) = ihl &gt;= 5 and ihl &lt;= 15

// Header length in bytes
define header_length(ihl) = ihl * 4

// Common protocols: 1=ICMP, 6=TCP, 17=UDP
define is_tcp(proto) = proto = 6
define is_udp(proto) = proto = 17

// Private address ranges
define is_private_class_a(o1) = o1 = 10
define is_private_class_c(o1, o2) = o1 = 192 and o2 = 168

// Full packet validation
define valid_packet(version, ihl, total, ttl, proto) = 
    valid_version(version) = 1 and
    valid_ihl(ihl) = 1 and
    ttl &gt; 0 and
    total &gt;= header_length(ihl)
</code></pre>
<h2 id="authorization--access-control"><a class="header" href="#authorization--access-control">Authorization &amp; Access Control</a></h2>
<p>Model Zanzibar-style relationship-based access control (like Google Drive):</p>
<pre><code class="language-kleis">// Permission Levels: 0=None, 1=Viewer, 2=Commenter, 3=Editor, 4=Owner

define has_at_least(user_perm, required_perm) = user_perm &gt;= required_perm

define can_read(perm) = has_at_least(perm, 1)
define can_edit(perm) = has_at_least(perm, 3)
define can_delete(perm) = has_at_least(perm, 4)

// Folder inheritance (like Google Drive)
define inherited_permission(child_perm, parent_perm) = 
    if child_perm &gt; 0 
    then child_perm      // Explicit permission overrides
    else parent_perm     // Inherit from parent

// Multi-group permission: take highest
define effective_permission(direct, group) = 
    if direct &gt;= group then direct else group

// Security invariant: can_edit implies can_read
// ‚àÄ p . can_edit(p) = 1 ‚Üí can_read(p) = 1
</code></pre>
<h2 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h2>
<p>Use Z3 string theory for static security analysis:</p>
<pre><code class="language-kleis">// SQL Injection Detection using String Operations

// Vulnerable pattern: string concatenation + SQL execution
// :verify and(
//   contains("SELECT * FROM users WHERE id=" + userId, "+ userId"),
//   contains(code, "executeQuery")
// )
// If Valid ‚Üí VULNERABLE!

// Safe pattern: parameterized queries
// :verify and(
//   contains(code, "PreparedStatement"),
//   not(contains(code, "+ userId +"))
// )
// If Valid ‚Üí SAFE

// XSS Detection: innerHTML with user input
// :verify and(
//   contains(code, "innerHTML"),
//   contains(code, "userData")
// )
</code></pre>
<h2 id="control-systems-engineering"><a class="header" href="#control-systems-engineering">Control Systems Engineering</a></h2>
<p>Design optimal controllers with verified stability:</p>
<pre><code class="language-kleis">// LQG Controller: Linear Quadratic Gaussian

structure LinearSystem(n: Nat, m: Nat, p: Nat) {
    element A : Matrix(n, n, ‚Ñù)   // State dynamics
    element B : Matrix(n, m, ‚Ñù)   // Input matrix
    element C : Matrix(p, n, ‚Ñù)   // Output matrix
    element W : Matrix(n, n, ‚Ñù)   // Process noise covariance
    element V : Matrix(p, p, ‚Ñù)   // Measurement noise covariance
}

// LQR: Optimal state feedback
operation lqr_gain : LQRProblem(n, m) ‚Üí Matrix(m, n, ‚Ñù)

axiom lqr_stability:
    ‚àÄ prob : LQRProblem(n, m) .
    let K = lqr_gain(prob) in
    let A_cl = prob.A - prob.B ¬∑ K in
    is_stable(A_cl)

// Kalman Filter: Optimal state estimation
operation kalman_gain : KalmanProblem(n, p) ‚Üí Matrix(n, p, ‚Ñù)

// LQG combines LQR + Kalman via Separation Principle
structure LQGController(n: Nat, m: Nat, p: Nat) {
    element K : Matrix(m, n, ‚Ñù)   // LQR gain
    element L : Matrix(n, p, ‚Ñù)   // Kalman gain
}
</code></pre>
<h2 id="dimensional-analysis-physical-units"><a class="header" href="#dimensional-analysis-physical-units">Dimensional Analysis (Physical Units)</a></h2>
<p>Prevent unit mismatch bugs at compile time - like the Mars Climate Orbiter disaster ($327M lost due to imperial/metric confusion):</p>
<pre><code class="language-kleis">// Physical dimensions as exponent tuples [Length, Mass, Time]
structure Dimension(L : ‚Ñ§, M : ‚Ñ§, T : ‚Ñ§) {
    axiom equal : ‚àÄ(d1 d2 : Dimension). 
        d1 = d2 ‚Üî (L(d1) = L(d2) ‚àß M(d1) = M(d2) ‚àß T(d1) = T(d2))
}

// Named dimensions
define Length = Dimension(1, 0, 0)
define Mass = Dimension(0, 1, 0)
define Time = Dimension(0, 0, 1)
define Velocity = Dimension(1, 0, -1)      // L¬∑T‚Åª¬π
define Force = Dimension(1, 1, -2)         // M¬∑L¬∑T‚Åª¬≤
define Energy = Dimension(2, 1, -2)        // M¬∑L¬≤¬∑T‚Åª¬≤

// Physical quantity = value + dimension
structure Quantity(value : ‚Ñù, dim : Dimension) {
    // Addition: dimensions must match
    axiom add_same_dim : ‚àÄ(q1 q2 : Quantity)(d : Dimension).
        dim(q1) = d ‚àß dim(q2) = d ‚Üí dim(q1 + q2) = d
    
    // Multiplication: dimensions compose
    axiom mul_composes : ‚àÄ(q1 q2 : Quantity).
        dim(q1 * q2) = Dimension(
            L(dim(q1)) + L(dim(q2)), 
            M(dim(q1)) + M(dim(q2)), 
            T(dim(q1)) + T(dim(q2)))
}

// Unit constructors
define meter(x : ‚Ñù) = Quantity(x, Length)
define kilogram(x : ‚Ñù) = Quantity(x, Mass)
define second(x : ‚Ñù) = Quantity(x, Time)
define newton(x : ‚Ñù) = Quantity(x, Force)

// Physics axioms verify dimensional consistency
structure Mechanics {
    // F = ma: [M¬∑L¬∑T‚Åª¬≤] = [M] √ó [L¬∑T‚Åª¬≤] ‚úì
    axiom newton_second_law : ‚àÄ(m : Quantity)(a : Quantity).
        dim(m) = Mass ‚àß dim(a) = Dimension(1, 0, -2) ‚Üí
        dim(m * a) = Force
    
    // E = ¬Ωmv¬≤: [M¬∑L¬≤¬∑T‚Åª¬≤] = [M] √ó [L¬∑T‚Åª¬π]¬≤ ‚úì
    axiom kinetic_energy : ‚àÄ(m : Quantity)(v : Quantity).
        dim(m) = Mass ‚àß dim(v) = Velocity ‚Üí
        dim(m * v * v) = Energy
}
</code></pre>
<p><strong>Type-safe physics:</strong></p>
<ul>
<li><code>meter(100) + meter(50)</code> ‚Üí <code>Quantity(150, Length)</code> ‚úì</li>
<li><code>meter(100) / second(10)</code> ‚Üí <code>Quantity(10, Velocity)</code> ‚úì</li>
<li><code>meter(100) + second(10)</code> ‚Üí ‚ùå Type error: <code>Length ‚â† Time</code></li>
</ul>
<p>See <code>examples/physics/dimensional_analysis.kleis</code> for the full example.</p>
<h2 id="differential-geometry"><a class="header" href="#differential-geometry">Differential Geometry</a></h2>
<p>Kleis excels at differential geometry calculations:</p>
<pre><code class="language-kleis">// Christoffel symbols for spherical coordinates
structure SphericalMetric {
    operation metric : (‚Ñù, ‚Ñù) ‚Üí Matrix(2, 2, ‚Ñù)
    operation christoffel : (‚Ñù, ‚Ñù) ‚Üí Tensor(1, 2)
}

implements SphericalMetric {
    // Metric tensor: ds¬≤ = r¬≤(dŒ∏¬≤ + sin¬≤Œ∏ dœÜ¬≤)
    operation metric(r, Œ∏) = Matrix [
        [r^2, 0],
        [0, r^2 * sin(Œ∏)^2]
    ]
    
    // Christoffel symbols Œì‚Å±‚±º‚Çñ
    operation christoffel(r, Œ∏) = 
        let g = metric(r, Œ∏) in
        let g_inv = inverse(g) in
        // ... compute from metric derivatives
}
</code></pre>
<h2 id="tensor-calculus"><a class="header" href="#tensor-calculus">Tensor Calculus</a></h2>
<pre><code class="language-kleis">// Einstein field equations
structure EinsteinEquations {
    // Ricci tensor
    operation ricci : Manifold ‚Üí Tensor(0, 2)
    // Scalar curvature
    operation scalar : Manifold ‚Üí ‚Ñù
    // Einstein tensor
    operation einstein : Manifold ‚Üí Tensor(0, 2)
    
    axiom einstein_tensor : ‚àÄ(M : Manifold).
        einstein(M) = ricci(M) - (scalar(M) / 2) * metric(M)
}
</code></pre>
<h2 id="symbolic-differentiation"><a class="header" href="#symbolic-differentiation">Symbolic Differentiation</a></h2>
<p>Kleis supports differentiation in two fundamentally different ways:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Approach</th><th>Function</th><th>Purpose</th><th>Runs In</th></tr>
</thead>
<tbody>
<tr><td><strong>Computational</strong></td><td><code>diff(expr, var)</code></td><td>Actually compute derivatives</td><td>Kleis Evaluator</td></tr>
<tr><td><strong>Axiomatic</strong></td><td><code>D(f, x)</code>, <code>Dt(f, x)</code></td><td>Verify derivative properties</td><td>Z3 Solver</td></tr>
</tbody>
</table>
</div>
<h3 id="computational-differentiation-diff"><a class="header" href="#computational-differentiation-diff">Computational Differentiation: <code>diff</code></a></h3>
<p>The <code>diff</code> function <strong>computes</strong> derivatives by pattern matching on expression trees. It‚Äôs implemented in pure Kleis and returns a new expression:</p>
<pre><code class="language-kleis">data Expression = 
    ENumber(value : ‚Ñù)
  | EVariable(name : String)
  | EOperation(name : String, args : List(Expression))

// Helper constructors
define num(n) = ENumber(n)
define var(x) = EVariable(x)
define e_add(a, b) = EOperation("plus", Cons(a, Cons(b, Nil)))
define e_mul(a, b) = EOperation("times", Cons(a, Cons(b, Nil)))
define e_pow(a, b) = EOperation("power", Cons(a, Cons(b, Nil)))

define diff(e, var_name) =
    match e {
        ENumber(_) =&gt; num(0)
        EVariable(name) =&gt; if str_eq(name, var_name) then num(1) else num(0)
        EOperation(op_name, args) =&gt; diff_op(op_name, args, var_name)
    }

define diff_op(op_name, args, var_name) = match op_name {
    "plus" =&gt; match args {
        Cons(f, Cons(g, Nil)) =&gt; e_add(diff(f, var_name), diff(g, var_name))
        | _ =&gt; num(0)
    }
    "times" =&gt; match args {
        Cons(f, Cons(g, Nil)) =&gt; 
            e_add(e_mul(diff(f, var_name), g), e_mul(f, diff(g, var_name)))
        | _ =&gt; num(0)
    }
    "power" =&gt; match args {
        Cons(f, Cons(ENumber(n), Nil)) =&gt; 
            e_mul(e_mul(num(n), e_pow(f, num(n - 1))), diff(f, var_name))
        | _ =&gt; num(0)
    }
    "sin" =&gt; match args {
        Cons(f, Nil) =&gt; e_mul(e_cos(f), diff(f, var_name))
        | _ =&gt; num(0)
    }
    "cos" =&gt; match args {
        Cons(f, Nil) =&gt; e_neg(e_mul(e_sin(f), diff(f, var_name)))
        | _ =&gt; num(0)
    }
    _ =&gt; num(0)
}
</code></pre>
<p><strong>Usage:</strong> Call <code>diff(e_mul(var("x"), var("x")), "x")</code> and get back an expression representing <code>2x</code>.</p>
<h3 id="axiomatic-differentiation-d-and-dt"><a class="header" href="#axiomatic-differentiation-d-and-dt">Axiomatic Differentiation: <code>D</code> and <code>Dt</code></a></h3>
<p>The <code>D</code> and <code>Dt</code> operations are declared in <code>stdlib/calculus.kleis</code> with <strong>axioms</strong> that describe derivative properties. They don‚Äôt compute anything ‚Äî Z3 uses these axioms to <strong>verify</strong> that equations involving derivatives are consistent:</p>
<pre><code class="language-kleis">// From stdlib/calculus.kleis
structure Differentiable(F) {
    operation D : F ‚Üí Variable ‚Üí F      // Partial derivative
    operation Dt : F ‚Üí Variable ‚Üí F     // Total derivative
    
    axiom D_product: ‚àÄ(f g : F, x : Variable). 
        D(f * g, x) = D(f, x) * g + f * D(g, x)
    
    axiom Dt_chain: ‚àÄ(f : F, x y : Variable). 
        Dt(f, x) = D(f, x) + D(f, y) * Dt(y, x)
}
</code></pre>
<p><strong>Usage:</strong> Write <code>D(f * g, x) = D(f, x) * g + f * D(g, x)</code> and Z3 confirms it‚Äôs valid (it matches the <code>D_product</code> axiom).</p>
<h3 id="when-to-use-each"><a class="header" href="#when-to-use-each">When to Use Each</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Task</th><th>Use</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td>Compute ‚àÇ/‚àÇx of x¬≤ + 2x</td><td><code>diff</code></td><td>Returns expression tree for 2x + 2</td></tr>
<tr><td>Verify product rule holds</td><td><code>D</code> + Z3</td><td>Returns ‚úÖ SAT</td></tr>
<tr><td>Check physics equation consistency</td><td><code>D</code> + Z3</td><td>Verifies Euler-Lagrange equations</td></tr>
<tr><td>Build a symbolic algebra system</td><td><code>diff</code></td><td>CAS-style manipulation</td></tr>
</tbody>
</table>
</div>
<p><strong>Analogy:</strong></p>
<ul>
<li><code>diff</code> is like a <strong>calculator</strong> ‚Äî it gives you answers</li>
<li><code>D</code> axioms are like <strong>mathematical theorems</strong> ‚Äî Z3 uses them to check proofs</li>
</ul>
<p>See <code>examples/calculus/derivatives.kleis</code> for more examples of both approaches.</p>
<h2 id="linear-algebra-1"><a class="header" href="#linear-algebra-1">Linear Algebra</a></h2>
<pre><code class="language-kleis">structure LinearSystem(n : ‚Ñï) {
    operation solve : Matrix(n, n, ‚Ñù) √ó Vector(n, ‚Ñù) ‚Üí Vector(n, ‚Ñù)
    
    // Solution satisfies Ax = b
    axiom solution_correct : ‚àÄ(A : Matrix(n, n, ‚Ñù))(b : Vector(n, ‚Ñù)).
        det(A) ‚â† 0 ‚Üí mul(A, solve(A, b)) = b
}

// Eigenvalue problem
structure Eigen(n : ‚Ñï) {
    operation eigenvalues : Matrix(n, n, ‚ÑÇ) ‚Üí List(‚ÑÇ)
    operation eigenvectors : Matrix(n, n, ‚ÑÇ) ‚Üí List(Vector(n, ‚ÑÇ))
    
    axiom eigenpair : ‚àÄ(A : Matrix(n, n, ‚ÑÇ))(i : ‚Ñï).
        let lam = nth(eigenvalues(A), i) in
        let v = nth(eigenvectors(A), i) in
            mul(A, v) = scale(lam, v)
}
</code></pre>
<h2 id="quantum-mechanics"><a class="header" href="#quantum-mechanics">Quantum Mechanics</a></h2>
<pre><code class="language-kleis">structure QuantumState(n : ‚Ñï) {
    operation amplitudes : Vector(n, ‚ÑÇ)
    
    // States must be normalized
    axiom normalized : ‚àÄ(psi : QuantumState(n)).
        sum(map(Œª a . abs(a)^2, amplitudes(psi))) = 1
}

structure Observable(n : ‚Ñï) {
    operation matrix : Matrix(n, n, ‚ÑÇ)
    
    // Observables are Hermitian
    axiom hermitian : ‚àÄ(O : Observable(n)).
        matrix(O) = conjugate_transpose(matrix(O))
}

// Expectation value
define expectation(psi, O) =
    real(inner_product(amplitudes(psi), mul(matrix(O), amplitudes(psi))))
</code></pre>
<h2 id="category-theory"><a class="header" href="#category-theory">Category Theory</a></h2>
<pre><code class="language-kleis">structure Category(Obj, Mor) {
    operation id : Obj ‚Üí Mor
    operation compose : Mor √ó Mor ‚Üí Mor
    operation dom : Mor ‚Üí Obj
    operation cod : Mor ‚Üí Obj
    
    axiom identity_left : ‚àÄ(f : Mor).
        compose(id(cod(f)), f) = f
        
    axiom identity_right : ‚àÄ(f : Mor).
        compose(f, id(dom(f))) = f
        
    axiom associativity : ‚àÄ(f : Mor)(g : Mor)(h : Mor).
        compose(compose(h, g), f) = compose(h, compose(g, f))
}

structure Functor(C, D) {
    operation map_obj : C ‚Üí D
    operation map_mor : C ‚Üí D
    
    axiom preserves_id : ‚àÄ(x : C).
        map_mor(id(x)) = id(map_obj(x))
        
    axiom preserves_compose : ‚àÄ(f : C)(g : C).
        map_mor(compose(g, f)) = compose(map_mor(g), map_mor(f))
}
</code></pre>
<h2 id="physics-classical-mechanics"><a class="header" href="#physics-classical-mechanics">Physics: Classical Mechanics</a></h2>
<pre><code class="language-kleis">structure LagrangianMechanics(n : ‚Ñï) {
    // Generalized coordinates and velocities
    operation q : ‚Ñï ‚Üí ‚Ñù     // Position
    operation q_dot : ‚Ñï ‚Üí ‚Ñù  // Velocity
    operation t : ‚Ñù          // Time
    
    // Lagrangian L = T - V
    operation lagrangian : ‚Ñù
    
    // Euler-Lagrange equations
    // Using Mathematica-style: Dt for total derivative, D for partial
    axiom euler_lagrange : ‚àÄ i : ‚Ñï . i &lt; n ‚Üí
        Dt(D(lagrangian, q_dot(i)), t) = D(lagrangian, q(i))
}
</code></pre>
<h2 id="language-implementation"><a class="header" href="#language-implementation">Language Implementation</a></h2>
<p>Kleis can serve as a <strong>meta-language</strong> ‚Äî a language for implementing other languages. See the complete LISP interpreter in Kleis:</p>
<pre><code>Œª&gt; :load examples/meta-programming/lisp_parser.kleis

Œª&gt; :eval run("(letrec ((fib (lambda (n) (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 10))")
‚úÖ VNum(55)

Œª&gt; :eval run("(letrec ((fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))) (fact 5))")
‚úÖ VNum(120)
</code></pre>
<p>The complete implementation (parser + evaluator) is ~560 lines of pure Kleis code.</p>
<p>‚Üí <a href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter</a> ‚Äî Full source code with explanation</p>
<h2 id="whats-next-12"><a class="header" href="#whats-next-12">What‚Äôs Next?</a></h2>
<p>Check out the reference appendices!</p>
<p>‚Üí <a href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a>
‚Üí <a href="#appendix-operators">Appendix B: Operators</a>
‚Üí <a href="#appendix-c-standard-library">Appendix C: Standard Library</a>
‚Üí <a href="#appendix-lisp-interpreter-in-kleis">Appendix D: LISP Interpreter</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-blocks-v093"><a class="header" href="#example-blocks-v093">Example Blocks (v0.93)</a></h1>
<p>Kleis v0.93 introduces <strong>example blocks</strong> ‚Äî executable documentation that serves as tests, debugging entry points, and living examples.</p>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<pre><code class="language-kleis">example "descriptive name" {
    let x = 5
    let y = double(x)
    assert(y = 10)
}
</code></pre>
<p>An example block contains:</p>
<ul>
<li><strong>Let bindings</strong> ‚Äî bind values to names</li>
<li><strong>Assert statements</strong> ‚Äî verify expected results</li>
<li><strong>Expressions</strong> ‚Äî any valid Kleis expression</li>
</ul>
<h2 id="why-example-blocks"><a class="header" href="#why-example-blocks">Why Example Blocks?</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Traditional Tests</th><th>Example Blocks</th></tr>
</thead>
<tbody>
<tr><td>Separate test files</td><td>Inline with code</td></tr>
<tr><td>Run with test runner</td><td>Run with <code>kleis test</code></td></tr>
<tr><td>Not visible in docs</td><td>Executable documentation</td></tr>
<tr><td>Hard to debug</td><td>Full DAP debugger support</td></tr>
</tbody>
</table>
</div>
<p>Example blocks serve three purposes:</p>
<ol>
<li><strong>Documentation</strong> ‚Äî Show how to use your functions</li>
<li><strong>Testing</strong> ‚Äî Verify behavior with assertions</li>
<li><strong>Debugging</strong> ‚Äî Set breakpoints and step through</li>
</ol>
<h2 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h2>
<p>Use the <code>kleis test</code> command:</p>
<pre><code class="language-bash">$ kleis test examples/math/complex_demo.kleis

‚úÖ complex arithmetic basics
‚úÖ euler's formula
‚úÖ quadratic roots

3/3 examples passed
</code></pre>
<p>Failed assertions show details:</p>
<pre><code class="language-bash">$ kleis test broken.kleis

‚ùå my test
   Assertion failed: expected Const("20"), got Const("15")

0/1 examples passed (1 failed)
</code></pre>
<h2 id="assert-statement"><a class="header" href="#assert-statement">Assert Statement</a></h2>
<p>The <code>assert</code> statement verifies a condition. Kleis distinguishes between two types:</p>
<h3 id="concrete-assertions-computation"><a class="header" href="#concrete-assertions-computation">Concrete Assertions (Computation)</a></h3>
<p>When both sides of an assertion can be <strong>fully evaluated to values</strong>, Kleis computes them directly:</p>
<pre><code class="language-kleis">example "concrete assertions" {
    // Arithmetic
    assert(1 + 2 = 3)
    
    // Transcendental functions
    assert(sin(0) = 0)
    assert(cos(0) = 1)
    assert(exp(0) = 1)
    assert(log(1) = 0)
    
    // Variables with bound values
    let x = 5
    assert(x + x = 10)
    assert(pow(x, 2) = 25)
}
</code></pre>
<p>Kleis uses <code>eval_concrete()</code> to fully evaluate both sides (including functions like <code>sin</code>, <code>cos</code>, <code>exp</code>, etc.), then compares. Floating-point comparisons use a relative tolerance of 1e-10.</p>
<p>When an assertion contains <strong>free (unbound) variables</strong>, it becomes a theorem proof using Z3:</p>
<pre><code class="language-kleis">structure CommutativeRing(R) {
    operation (+) : R √ó R ‚Üí R
    axiom commutativity: ‚àÄ(a b : R). a + b = b + a
}

example "algebraic properties" {
    // Z3 verifies this using the commutativity axiom!
    assert(x + y = y + x)
    
    // Z3 proves associativity if the axiom is defined
    assert((a + b) + c = a + (b + c))
}
</code></pre>
<p>When an assertion contains unbound variables (like <code>x</code>, <code>y</code>), Kleis:</p>
<ol>
<li>Detects the expression is symbolic</li>
<li>Loads axioms from defined structures</li>
<li>Passes the claim to Z3 for verification</li>
<li>Reports: Verified, Disproved (with counterexample), or Unknown</li>
</ol>
<pre><code class="language-kleis">example "z3 finds counterexamples" {
    // Z3 disproves this with: "Counterexample: y!1 -&gt; 1, x!0 -&gt; 0"
    // assert(x + y = y + y)  // Would fail!
}
</code></pre>
<p>This enables <strong>theorem proving</strong> in your tests:</p>
<pre><code class="language-kleis">structure Field(F) {
    operation (*) : F √ó F ‚Üí F
    operation inverse : F ‚Üí F
    
    axiom inverse_right: ‚àÄ(x : F). x * inverse(x) = 1
    axiom inverse_left: ‚àÄ(x : F). inverse(x) * x = 1
}

example "inverse properties" {
    // Z3 verifies using field axioms
    assert(a * inverse(a) = 1)
    assert(inverse(inverse(a)) = a)  // Derived property!
}
</code></pre>
<h3 id="how-kleis-chooses-concrete-vs-symbolic"><a class="header" href="#how-kleis-chooses-concrete-vs-symbolic">How Kleis Chooses: Concrete vs Symbolic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Free Variables?</th><th>Path Taken</th></tr>
</thead>
<tbody>
<tr><td><code>sin(0) = 0</code></td><td>No</td><td><code>eval_concrete()</code> ‚Üí compare</td></tr>
<tr><td><code>x + y = y + x</code></td><td>Yes (<code>x</code>, <code>y</code>)</td><td>Z3 theorem proving</td></tr>
<tr><td><code>sin(x) = 0</code></td><td>Yes (<code>x</code>)</td><td>Z3 (can‚Äôt evaluate)</td></tr>
</tbody>
</table>
</div>
<p>The decision flow:</p>
<ol>
<li>Try <code>eval_concrete()</code> on both sides</li>
<li>If both reduce to values ‚Üí compare (with floating-point tolerance)</li>
<li>If either contains free variables ‚Üí invoke Z3 with loaded axioms</li>
<li>Z3 returns: Verified, Disproved (with counterexample), or Unknown</li>
</ol>
<h2 id="example-blocks-as-entry-points"><a class="header" href="#example-blocks-as-entry-points">Example Blocks as Entry Points</a></h2>
<p>Example blocks are the <strong>entry points for debugging</strong>. Unlike function definitions which are just declarations, example blocks contain executable code:</p>
<pre><code class="language-kleis">// Function definition (not executable on its own)
define fib(n) = 
    if n &lt;= 1 then n 
    else fib(n - 1) + fib(n - 2)

// Example block (executable, can set breakpoints)
example "fibonacci test" {
    let f5 = fib(5)      // ‚Üê Set breakpoint here
    let f10 = fib(10)    // ‚Üê Or here
    assert(f5 = 5)
    assert(f10 = 55)
}
</code></pre>
<p>When debugging:</p>
<ol>
<li>Set a breakpoint on a line in an example block</li>
<li>Launch the debugger</li>
<li>Execution stops at your breakpoint</li>
<li>Step through, inspect variables, step into functions</li>
</ol>
<h2 id="cross-file-debugging"><a class="header" href="#cross-file-debugging">Cross-File Debugging</a></h2>
<p>Example blocks work with imports. When you step into a function from an imported file, the debugger opens that file:</p>
<pre><code class="language-kleis">// main.kleis
import "stdlib/complex.kleis"

example "complex math" {
    let z = complex(3, 4)
    let mag = abs(z)        // ‚Üê Step into this
    assert(mag = 5)         // Opens complex.kleis, shows abs definition
}
</code></pre>
<p>The debugger tracks source locations across files, showing you exactly where you are.</p>
<h2 id="source-location-tracking"><a class="header" href="#source-location-tracking">Source Location Tracking</a></h2>
<p>Every expression in Kleis carries its <strong>source location</strong> (line, column, file). This enables:</p>
<ul>
<li>Accurate error messages</li>
<li>Precise debugger breakpoints</li>
<li>Cross-file stepping</li>
<li>Stack traces with file paths</li>
</ul>
<p>The location travels with the expression through evaluation, so even after function application, the debugger knows the original source.</p>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-one-concept-per-example"><a class="header" href="#1-one-concept-per-example">1. One Concept Per Example</a></h3>
<pre><code class="language-kleis">// Good: focused examples
example "addition is commutative" {
    assert(2 + 3 = 3 + 2)
}

example "multiplication distributes" {
    assert(2 * (3 + 4) = 2 * 3 + 2 * 4)
}

// Bad: too much in one example
example "all arithmetic" {
    assert(2 + 3 = 3 + 2)
    assert(2 * 3 = 3 * 2)
    assert(2 * (3 + 4) = 2 * 3 + 2 * 4)
    // ... many more assertions
}
</code></pre>
<h3 id="2-descriptive-names"><a class="header" href="#2-descriptive-names">2. Descriptive Names</a></h3>
<pre><code class="language-kleis">// Good: describes what's being tested
example "negative numbers square to positive" { ... }

// Bad: vague
example "test1" { ... }
</code></pre>
<h3 id="3-use-let-bindings-for-clarity"><a class="header" href="#3-use-let-bindings-for-clarity">3. Use Let Bindings for Clarity</a></h3>
<pre><code class="language-kleis">// Good: intermediate values have names
example "quadratic formula" {
    let a = 1
    let b = -5
    let c = 6
    let discriminant = b * b - 4 * a * c
    let root1 = (-b + sqrt(discriminant)) / (2 * a)
    assert(root1 = 3)
}

// Bad: one big expression
example "quadratic formula" {
    assert((-(-5) + sqrt((-5) * (-5) - 4 * 1 * 6)) / (2 * 1) = 3)
}
</code></pre>
<h2 id="grammar-reference"><a class="header" href="#grammar-reference">Grammar Reference</a></h2>
<pre><code class="language-ebnf">exampleBlock    ::= "example" string "{" exampleBody "}"
exampleBody     ::= { exampleStatement }
exampleStatement ::= letBinding 
                   | assertStatement 
                   | expression ";"

assertStatement ::= "assert" "(" expression ")"

letBinding      ::= "let" identifier [":" type] "=" expression
</code></pre>
<h2 id="whats-next-13"><a class="header" href="#whats-next-13">What‚Äôs Next?</a></h2>
<p>Explore the functions and structures available in the standard library:</p>
<p>‚Üí <a href="#standard-library-types">Standard Library</a></p>
<p>Learn how to set up VS Code for debugging:</p>
<p>‚Üí <a href="#vs-code-debugging">Appendix: VS Code Debugging</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="standard-library-types"><a class="header" href="#standard-library-types">Standard Library Types</a></h1>
<h2 id="self-hosting-kleis-defines-kleis"><a class="header" href="#self-hosting-kleis-defines-kleis">Self-Hosting: Kleis Defines Kleis</a></h2>
<p>One of Kleis‚Äôs most elegant features is <strong>meta-circularity</strong>: the type system is defined <em>in Kleis itself</em>.</p>
<pre><code class="language-kleis">// From stdlib/types.kleis - loaded before anything else
data Type =
    Scalar
    | Vector(n: Nat, T)
    | Matrix(m: Nat, n: Nat, T)
    | Complex
    | Set(T: Type)
    | List(T: Type)
    | Tensor(dims: List(Nat))
</code></pre>
<p>This means:</p>
<ul>
<li>Types aren‚Äôt hardcoded in the Rust compiler</li>
<li>Users can extend the type system without recompiling</li>
<li>The type checker can reason about types <em>as data</em></li>
</ul>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<p>The fundamental boolean type:</p>
<pre><code class="language-kleis">data Bool = True | False
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-kleis">define not(b) = match b {
    True =&gt; False
    | False =&gt; True
}

define and(b1, b2) = match b1 {
    False =&gt; False
    | True =&gt; b2
}

define or(b1, b2) = match b1 {
    True =&gt; True
    | False =&gt; b2
}
</code></pre>
<h3 id="optiont"><a class="header" href="#optiont">Option(T)</a></h3>
<p>For values that might not exist (like Haskell‚Äôs <code>Maybe</code>):</p>
<pre><code class="language-kleis">data Option(T) =
    None
    | Some(value: T)
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-kleis">define isSome(opt) = match opt {
    None =&gt; False
    | Some(_) =&gt; True
}

define isNone(opt) = match opt {
    None =&gt; True
    | Some(_) =&gt; False
}

define getOrDefault(opt, default) = match opt {
    None =&gt; default
    | Some(x) =&gt; x
}
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-kleis">// Safe division that doesn't crash on zero
define safeDivide(a, b) =
    if b = 0 then None
    else Some(a / b)

// Use with pattern matching
define showResult(result) =
    match result {
        None =&gt; "undefined"
        Some(x) =&gt; x
    }
</code></pre>
<h3 id="resultt-e"><a class="header" href="#resultt-e">Result(T, E)</a></h3>
<p>For operations that can succeed or fail with an error (like Rust‚Äôs <code>Result</code>):</p>
<pre><code class="language-kleis">data Result(T, E) =
    Ok(value: T)
    | Err(error: E)
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-kleis">define parseNumber(s) =
    if isNumeric(s) then Ok(toNumber(s))
    else Err("not a number")

define processInput(input) =
    match parseNumber(input) {
        Ok(n) =&gt; n * 2
        Err(msg) =&gt; 0
    }
</code></pre>
<h3 id="listt"><a class="header" href="#listt">List(T)</a></h3>
<p>Recursive linked list:</p>
<pre><code class="language-kleis">data List(T) =
    Nil
    | Cons(head: T, tail: List(T))
</code></pre>
<p><strong>Operations:</strong></p>
<pre><code class="language-kleis">define isEmpty(list) = match list {
    Nil =&gt; True
    | Cons(_, _) =&gt; False
}

define head(list) = match list {
    Nil =&gt; None
    | Cons(h, _) =&gt; Some(h)
}

define tail(list) = match list {
    Nil =&gt; None
    | Cons(_, t) =&gt; Some(t)
}
</code></pre>
<p><strong>Note:</strong> For numeric computation, use the <code>[1, 2, 3]</code> list literal syntax with built-in functions like <code>list_map</code>, <code>list_filter</code>, etc. The <code>Cons</code>/<code>Nil</code> form is for symbolic reasoning and pattern matching.</p>
<h3 id="unit"><a class="header" href="#unit">Unit</a></h3>
<p>The type with only one value (like <code>void</code> in C, but safer):</p>
<pre><code class="language-kleis">data Unit = Unit
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-kleis">// A function that returns nothing meaningful
define printAndReturn(x) = Unit

// Flags without associated data
define flagSet : Option(Unit) = Some(Unit)
define flagUnset : Option(Unit) = None
</code></pre>
<h3 id="ordering"><a class="header" href="#ordering">Ordering</a></h3>
<p>For comparison results:</p>
<pre><code class="language-kleis">data Ordering = LT | EQ | GT
</code></pre>
<p><strong>Usage:</strong></p>
<pre><code class="language-kleis">define compareNumbers(a, b) =
    if a &lt; b then LT
    else if a &gt; b then GT
    else EQ
</code></pre>
<h2 id="numeric-types-1"><a class="header" href="#numeric-types-1">Numeric Types</a></h2>
<h3 id="scalar"><a class="header" href="#scalar">Scalar</a></h3>
<p>The base numeric type (real numbers ‚Ñù):</p>
<pre><code class="language-kleis">// Part of the Type data type
Scalar
</code></pre>
<h3 id="complex"><a class="header" href="#complex">Complex</a></h3>
<p>Complex numbers with real and imaginary parts:</p>
<pre><code class="language-kleis">// Part of the Type data type  
Complex
</code></pre>
<p>See <a href="#complex-numbers">Chapter 14: Complex Numbers</a> for operations.</p>
<h3 id="vectorn-t"><a class="header" href="#vectorn-t">Vector(n, T)</a></h3>
<p>Fixed-length vectors:</p>
<pre><code class="language-kleis">Vector(n: Nat, T)
</code></pre>
<p>Example: <code>Vector(3, ‚Ñù)</code> is a 3D real vector.</p>
<h3 id="matrixm-n-t"><a class="header" href="#matrixm-n-t">Matrix(m, n, T)</a></h3>
<p>Matrices with row and column dimensions:</p>
<pre><code class="language-kleis">Matrix(m: Nat, n: Nat, T)
</code></pre>
<p>Example: <code>Matrix(2, 3, ‚Ñù)</code> is a 2√ó3 real matrix.</p>
<p><strong>Delimiter Variants:</strong></p>
<pre><code class="language-kleis">Matrix(m, n, T)   // [a b; c d] - square brackets
PMatrix(m, n, T)  // (a b; c d) - parentheses
VMatrix(m, n, T)  // |a b; c d| - vertical bars (determinants)
BMatrix(m, n, T)  // {a b; c d} - braces
</code></pre>
<p>See <a href="#matrices">Chapter 19: Matrices</a> for operations.</p>
<h2 id="tensor-types-xact-style"><a class="header" href="#tensor-types-xact-style">Tensor Types (xAct-style)</a></h2>
<p>Kleis includes types for differential geometry with xAct-style tensor notation.</p>
<h3 id="indexvariance"><a class="header" href="#indexvariance">IndexVariance</a></h3>
<p>Whether an index is upper (contravariant) or lower (covariant):</p>
<pre><code class="language-kleis">data IndexVariance = Contravariant | Covariant
</code></pre>
<h3 id="tensoridx"><a class="header" href="#tensoridx">TensorIdx</a></h3>
<p>A single tensor index:</p>
<pre><code class="language-kleis">data TensorIdx = TIdx(name: String, variance: IndexVariance)
</code></pre>
<p>Example: <code>TIdx("Œº", Contravariant)</code> represents the upper index Œº.</p>
<h3 id="tensorrank"><a class="header" href="#tensorrank">TensorRank</a></h3>
<p>Tensor rank as (contravariant, covariant) pair:</p>
<pre><code class="language-kleis">data TensorRank = Rank(upper: Nat, lower: Nat)
</code></pre>
<p>Example: <code>Rank(1, 2)</code> for a (1,2)-tensor like Œì^Œº_{ŒΩœÅ}.</p>
<h3 id="tensortype"><a class="header" href="#tensortype">TensorType</a></h3>
<p>Full tensor type with explicit index structure:</p>
<pre><code class="language-kleis">data TensorType = TensorT(name: String, indices: List(TensorIdx))
</code></pre>
<p><strong>Usage in physics:</strong></p>
<pre><code class="language-kleis">// Christoffel symbol Œì^Œª_ŒºŒΩ
let christoffel = TensorT("Gamma", [
    TIdx("lambda", Contravariant),
    TIdx("mu", Covariant),
    TIdx("nu", Covariant)
])

// Riemann tensor R^œÅ_œÉŒºŒΩ
let riemann = TensorT("R", [
    TIdx("rho", Contravariant),
    TIdx("sigma", Covariant),
    TIdx("mu", Covariant),
    TIdx("nu", Covariant)
])
</code></pre>
<h2 id="the-prelude-core-structures"><a class="header" href="#the-prelude-core-structures">The Prelude: Core Structures</a></h2>
<p>After types load, <code>minimal_prelude.kleis</code> defines the fundamental structures that make operations work.</p>
<h3 id="arithmetict"><a class="header" href="#arithmetict">Arithmetic(T)</a></h3>
<p>Basic math operations for any type:</p>
<pre><code class="language-kleis">structure Arithmetic(T) {
    operation plus : T ‚Üí T ‚Üí T
    operation minus : T ‚Üí T ‚Üí T
    operation times : T ‚Üí T ‚Üí T
    operation divide : T ‚Üí T ‚Üí T
    operation frac : T ‚Üí T ‚Üí T
}

// Implementation for real numbers
implements Arithmetic(‚Ñù) {
    operation plus = builtin_add
    operation minus = builtin_sub
    operation times = builtin_mul
    operation divide = builtin_div
    operation frac = builtin_div
}
</code></pre>
<h3 id="equatablet"><a class="header" href="#equatablet">Equatable(T)</a></h3>
<p>Equality comparison:</p>
<pre><code class="language-kleis">structure Equatable(T) {
    operation equals : T ‚Üí T ‚Üí Bool
    operation not_equals : T ‚Üí T ‚Üí Bool
}

implements Equatable(‚Ñù) {
    operation equals = builtin_eq
    operation not_equals = builtin_neq
}

// Matrices have component-wise equality
implements Equatable(Matrix(m, n, ‚Ñù)) {
    operation equals = builtin_matrix_eq
    operation not_equals = builtin_matrix_neq
}
</code></pre>
<h3 id="orderedt"><a class="header" href="#orderedt">Ordered(T)</a></h3>
<p>Comparison operations (only for types with natural ordering):</p>
<pre><code class="language-kleis">structure Ordered(T) {
    operation less_than : T ‚Üí T ‚Üí Bool
    operation greater_than : T ‚Üí T ‚Üí Bool
    operation less_equal : T ‚Üí T ‚Üí Bool
    operation greater_equal : T ‚Üí T ‚Üí Bool
}

// Only scalars are ordered - matrices are NOT!
implements Ordered(‚Ñù) {
    operation less_than = builtin_lt
    operation greater_than = builtin_gt
    operation less_equal = builtin_le
    operation greater_equal = builtin_ge
}
</code></pre>
<p><strong>Note:</strong> Matrices don‚Äôt implement <code>Ordered</code> because matrix comparison isn‚Äôt well-defined (is [[1,2],[3,4]] &lt; [[5,6],[7,8]]?).</p>
<h3 id="numericn"><a class="header" href="#numericn">Numeric(N)</a></h3>
<p>Advanced numeric operations:</p>
<pre><code class="language-kleis">structure Numeric(N) {
    operation abs : N ‚Üí N
    operation floor : N ‚Üí N
    operation sqrt : N ‚Üí N
    operation power : N ‚Üí N ‚Üí N
}

implements Numeric(‚Ñù) {
    operation abs = builtin_abs
    operation floor = builtin_floor
    operation sqrt = builtin_sqrt
    operation power = builtin_pow
}
</code></pre>
<h3 id="calculus-structures"><a class="header" href="#calculus-structures">Calculus Structures</a></h3>
<p>For symbolic differentiation and integration:</p>
<pre><code class="language-kleis">structure Differentiable(F) {
    operation derivative : F ‚Üí F
    operation partial : F ‚Üí F
}

structure Integrable(F) {
    operation integral : F ‚Üí ‚Ñù
    operation int_bounds : F ‚Üí ‚Ñù ‚Üí ‚Ñù ‚Üí F ‚Üí ‚Ñù
}
</code></pre>
<h2 id="other-standard-library-files"><a class="header" href="#other-standard-library-files">Other Standard Library Files</a></h2>
<p>The stdlib contains domain-specific modules:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>complex.kleis</code></td><td>Complex number operations</td></tr>
<tr><td><code>matrices.kleis</code></td><td>Matrix algebra, transpose, determinant</td></tr>
<tr><td><code>tensors.kleis</code></td><td>Tensor algebra, index contraction</td></tr>
<tr><td><code>calculus.kleis</code></td><td>Derivatives, integrals, limits</td></tr>
<tr><td><code>sets.kleis</code></td><td>Set operations ‚à™, ‚à©, ‚äÜ</td></tr>
<tr><td><code>lists.kleis</code></td><td>List operations, folds</td></tr>
<tr><td><code>rational.kleis</code></td><td>Rational number arithmetic</td></tr>
<tr><td><code>bitvector.kleis</code></td><td>Bit manipulation</td></tr>
<tr><td><code>combinatorics.kleis</code></td><td>Factorials, binomials</td></tr>
<tr><td><code>bigops.kleis</code></td><td>Œ£, Œ†, big operators</td></tr>
<tr><td><code>quantum.kleis</code></td><td>Quantum mechanics notation</td></tr>
</tbody>
</table>
</div>
<p>Import what you need:</p>
<pre><code class="language-kleis">import "stdlib/complex.kleis"
import "stdlib/tensors.kleis"
</code></pre>
<h2 id="loading-order"><a class="header" href="#loading-order">Loading Order</a></h2>
<p>The standard library loads in a specific order:</p>
<ol>
<li><strong>types.kleis</strong> - Core type definitions (Bool, Option, etc.)</li>
<li><strong>minimal_prelude.kleis</strong> - Core structures (Arithmetic, Equatable, etc.)</li>
<li><strong>Domain modules</strong> - As imported by user</li>
</ol>
<p>This ensures types are defined before they‚Äôre used in structures.</p>
<h2 id="extending-the-type-system"><a class="header" href="#extending-the-type-system">Extending the Type System</a></h2>
<p>Because types are defined in Kleis, you can add your own:</p>
<pre><code class="language-kleis">// Physics domain
data Particle = Electron | Proton | Neutron | Photon
data Spin = SpinUp | SpinDown

// Chemistry domain  
data Element = H | He | Li | Be | B | C | N | O

// Business domain
data Currency = USD | EUR | GBP | JPY
</code></pre>
<p>Your custom types work with pattern matching, axioms, and Z3 verification just like built-in types.</p>
<h2 id="whats-next-14"><a class="header" href="#whats-next-14">What‚Äôs Next?</a></h2>
<p>Explore specific type domains in depth:</p>
<p>‚Üí <a href="#complex-numbers">Complex Numbers</a><br>‚Üí <a href="#matrices">Matrices</a><br>‚Üí <a href="#set-theory">Set Theory</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="complex-numbers"><a class="header" href="#complex-numbers">Complex Numbers</a></h1>
<p>Kleis has first-class support for complex numbers (‚ÑÇ), enabling symbolic reasoning about complex arithmetic, verification of identities, and theorem proving in complex analysis.</p>
<h2 id="natural-arithmetic-syntax--new"><a class="header" href="#natural-arithmetic-syntax--new">Natural Arithmetic Syntax ‚ú® NEW</a></h2>
<p><strong>Kleis now supports natural arithmetic operators for complex numbers!</strong></p>
<p>You can write expressions using <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> with complex numbers, just like you would with real numbers:</p>
<pre><code class="language-kleis">// Natural syntax (NEW!)
:verify complex(1, 2) + complex(3, 4) = complex(4, 6)
// ‚úÖ Valid

:verify complex(1, 2) * complex(3, 4) = complex(-5, 10)
// ‚úÖ Valid

// The classic: 3 + 4i
:verify 3 + 4*i = complex(3, 4)
// ‚úÖ Valid

// Mixed real and complex
:verify 5 + complex(1, 2) = complex(6, 2)
// ‚úÖ Valid
</code></pre>
<p>Kleis automatically converts these to the appropriate complex operations via <strong>semantic lowering</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>You Write</th><th>Kleis Translates To</th></tr>
</thead>
<tbody>
<tr><td><code>z1 + z2</code></td><td><code>complex_add(z1, z2)</code></td></tr>
<tr><td><code>z1 - z2</code></td><td><code>complex_sub(z1, z2)</code></td></tr>
<tr><td><code>z1 * z2</code></td><td><code>complex_mul(z1, z2)</code></td></tr>
<tr><td><code>z1 / z2</code></td><td><code>complex_div(z1, z2)</code></td></tr>
<tr><td><code>r + z</code> (‚Ñù + ‚ÑÇ)</td><td><code>complex_add(complex(r, 0), z)</code></td></tr>
<tr><td><code>-z</code></td><td><code>neg_complex(z)</code></td></tr>
</tbody>
</table>
</div>
<p>This works transparently in the REPL and for verification.</p>
<h2 id="concrete-evaluation-with-eval-1"><a class="header" href="#concrete-evaluation-with-eval-1">Concrete Evaluation with <code>:eval</code></a></h2>
<p>For direct computation with complex numbers, use the <code>:eval</code> command:</p>
<pre><code class="language-kleis">:eval complex_add(complex(1, 2), complex(3, 4))
// ‚Üí complex(4, 6)

:eval complex_sub(complex(10, 20), complex(3, 4))
// ‚Üí complex(7, 16)

:eval complex_mul(complex(1, 2), complex(3, 4))
// ‚Üí complex(-5, 10)

:eval complex_conj(complex(3, 4))
// ‚Üí complex(3, -4)

:eval complex_abs_squared(complex(3, 4))
// ‚Üí 25  (|3+4i|¬≤ = 9 + 16 = 25)
</code></pre>
<h3 id="extracting-parts"><a class="header" href="#extracting-parts">Extracting Parts</a></h3>
<pre><code class="language-kleis">:eval real(complex(5, 7))
// ‚Üí 5

:eval imag(complex(5, 7))
// ‚Üí 7
</code></pre>
<h3 id="mixed-symbolicconcrete"><a class="header" href="#mixed-symbolicconcrete">Mixed Symbolic/Concrete</a></h3>
<p><code>:eval</code> supports partial symbolic evaluation:</p>
<pre><code class="language-kleis">:eval complex_add(complex(a, 2), complex(3, 4))
// ‚Üí complex(a + 3, 6)

:eval complex_mul(complex(a, 0), complex(0, b))
// ‚Üí complex(0, a * b)
</code></pre>
<h2 id="the-imaginary-unit"><a class="header" href="#the-imaginary-unit">The Imaginary Unit</a></h2>
<p>The imaginary unit <code>i</code> is predefined in Kleis:</p>
<pre><code class="language-kleis">// i is the square root of -1
define i_squared = i * i
// Result: complex(-1, 0)  ‚Äî that's -1!
</code></pre>
<p>In the REPL, you can verify this fundamental property:</p>
<pre><code class="language-kleis">:verify i * i = complex(-1, 0)
// ‚úÖ Valid

// Or using the explicit function:
:verify complex_mul(i, i) = complex(-1, 0)
// ‚úÖ Valid
</code></pre>
<h3 id="scoping-rules-for-i"><a class="header" href="#scoping-rules-for-i">Scoping Rules for <code>i</code></a></h3>
<p>The imaginary unit <code>i</code> is a global constant. However, it can be shadowed by:</p>
<ol>
<li><strong>Quantified variables</strong> with explicit type annotations</li>
<li><strong>Lambda parameters</strong></li>
</ol>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Type</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><code>i</code></td><td>Complex</td><td>Global imaginary unit</td></tr>
<tr><td><code>i + 1</code></td><td>Complex</td><td>Uses global <code>i</code></td></tr>
<tr><td><code>i * i</code></td><td>Complex</td><td><code>i¬≤ = -1</code></td></tr>
<tr><td><code>Œª x . x + i</code></td><td>Complex</td><td>Uses global <code>i</code> in body</td></tr>
<tr><td><code>‚àÄ(i : ‚Ñù). i + 1</code></td><td>Scalar</td><td>Quantifier <code>i : ‚Ñù</code> shadows global</td></tr>
<tr><td><code>‚àÄ(i : ‚Ñï). i + 0</code></td><td>Nat</td><td>Quantifier <code>i : ‚Ñï</code> shadows global</td></tr>
<tr><td><code>Œª i . i + 1</code></td><td>Scalar</td><td>Lambda param shadows global</td></tr>
</tbody>
</table>
</div>
<p><strong>Scoping examples:</strong></p>
<pre><code class="language-kleis">// Quantified variable i : ‚Ñù shadows the global imaginary unit
// Here i is a real number, so i + 1 uses regular addition
verify ‚àÄ(i : ‚Ñù). i + 1 = 1 + i

// Quantified variable i : ‚Ñï is a natural number
verify ‚àÄ(i : ‚Ñï). i + 0 = i

// Quantified variable i : ‚ÑÇ is explicitly complex
verify ‚àÄ(i : ‚ÑÇ). complex_add(i, complex(0, 0)) = i
</code></pre>
<p><strong>In the REPL, you can also check types:</strong></p>
<pre><code>Œª&gt; :type i
üìê Type: Complex

Œª&gt; :type i + 1  
üìê Type: Complex

Œª&gt; :type Œª x . x + i
üìê Type: Complex

Œª&gt; :type Œª i . i + 1
üìê Type: Scalar
</code></pre>
<p>Note: <code>Œª x . x + i</code> uses global <code>i</code>, while <code>Œª i . i + 1</code> has parameter <code>i</code> shadowing global.</p>
<p><strong>Best practice:</strong> Avoid using <code>i</code> as a variable name to prevent confusion with the imaginary unit. Use descriptive names like <code>idx</code>, <code>index</code>, or <code>iter</code> for loop-like variables.</p>
<pre><code class="language-kleis">// Clear: using i as imaginary unit
verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, i) = complex(neg(im(z)), re(z))

// Clear: using idx as index variable  
verify ‚àÄ(idx : ‚Ñï). idx + 0 = idx
</code></pre>
<h2 id="creating-complex-numbers"><a class="header" href="#creating-complex-numbers">Creating Complex Numbers</a></h2>
<p><strong>Method 1: Using arithmetic (recommended)</strong></p>
<pre><code class="language-kleis">define z1 = 3 + 4*i           // 3 + 4i
define z2 = 1 - 2*i           // 1 - 2i
define pure_real = 5 + 0*i    // 5 (a real number)
define pure_imag = 0 + 3*i    // 3i (pure imaginary)
</code></pre>
<p><strong>Method 2: Using the <code>complex(re, im)</code> constructor</strong></p>
<pre><code class="language-kleis">// complex(real_part, imaginary_part)
define z1 = complex(3, 4)       // 3 + 4i
define z2 = complex(1, -2)      // 1 - 2i
define pure_real = complex(5, 0)     // 5 (a real number)
define pure_imag = complex(0, 3)     // 3i (pure imaginary)
</code></pre>
<h2 id="extracting-parts-1"><a class="header" href="#extracting-parts-1">Extracting Parts</a></h2>
<p>Use <code>re</code> and <code>im</code> to extract the real and imaginary parts:</p>
<pre><code class="language-kleis">define z = complex(3, 4)

// Extract real part
define real_part = re(z)        // 3

// Extract imaginary part  
define imag_part = im(z)        // 4
</code></pre>
<p>Verification examples:</p>
<pre><code class="language-kleis">:verify re(complex(7, 8)) = 7
// ‚úÖ Valid

:verify im(complex(7, 8)) = 8
// ‚úÖ Valid

:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù). re(complex(a, b)) = a
// ‚úÖ Valid
</code></pre>
<h2 id="type-ascriptions-with-‚ÑÇ"><a class="header" href="#type-ascriptions-with-‚ÑÇ">Type Ascriptions with ‚ÑÇ</a></h2>
<p>Type ascriptions tell Kleis (and Z3) that a variable is a complex number. The syntax is <code>: ‚ÑÇ</code> (or <code>: Complex</code>).</p>
<h3 id="quantifier-variables"><a class="header" href="#quantifier-variables">Quantifier Variables</a></h3>
<p>The most common use is in universal quantifiers:</p>
<pre><code class="language-kleis">// z is a complex variable
:verify ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
// ‚úÖ Valid

// Multiple complex variables
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). z1 + z2 = z2 + z1
// ‚úÖ Valid

// Mixed types: real and complex
:verify ‚àÄ(r : ‚Ñù)(z : ‚ÑÇ). r + z = complex(r + re(z), im(z))
// ‚úÖ Valid
</code></pre>
<p>When you write <code>‚àÄ(z : ‚ÑÇ)</code>, the Z3 backend creates a symbolic complex variable with unknown real and imaginary parts. This lets Z3 reason about <strong>all possible</strong> complex numbers.</p>
<h3 id="definition-annotations"><a class="header" href="#definition-annotations">Definition Annotations</a></h3>
<p>You can annotate definitions for clarity:</p>
<pre><code class="language-kleis">define z1 : ‚ÑÇ = complex(1, 2)
define z2 : ‚ÑÇ = 3 + 4*i
define origin : ‚ÑÇ = complex(0, 0)
</code></pre>
<h3 id="why-type-ascriptions-matter"><a class="header" href="#why-type-ascriptions-matter">Why Type Ascriptions Matter</a></h3>
<p>Without type information, Z3 wouldn‚Äôt know how to handle operations:</p>
<pre><code class="language-kleis">// With `: ‚ÑÇ`, Z3 knows z is complex and creates appropriate constraints
:verify ‚àÄ(z : ‚ÑÇ). z * complex(1, 0) = z
// ‚úÖ Valid

// Z3 can reason symbolically about the real and imaginary parts
:verify ‚àÄ(z : ‚ÑÇ). re(z) * re(z) + im(z) * im(z) = abs_squared(z)
// ‚úÖ Valid
</code></pre>
<h3 id="equivalent-type-names"><a class="header" href="#equivalent-type-names">Equivalent Type Names</a></h3>
<p>For complex numbers, these are all equivalent:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>: ‚ÑÇ</code></td><td>Unicode symbol (recommended)</td></tr>
<tr><td><code>: Complex</code></td><td>Full name</td></tr>
<tr><td><code>: C</code></td><td>Short ASCII alternative</td></tr>
</tbody>
</table>
</div>
<p>For comparison, here are the equivalent forms for other numeric types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>ASCII</th></tr>
</thead>
<tbody>
<tr><td>Complex</td><td><code>: ‚ÑÇ</code></td><td><code>: Complex</code></td><td><code>: C</code></td></tr>
<tr><td>Real/Scalar</td><td><code>: ‚Ñù</code></td><td><code>: Real</code> or <code>: Scalar</code></td><td><code>: R</code></td></tr>
<tr><td>Natural</td><td><code>: ‚Ñï</code></td><td><code>: Nat</code></td><td><code>: N</code></td></tr>
<tr><td>Integer</td><td><code>: ‚Ñ§</code></td><td><code>: Int</code> or <code>: Integer</code></td><td><code>: Z</code></td></tr>
<tr><td>Boolean</td><td><code>: ùîπ</code></td><td><code>: Bool</code></td><td>‚Äî</td></tr>
</tbody>
</table>
</div>
<h2 id="arithmetic-operations"><a class="header" href="#arithmetic-operations">Arithmetic Operations</a></h2>
<h3 id="addition-and-subtraction"><a class="header" href="#addition-and-subtraction">Addition and Subtraction</a></h3>
<pre><code class="language-kleis">define z1 = 1 + 2*i    // 1 + 2i
define z2 = 3 + 4*i    // 3 + 4i

// Addition: (1 + 2i) + (3 + 4i) = 4 + 6i
define sum = z1 + z2

// Subtraction: (1 + 2i) - (3 + 4i) = -2 - 2i
define diff = z1 - z2
</code></pre>
<p>Verify concrete arithmetic:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 2*i) + (3 + 4*i) = 4 + 6*i
// ‚úÖ Valid

:verify (5 + 3*i) - (2 + 1*i) = 3 + 2*i
// ‚úÖ Valid

// Explicit function syntax (also works)
:verify complex_add(complex(1, 2), complex(3, 4)) = complex(4, 6)
// ‚úÖ Valid
</code></pre>
<h3 id="multiplication"><a class="header" href="#multiplication">Multiplication</a></h3>
<p>Complex multiplication follows the rule: <code>(a + bi)(c + di) = (ac - bd) + (ad + bc)i</code></p>
<pre><code class="language-kleis">define z1 = 1 + 2*i    // 1 + 2i
define z2 = 3 + 4*i    // 3 + 4i

// (1 + 2i)(3 + 4i) = 3 + 4i + 6i + 8i¬≤ = 3 + 10i - 8 = -5 + 10i
define product = z1 * z2
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 2*i) * (3 + 4*i) = complex(-5, 10)
// ‚úÖ Valid

// The fundamental property: i¬≤ = -1
:verify i * i = complex(-1, 0)
// ‚úÖ Valid

// Multiplication by i rotates 90¬∞
:verify ‚àÄ(z : ‚ÑÇ). z * i = complex(neg(im(z)), re(z))
// ‚úÖ Valid (where neg is negation)
</code></pre>
<h3 id="division"><a class="header" href="#division">Division</a></h3>
<pre><code class="language-kleis">define z1 = 1 + 0*i    // 1
define z2 = 0 + 1*i    // i

// 1 / i = -i
define quotient = z1 / z2
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 0*i) / (0 + 1*i) = 0 - 1*i
// ‚úÖ Valid

// Explicit function syntax
:verify complex_div(complex(1, 0), complex(0, 1)) = complex(0, -1)
// ‚úÖ Valid
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<pre><code class="language-kleis">define z = complex(3, 4)
define neg_z = neg_complex(z)    // -3 - 4i
</code></pre>
<pre><code class="language-kleis">:verify neg_complex(complex(3, 4)) = complex(-3, -4)
// ‚úÖ Valid

:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, neg_complex(z)) = complex(0, 0)
// ‚úÖ Valid
</code></pre>
<h3 id="inverse"><a class="header" href="#inverse">Inverse</a></h3>
<pre><code class="language-kleis">define z = complex(0, 1)         // i
define inv = complex_inverse(z)   // 1/i = -i
</code></pre>
<pre><code class="language-kleis">:verify complex_inverse(complex(0, 1)) = complex(0, -1)
// ‚úÖ Valid

// z * (1/z) = 1 (for non-zero z)
:verify ‚àÄ(z : ‚ÑÇ). z ‚â† complex(0, 0) ‚üπ complex_mul(z, complex_inverse(z)) = complex(1, 0)
// ‚úÖ Valid
</code></pre>
<h2 id="complex-conjugate"><a class="header" href="#complex-conjugate">Complex Conjugate</a></h2>
<p>The conjugate of <code>a + bi</code> is <code>a - bi</code>:</p>
<pre><code class="language-kleis">define z = complex(3, 4)
define z_bar = conj(z)    // 3 - 4i
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">:verify conj(complex(2, 3)) = complex(2, -3)
// ‚úÖ Valid

// Double conjugate is identity
:verify ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
// ‚úÖ Valid

// Conjugate of product
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). conj(complex_mul(z1, z2)) = complex_mul(conj(z1), conj(z2))
// ‚úÖ Valid

// Conjugate of sum
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). conj(complex_add(z1, z2)) = complex_add(conj(z1), conj(z2))
// ‚úÖ Valid
</code></pre>
<h2 id="magnitude-squared"><a class="header" href="#magnitude-squared">Magnitude Squared</a></h2>
<p>The squared magnitude <code>|z|¬≤ = re(z)¬≤ + im(z)¬≤</code>:</p>
<pre><code class="language-kleis">define z = complex(3, 4)
define mag_sq = abs_squared(z)    // 3¬≤ + 4¬≤ = 25
</code></pre>
<pre><code class="language-kleis">:verify abs_squared(complex(3, 4)) = 25
// ‚úÖ Valid

:verify ‚àÄ(z : ‚ÑÇ). abs_squared(z) = re(z) * re(z) + im(z) * im(z)
// ‚úÖ Valid
</code></pre>
<p>Note: Full magnitude <code>|z| = ‚àö(re¬≤ + im¬≤)</code> requires square root, which is not yet supported.</p>
<h2 id="field-properties"><a class="header" href="#field-properties">Field Properties</a></h2>
<p>Complex numbers form a field. Kleis can verify all field axioms:</p>
<h3 id="commutativity"><a class="header" href="#commutativity">Commutativity</a></h3>
<pre><code class="language-kleis">// Addition is commutative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). complex_add(z1, z2) = complex_add(z2, z1)
// ‚úÖ Valid

// Multiplication is commutative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). complex_mul(z1, z2) = complex_mul(z2, z1)
// ‚úÖ Valid
</code></pre>
<h3 id="associativity"><a class="header" href="#associativity">Associativity</a></h3>
<pre><code class="language-kleis">// Addition is associative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_add(complex_add(z1, z2), z3) = complex_add(z1, complex_add(z2, z3))
// ‚úÖ Valid

// Multiplication is associative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_mul(complex_mul(z1, z2), z3) = complex_mul(z1, complex_mul(z2, z3))
// ‚úÖ Valid
</code></pre>
<h3 id="identity-elements"><a class="header" href="#identity-elements">Identity Elements</a></h3>
<pre><code class="language-kleis">// Additive identity: z + 0 = z
:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, complex(0, 0)) = z
// ‚úÖ Valid

// Multiplicative identity: z * 1 = z
:verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, complex(1, 0)) = z
// ‚úÖ Valid
</code></pre>
<h3 id="distributive-law"><a class="header" href="#distributive-law">Distributive Law</a></h3>
<pre><code class="language-kleis">:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_mul(z1, complex_add(z2, z3)) = 
        complex_add(complex_mul(z1, z2), complex_mul(z1, z3))
// ‚úÖ Valid
</code></pre>
<h2 id="embedding-real-numbers"><a class="header" href="#embedding-real-numbers">Embedding Real Numbers</a></h2>
<p>Real numbers embed into complex numbers with imaginary part 0:</p>
<pre><code class="language-kleis">define r = 5
define z = complex(r, 0)    // 5 + 0i = 5

// Extracting real from embedded real
:verify ‚àÄ(a : ‚Ñù). re(complex(a, 0)) = a
// ‚úÖ Valid

:verify ‚àÄ(a : ‚Ñù). im(complex(a, 0)) = 0
// ‚úÖ Valid
</code></pre>
<p>Adding real and imaginary parts:</p>
<pre><code class="language-kleis">:verify ‚àÄ(x : ‚Ñù)(y : ‚Ñù). complex_add(complex(x, 0), complex(0, y)) = complex(x, y)
// ‚úÖ Valid
</code></pre>
<h2 id="the-multiplication-formula"><a class="header" href="#the-multiplication-formula">The Multiplication Formula</a></h2>
<p>The explicit formula for complex multiplication:</p>
<pre><code class="language-kleis">// (a + bi)(c + di) = (ac - bd) + (ad + bc)i
:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù)(c : ‚Ñù)(d : ‚Ñù). 
    complex_mul(complex(a, b), complex(c, d)) = complex(a*c - b*d, a*d + b*c)
// ‚úÖ Valid
</code></pre>
<h2 id="mixing-symbolic-and-concrete"><a class="header" href="#mixing-symbolic-and-concrete">Mixing Symbolic and Concrete</a></h2>
<p>Kleis can reason about mixed expressions:</p>
<pre><code class="language-kleis">// Symbolic z plus concrete value
:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, complex(0, 0)) = z
// ‚úÖ Valid

// Symbolic z times concrete i
:verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, i) = complex_add(z, complex(0, 1))
// This checks if multiplying by i equals adding i (it doesn't!)
// ‚ùå Invalid ‚Äî as expected!

// Correct: multiplying by i rotates
:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù). complex_mul(complex(a, b), i) = complex(-b, a)
// ‚úÖ Valid (rotation by 90¬∞)
</code></pre>
<h2 id="the-fundamental-theorem"><a class="header" href="#the-fundamental-theorem">The Fundamental Theorem</a></h2>
<p>The defining property of complex numbers:</p>
<pre><code class="language-kleis">// i¬≤ = -1
:verify complex_mul(i, i) = complex(-1, 0)
// ‚úÖ Valid

// More explicitly
:verify complex_mul(complex(0, 1), complex(0, 1)) = complex(-1, 0)
// ‚úÖ Valid
</code></pre>
<h2 id="convention-loop-indices"><a class="header" href="#convention-loop-indices">Convention: Loop Indices</a></h2>
<p>When using <code>Sum</code> or <code>Product</code> with complex numbers, <strong>avoid using <code>i</code> as a loop index</strong>:</p>
<pre><code class="language-kleis">// GOOD: use k, j, n, m as loop indices
Sum(k, complex_mul(complex(1, 0), pow(z, k)), 0, n)

// BAD: i as loop index clashes with imaginary i
Sum(i, complex_mul(i, pow(z, i)), 0, n)   // Which 'i' is which?
</code></pre>
<p>The convention is:</p>
<ul>
<li><code>k</code>, <code>j</code>, <code>n</code>, <code>m</code> ‚Äî loop indices</li>
<li><code>i</code> ‚Äî imaginary unit</li>
</ul>
<h2 id="complete-example-verifying-complex-identities"><a class="header" href="#complete-example-verifying-complex-identities">Complete Example: Verifying Complex Identities</a></h2>
<p>Here‚Äôs a complete session verifying multiple complex number properties:</p>
<pre><code class="language-kleis">// Define some complex numbers
define z1 : ‚ÑÇ = complex(1, 2)
define z2 : ‚ÑÇ = complex(3, 4)

// Compute operations
define sum = complex_add(z1, z2)
define product = complex_mul(z1, z2)
define i_squared = complex_mul(i, i)

// Structure with axioms
structure ComplexTest {
    axiom i_squared_minus_one : complex_mul(i, i) = complex(-1, 0)
    axiom conj_involution : ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
    axiom add_commutes : ‚àÄ(a : ‚ÑÇ)(b : ‚ÑÇ). complex_add(a, b) = complex_add(b, a)
}
</code></pre>
<h2 id="operation-reference"><a class="header" href="#operation-reference">Operation Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Natural Syntax</th><th>Explicit Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Create</td><td><code>a + b*i</code></td><td><code>complex(a, b)</code></td><td>Create a + bi</td></tr>
<tr><td>Real part</td><td>‚Äî</td><td><code>re(z)</code></td><td>Extract real part</td></tr>
<tr><td>Imaginary part</td><td>‚Äî</td><td><code>im(z)</code></td><td>Extract imaginary part</td></tr>
<tr><td>Add</td><td><code>z1 + z2</code></td><td><code>complex_add(z1, z2)</code></td><td>z1 + z2</td></tr>
<tr><td>Subtract</td><td><code>z1 - z2</code></td><td><code>complex_sub(z1, z2)</code></td><td>z1 - z2</td></tr>
<tr><td>Multiply</td><td><code>z1 * z2</code></td><td><code>complex_mul(z1, z2)</code></td><td>z1 √ó z2</td></tr>
<tr><td>Divide</td><td><code>z1 / z2</code></td><td><code>complex_div(z1, z2)</code></td><td>z1 / z2</td></tr>
<tr><td>Negate</td><td><code>-z</code></td><td><code>neg_complex(z)</code></td><td>-z</td></tr>
<tr><td>Inverse</td><td>‚Äî</td><td><code>complex_inverse(z)</code></td><td>1/z</td></tr>
<tr><td>Conjugate</td><td>‚Äî</td><td><code>conj(z)</code></td><td>Complex conjugate</td></tr>
<tr><td>Magnitude¬≤</td><td>‚Äî</td><td><code>abs_squared(z)</code></td><td>|z|¬≤</td></tr>
</tbody>
</table>
</div>
<h2 id="current-limitations"><a class="header" href="#current-limitations">Current Limitations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Operator overloading</td><td>‚úÖ</td><td><code>z1 + z2</code>, <code>3 + 4*i</code> work!</td></tr>
<tr><td>Magnitude <code>abs(z)</code></td><td>‚ùå</td><td>Requires sqrt</td></tr>
<tr><td>Transcendentals</td><td>‚ùå</td><td><code>exp</code>, <code>log</code>, <code>sin</code>, <code>cos</code></td></tr>
<tr><td>Polar form</td><td>‚ùå</td><td><code>(r, Œ∏)</code></td></tr>
<tr><td>Euler‚Äôs formula</td><td>‚ùå</td><td><code>e^{iŒ∏} = cos(Œ∏) + i¬∑sin(Œ∏)</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-15"><a class="header" href="#whats-next-15">What‚Äôs Next?</a></h2>
<p>Complex numbers enable reasoning about:</p>
<ul>
<li>Signal processing (Fourier transforms)</li>
<li>Quantum mechanics (wave functions)</li>
<li>Control theory (transfer functions)</li>
<li>Complex analysis (contour integrals)</li>
</ul>
<p>Continue exploring Kleis‚Äôs number systems:</p>
<p>‚Üí <a href="#rational-numbers">Rational Numbers</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rational-numbers"><a class="header" href="#rational-numbers">Rational Numbers</a></h1>
<p>Kleis provides complete support for <strong>rational numbers</strong> (‚Ñö), the field of fractions p/q where p and q are integers and q ‚â† 0. Rational arithmetic in Kleis is <strong>exact</strong>‚Äîno floating-point approximation errors.</p>
<h2 id="the-rational-type"><a class="header" href="#the-rational-type">The Rational Type</a></h2>
<p>Kleis recognizes three equivalent notations for the rational type:</p>
<pre><code class="language-kleis">define half : ‚Ñö = rational(1, 2)
define third : Rational = rational(1, 3)
define quarter : Q = rational(1, 4)
</code></pre>
<h2 id="constructing-rationals"><a class="header" href="#constructing-rationals">Constructing Rationals</a></h2>
<p>Use the <code>rational(p, q)</code> constructor to create rational numbers:</p>
<pre><code class="language-kleis">define one_half : ‚Ñö = rational(1, 2)
define two_thirds : ‚Ñö = rational(2, 3)
define negative : ‚Ñö = rational(-3, 4)
</code></pre>
<h3 id="accessors"><a class="header" href="#accessors">Accessors</a></h3>
<p>Extract the numerator and denominator:</p>
<pre><code class="language-kleis">structure RationalAccessors {
    axiom numer_ex : numer(rational(3, 4)) = 3
    axiom denom_ex : denom(rational(3, 4)) = 4
}
</code></pre>
<h2 id="arithmetic-operations-1"><a class="header" href="#arithmetic-operations-1">Arithmetic Operations</a></h2>
<h3 id="basic-arithmetic-1"><a class="header" href="#basic-arithmetic-1">Basic Arithmetic</a></h3>
<p>Kleis supports operator overloading for rationals:</p>
<pre><code class="language-kleis">define sum : ‚Ñö = rational(1, 2) + rational(1, 3)
define diff : ‚Ñö = rational(3, 4) - rational(1, 4)
define prod : ‚Ñö = rational(2, 3) * rational(3, 2)
define quot : ‚Ñö = rational(1, 2) / rational(1, 4)
</code></pre>
<p>These lower to explicit rational operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Lowers to</th></tr>
</thead>
<tbody>
<tr><td><code>r1 + r2</code></td><td><code>rational_add(r1, r2)</code></td></tr>
<tr><td><code>r1 - r2</code></td><td><code>rational_sub(r1, r2)</code></td></tr>
<tr><td><code>r1 * r2</code></td><td><code>rational_mul(r1, r2)</code></td></tr>
<tr><td><code>r1 / r2</code></td><td><code>rational_div(r1, r2)</code></td></tr>
<tr><td><code>-r</code></td><td><code>neg_rational(r)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="reciprocal-and-inverse"><a class="header" href="#reciprocal-and-inverse">Reciprocal and Inverse</a></h3>
<pre><code class="language-kleis">structure RationalInverse {
    axiom inv_half : rational_inv(rational(1, 2)) = rational(2, 1)
    axiom inv_def : ‚àÄ(p q : ‚Ñ§). p ‚â† 0 ‚àß q ‚â† 0 ‚Üí 
        rational_inv(rational(p, q)) = rational(q, p)
}
</code></pre>
<h2 id="derived-operations"><a class="header" href="#derived-operations">Derived Operations</a></h2>
<p>Kleis defines several derived operations using conditionals:</p>
<h3 id="sign-absolute-value-min-max"><a class="header" href="#sign-absolute-value-min-max">Sign, Absolute Value, Min, Max</a></h3>
<pre><code class="language-kleis">structure DerivedOps {
    define sign_rational(r : ‚Ñö) : ‚Ñ§ = 
        if rational_lt(r, rational(0, 1)) then 0 - 1
        else if r = rational(0, 1) then 0
        else 1
    
    define abs_rational(r : ‚Ñö) : ‚Ñö = 
        if rational_lt(r, rational(0, 1)) then neg_rational(r) 
        else r
    
    define min_rational(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        if rational_le(r1, r2) then r1 else r2
    
    define max_rational(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        if rational_le(r1, r2) then r2 else r1
    
    define midpoint(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        rational_div(rational_add(r1, r2), rational(2, 1))
}
</code></pre>
<h2 id="comparison-operations"><a class="header" href="#comparison-operations">Comparison Operations</a></h2>
<p>Rationals are totally ordered:</p>
<pre><code class="language-kleis">structure RationalOrder {
    axiom trichotomy : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚à® r1 = r2 ‚à® rational_gt(r1, r2)
    
    axiom transitive : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_lt(r1, r2) ‚àß rational_lt(r2, r3) ‚Üí rational_lt(r1, r3)
}
</code></pre>
<h3 id="mixed-type-comparisons"><a class="header" href="#mixed-type-comparisons">Mixed-Type Comparisons</a></h3>
<p>Kleis supports comparing rationals with other numeric types:</p>
<pre><code class="language-kleis">structure MixedComparisons {
    // Compare ‚Ñö with ‚Ñï
    axiom half_less_one : rational(1, 2) &lt; 1
    
    // Compare ‚Ñö with ‚Ñ§
    axiom neg_half_less_zero : rational(-1, 2) &lt; 0
}
</code></pre>
<h2 id="type-promotion"><a class="header" href="#type-promotion">Type Promotion</a></h2>
<p>When mixing rationals with other numeric types, Kleis promotes according to:</p>
<pre><code>‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñö ‚Üí ‚Ñù ‚Üí ‚ÑÇ
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">structure TypePromotion {
    // ‚Ñö + ‚Ñ§ ‚Üí ‚Ñö (integer lifted to rational)
    axiom int_plus_rat : rational(1, 2) + 1 = rational(3, 2)
    
    // ‚Ñö + ‚Ñù ‚Üí ‚Ñù (rational becomes real)
    axiom rat_plus_real : rational(1, 2) + 0.5 = 1.0
}
</code></pre>
<h2 id="field-axioms"><a class="header" href="#field-axioms">Field Axioms</a></h2>
<p>Rationals form a <strong>field</strong>‚Äîall the familiar algebraic laws hold:</p>
<pre><code class="language-kleis">structure RationalField {
    // Addition is commutative and associative
    axiom add_comm : ‚àÄ(r1 r2 : ‚Ñö). rational_add(r1, r2) = rational_add(r2, r1)
    axiom add_assoc : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_add(rational_add(r1, r2), r3) = rational_add(r1, rational_add(r2, r3))
    
    // Additive identity and inverse
    axiom add_identity : ‚àÄ(r : ‚Ñö). rational_add(r, rational(0, 1)) = r
    axiom add_inverse : ‚àÄ(r : ‚Ñö). rational_add(r, neg_rational(r)) = rational(0, 1)
    
    // Multiplication is commutative and associative
    axiom mul_comm : ‚àÄ(r1 r2 : ‚Ñö). rational_mul(r1, r2) = rational_mul(r2, r1)
    axiom mul_assoc : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_mul(rational_mul(r1, r2), r3) = rational_mul(r1, rational_mul(r2, r3))
    
    // Multiplicative identity and inverse
    axiom mul_identity : ‚àÄ(r : ‚Ñö). rational_mul(r, rational(1, 1)) = r
    axiom mul_inverse : ‚àÄ(r : ‚Ñö). r ‚â† rational(0, 1) ‚Üí 
        rational_mul(r, rational_inv(r)) = rational(1, 1)
    
    // Distributive law
    axiom distributive : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_mul(r1, rational_add(r2, r3)) = 
        rational_add(rational_mul(r1, r2), rational_mul(r1, r3))
}
</code></pre>
<h2 id="integer-operations"><a class="header" href="#integer-operations">Integer Operations</a></h2>
<h3 id="floor-and-ceiling"><a class="header" href="#floor-and-ceiling">Floor and Ceiling</a></h3>
<p>Convert rationals to integers:</p>
<pre><code class="language-kleis">structure FloorCeil {
    // floor: largest integer ‚â§ r
    axiom floor_def : ‚àÄ(r : ‚Ñö). int_to_rational(floor(r)) ‚â§ r
    
    // ceil: smallest integer ‚â• r
    axiom ceil_def : ‚àÄ(r : ‚Ñö). r ‚â§ int_to_rational(ceil(r))
    
    // Examples
    axiom floor_ex : floor(rational(7, 3)) = 2
    axiom ceil_ex : ceil(rational(7, 3)) = 3
}
</code></pre>
<h3 id="integer-division-and-modulo"><a class="header" href="#integer-division-and-modulo">Integer Division and Modulo</a></h3>
<pre><code class="language-kleis">structure IntDivMod {
    // Division identity: a = (a div b) * b + (a mod b)
    axiom div_mod_id : ‚àÄ(a b : ‚Ñ§). b ‚â† 0 ‚Üí 
        a = int_div(a, b) * b + int_mod(a, b)
    
    // Modulo is non-negative for positive divisor
    axiom mod_nonneg : ‚àÄ(a b : ‚Ñ§). b &gt; 0 ‚Üí 
        int_mod(a, b) ‚â• 0 ‚àß int_mod(a, b) &lt; b
}
</code></pre>
<h3 id="greatest-common-divisor"><a class="header" href="#greatest-common-divisor">Greatest Common Divisor</a></h3>
<p>GCD is defined axiomatically:</p>
<pre><code class="language-kleis">structure GCDAxioms {
    // GCD divides both arguments
    axiom gcd_divides_a : ‚àÄ(a b : ‚Ñ§). int_mod(a, gcd(a, b)) = 0
    axiom gcd_divides_b : ‚àÄ(a b : ‚Ñ§). int_mod(b, gcd(a, b)) = 0
    
    // GCD is the greatest such divisor
    axiom gcd_greatest : ‚àÄ(a b d : ‚Ñ§). 
        (int_mod(a, d) = 0 ‚àß int_mod(b, d) = 0) ‚Üí d ‚â§ gcd(a, b)
    
    // Euclidean algorithm
    axiom gcd_euclidean : ‚àÄ(a b : ‚Ñ§). b ‚â† 0 ‚Üí 
        gcd(a, b) = gcd(b, int_mod(a, b))
}
</code></pre>
<h2 id="density-property"><a class="header" href="#density-property">Density Property</a></h2>
<p>Between any two distinct rationals, there‚Äôs another:</p>
<pre><code class="language-kleis">structure Density {
    axiom density : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚Üí 
        (‚àÉ(r : ‚Ñö). rational_lt(r1, r) ‚àß rational_lt(r, r2))
    
    // The midpoint is always between
    axiom midpoint_between : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚Üí 
        rational_lt(r1, midpoint(r1, r2)) ‚àß rational_lt(midpoint(r1, r2), r2)
}
</code></pre>
<h2 id="z3-verification-1"><a class="header" href="#z3-verification-1">Z3 Verification</a></h2>
<p>Z3 maps rationals to its <code>Real</code> sort, which provides exact rational arithmetic:</p>
<pre><code class="language-kleis">structure Z3Example {
    // This theorem is verified by Z3
    axiom half_plus_half : rational_add(rational(1, 2), rational(1, 2)) = rational(1, 1)
    
    // Field properties are automatically verified
    axiom comm_verified : ‚àÄ(a b : ‚Ñö). rational_add(a, b) = rational_add(b, a)
}
</code></pre>
<h2 id="common-fractions"><a class="header" href="#common-fractions">Common Fractions</a></h2>
<p>The standard library defines convenient names:</p>
<pre><code class="language-kleis">structure CommonFractions {
    axiom half_def : half = rational(1, 2)
    axiom third_def : third = rational(1, 3)
    axiom quarter_def : quarter = rational(1, 4)
    axiom fifth_def : fifth = rational(1, 5)
    axiom tenth_def : tenth = rational(1, 10)
}
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Kleis Support</th></tr>
</thead>
<tbody>
<tr><td>Type notation</td><td><code>‚Ñö</code>, <code>Rational</code>, <code>Q</code></td></tr>
<tr><td>Construction</td><td><code>rational(p, q)</code></td></tr>
<tr><td>Arithmetic</td><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>-</code> (negation)</td></tr>
<tr><td>Comparison</td><td><code>&lt;</code>, <code>‚â§</code>, <code>&gt;</code>, <code>‚â•</code>, <code>=</code>, <code>‚â†</code></td></tr>
<tr><td>Derived ops</td><td><code>sign</code>, <code>abs</code>, <code>min</code>, <code>max</code>, <code>midpoint</code></td></tr>
<tr><td>Integer ops</td><td><code>floor</code>, <code>ceil</code>, <code>int_div</code>, <code>int_mod</code>, <code>gcd</code></td></tr>
<tr><td>Z3 backend</td><td>Native Real sort (exact arithmetic)</td></tr>
</tbody>
</table>
</div>
<p>See <code>stdlib/rational.kleis</code> for the complete axiom set.</p>
<h2 id="whats-next-16"><a class="header" href="#whats-next-16">What‚Äôs Next?</a></h2>
<p>Explore fixed-width binary arithmetic for hardware and low-level verification:</p>
<p>‚Üí <a href="#bit-vectors">Bit Vectors</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bit-vectors"><a class="header" href="#bit-vectors">Bit-Vectors</a></h1>
<p>Kleis provides support for <strong>bit-vectors</strong>‚Äîfixed-width sequences of bits. Bit-vectors are essential for hardware verification, cryptography, and low-level systems programming.</p>
<h2 id="bourbaki-definition"><a class="header" href="#bourbaki-definition">Bourbaki Definition</a></h2>
<p>Following Bourbaki‚Äôs rigorous style, a bit-vector of width n is defined as:</p>
<blockquote>
<p>A <strong>bit-vector</strong> of width n is a mapping x : [0, n-1] ‚Üí {0, 1}</p>
</blockquote>
<p>Equivalently, it‚Äôs a family (x·µ¢)_{i‚àà[0,n-1]} where each x·µ¢ ‚àà {0, 1}.</p>
<h2 id="the-bitvec-type"><a class="header" href="#the-bitvec-type">The BitVec Type</a></h2>
<pre><code class="language-kleis">define byte : BitVec(8) = bvzero(8)
define word : BitVec(32) = bvzero(32)
define qword : BitVec(64) = bvzero(64)
</code></pre>
<h2 id="mother-structures"><a class="header" href="#mother-structures">Mother Structures</a></h2>
<p>Bit-vectors inherit three fundamental algebraic structures:</p>
<h3 id="1-vector-space-over-ùîΩ‚ÇÇ"><a class="header" href="#1-vector-space-over-ùîΩ‚ÇÇ">1. Vector Space over ùîΩ‚ÇÇ</a></h3>
<p>The set BitVec(n) forms a vector space over the two-element field ùîΩ‚ÇÇ = {0, 1}:</p>
<pre><code class="language-kleis">structure VectorSpaceF2 {
    // XOR is the addition operation
    axiom add_commutative : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvxor(x, y) = bvxor(y, x)
    
    axiom add_associative : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvxor(bvxor(x, y), z) = bvxor(x, bvxor(y, z))
    
    axiom add_identity : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvxor(x, bvzero(n)) = x
    
    // Every element is its own additive inverse!
    axiom add_inverse : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvxor(x, x) = bvzero(n)
}
</code></pre>
<h3 id="2-boolean-algebra"><a class="header" href="#2-boolean-algebra">2. Boolean Algebra</a></h3>
<p>With AND, OR, and NOT, bit-vectors form a Boolean algebra:</p>
<pre><code class="language-kleis">structure BooleanAlgebra {
    // De Morgan's laws
    axiom demorgan_and : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvand(x, y)) = bvor(bvnot(x), bvnot(y))
    
    axiom demorgan_or : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvor(x, y)) = bvand(bvnot(x), bvnot(y))
    
    // Complement laws
    axiom and_complement : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvand(x, bvnot(x)) = bvzero(n)
    
    axiom or_complement : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvor(x, bvnot(x)) = bvones(n)
    
    // Distributive law
    axiom distribute : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvand(x, bvor(y, z)) = bvor(bvand(x, y), bvand(x, z))
}
</code></pre>
<h3 id="3-ordered-set"><a class="header" href="#3-ordered-set">3. Ordered Set</a></h3>
<p>Bit-vectors are totally ordered (both unsigned and signed):</p>
<pre><code class="language-kleis">structure TotalOrder {
    // Trichotomy: exactly one of &lt;, =, &gt; holds
    axiom trichotomy : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvult(x, y) ‚à® x = y ‚à® bvult(y, x)
    
    // Transitivity
    axiom transitive : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvult(x, y) ‚àß bvult(y, z) ‚Üí bvult(x, z)
}
</code></pre>
<h2 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h2>
<h3 id="logical-operations"><a class="header" href="#logical-operations">Logical Operations</a></h3>
<pre><code class="language-kleis">structure BitwiseLogic {
    // AND: set intersection on bit positions
    axiom and_idempotent : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvand(x, x) = x
    
    // OR: set union on bit positions  
    axiom or_idempotent : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvor(x, x) = x
    
    // XOR: symmetric difference
    axiom xor_self : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvxor(x, x) = bvzero(n)
    
    // NOT: complement
    axiom not_involution : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvnot(bvnot(x)) = x
}
</code></pre>
<h3 id="available-operations"><a class="header" href="#available-operations">Available Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>AND</td><td><code>bvand(x, y)</code></td><td>Bitwise AND</td></tr>
<tr><td>OR</td><td><code>bvor(x, y)</code></td><td>Bitwise OR</td></tr>
<tr><td>XOR</td><td><code>bvxor(x, y)</code></td><td>Bitwise XOR</td></tr>
<tr><td>NOT</td><td><code>bvnot(x)</code></td><td>Bitwise complement</td></tr>
</tbody>
</table>
</div>
<h2 id="arithmetic-operations-2"><a class="header" href="#arithmetic-operations-2">Arithmetic Operations</a></h2>
<p>Bit-vector arithmetic is <strong>modular</strong> (mod 2‚Åø):</p>
<pre><code class="language-kleis">structure ModularArithmetic {
    // Addition wraps around
    axiom add_commutative : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvadd(x, y) = bvadd(y, x)
    
    axiom add_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvadd(x, bvzero(n)) = x
    
    // Two's complement negation
    axiom neg_inverse : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvadd(x, bvneg(x)) = bvzero(n)
    
    // Multiplication distributes
    axiom mul_distribute : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvmul(x, bvadd(y, z)) = bvadd(bvmul(x, y), bvmul(x, z))
}
</code></pre>
<h3 id="available-operations-1"><a class="header" href="#available-operations-1">Available Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Add</td><td><code>bvadd(x, y)</code></td><td>Addition mod 2‚Åø</td></tr>
<tr><td>Subtract</td><td><code>bvsub(x, y)</code></td><td>Subtraction mod 2‚Åø</td></tr>
<tr><td>Multiply</td><td><code>bvmul(x, y)</code></td><td>Multiplication mod 2‚Åø</td></tr>
<tr><td>Negate</td><td><code>bvneg(x)</code></td><td>Two‚Äôs complement negation</td></tr>
<tr><td>Unsigned div</td><td><code>bvudiv(x, y)</code></td><td>Unsigned division</td></tr>
<tr><td>Signed div</td><td><code>bvsdiv(x, y)</code></td><td>Signed division</td></tr>
<tr><td>Unsigned rem</td><td><code>bvurem(x, y)</code></td><td>Unsigned remainder</td></tr>
</tbody>
</table>
</div>
<h2 id="shift-operations"><a class="header" href="#shift-operations">Shift Operations</a></h2>
<pre><code class="language-kleis">structure ShiftOps {
    // Left shift: multiply by 2·µè
    axiom shl_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvshl(x, bvzero(n)) = x
    
    // Logical right shift: divide by 2·µè (zero fill)
    axiom lshr_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvlshr(x, bvzero(n)) = x
    
    // Arithmetic right shift: divide by 2·µè (sign extend)
    axiom ashr_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvashr(x, bvzero(n)) = x
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Left shift</td><td><code>bvshl(x, k)</code></td><td>Shift left by k bits</td></tr>
<tr><td>Logical right</td><td><code>bvlshr(x, k)</code></td><td>Shift right, zero fill</td></tr>
<tr><td>Arithmetic right</td><td><code>bvashr(x, k)</code></td><td>Shift right, sign extend</td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-operations-1"><a class="header" href="#comparison-operations-1">Comparison Operations</a></h2>
<h3 id="unsigned-comparisons"><a class="header" href="#unsigned-comparisons">Unsigned Comparisons</a></h3>
<pre><code class="language-kleis">structure UnsignedCompare {
    axiom zero_minimum : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvule(bvzero(n), x)
    
    axiom ones_maximum : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvule(x, bvones(n))
}
</code></pre>
<h3 id="signed-comparisons"><a class="header" href="#signed-comparisons">Signed Comparisons</a></h3>
<pre><code class="language-kleis">structure SignedCompare {
    // In two's complement, high bit indicates negative
    axiom signed_negative : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bit(x, n - 1) = 1 ‚Üí bvslt(x, bvzero(n))
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unsigned</th><th>Signed</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bvult(x, y)</code></td><td><code>bvslt(x, y)</code></td><td>Less than</td></tr>
<tr><td><code>bvule(x, y)</code></td><td><code>bvsle(x, y)</code></td><td>Less or equal</td></tr>
<tr><td><code>bvugt(x, y)</code></td><td><code>bvsgt(x, y)</code></td><td>Greater than</td></tr>
<tr><td><code>bvuge(x, y)</code></td><td><code>bvsge(x, y)</code></td><td>Greater or equal</td></tr>
</tbody>
</table>
</div>
<h2 id="construction-and-extraction"><a class="header" href="#construction-and-extraction">Construction and Extraction</a></h2>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<pre><code class="language-kleis">structure Constants {
    // Zero vector (all bits 0)
    axiom zero_all : ‚àÄ(n : ‚Ñï)(i : ‚Ñï). i &lt; n ‚Üí bit(bvzero(n), i) = 0
    
    // Ones vector (all bits 1)
    axiom ones_all : ‚àÄ(n : ‚Ñï)(i : ‚Ñï). i &lt; n ‚Üí bit(bvones(n), i) = 1
    
    // Single 1 in lowest position
    axiom one_bit : bit(bvone(8), 0) = 1
}
</code></pre>
<h3 id="bit-extraction"><a class="header" href="#bit-extraction">Bit Extraction</a></h3>
<pre><code class="language-kleis">structure BitExtraction {
    // Get individual bit
    axiom bit_range : ‚àÄ(n : ‚Ñï)(x : BitVec(n))(i : ‚Ñï). 
        i &lt; n ‚Üí (bit(x, i) = 0 ‚à® bit(x, i) = 1)
    
    // Extract slice [high:low]
    axiom extract_width : ‚àÄ(n high low : ‚Ñï)(x : BitVec(n)).
        high ‚â• low ‚àß high &lt; n ‚Üí width(extract(high, low, x)) = high - low + 1
}
</code></pre>
<h3 id="extension"><a class="header" href="#extension">Extension</a></h3>
<pre><code class="language-kleis">structure Extension {
    // Zero extension (for unsigned)
    axiom zext_preserves : ‚àÄ(n m : ‚Ñï)(x : BitVec(n)).
        m ‚â• n ‚Üí bvult(x, bvzero(n)) = bvult(zext(m, x), bvzero(m))
    
    // Sign extension (for signed)
    axiom sext_preserves : ‚àÄ(n m : ‚Ñï)(x : BitVec(n)).
        m ‚â• n ‚Üí bvslt(x, bvzero(n)) = bvslt(sext(m, x), bvzero(m))
}
</code></pre>
<h2 id="z3-verification-2"><a class="header" href="#z3-verification-2">Z3 Verification</a></h2>
<p>Kleis maps bit-vector operations directly to Z3‚Äôs native BitVec theory:</p>
<pre><code class="language-kleis">structure Z3BitVecExample {
    // XOR properties verified by Z3
    axiom xor_cancel : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvxor(x, x) = bvzero(n)
    
    // De Morgan verified
    axiom demorgan : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvand(x, y)) = bvor(bvnot(x), bvnot(y))
    
    // Arithmetic properties
    axiom add_neg : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvadd(x, bvneg(x)) = bvzero(n)
}
</code></pre>
<h2 id="example-cryptographic-rotation"><a class="header" href="#example-cryptographic-rotation">Example: Cryptographic Rotation</a></h2>
<pre><code class="language-kleis">structure RotateExample {
    // Left rotation by k bits
    define rotl(n : ‚Ñï, x : BitVec(n), k : BitVec(n)) : BitVec(n) =
        bvor(bvshl(x, k), bvlshr(x, bvsub(bvone(n) * n, k)))
    
    // Right rotation by k bits
    define rotr(n : ‚Ñï, x : BitVec(n), k : BitVec(n)) : BitVec(n) =
        bvor(bvlshr(x, k), bvshl(x, bvsub(bvone(n) * n, k)))
    
    // Rotation is its own inverse
    axiom rotate_inverse : ‚àÄ(n k : ‚Ñï)(x : BitVec(n)).
        rotr(n, rotl(n, x, k), k) = x
}
</code></pre>
<h2 id="example-bit-manipulation"><a class="header" href="#example-bit-manipulation">Example: Bit Manipulation</a></h2>
<pre><code class="language-kleis">structure BitManipulation {
    // Set bit i to 1
    define set_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvor(x, bvshl(bvone(n), i))
    
    // Clear bit i to 0
    define clear_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvand(x, bvnot(bvshl(bvone(n), i)))
    
    // Toggle bit i
    define toggle_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvxor(x, bvshl(bvone(n), i))
    
    // Test if bit i is set
    define test_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : Bool =
        bvand(x, bvshl(bvone(n), i)) ‚â† bvzero(n)
}
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Operations</th></tr>
</thead>
<tbody>
<tr><td><strong>Bitwise</strong></td><td><code>bvand</code>, <code>bvor</code>, <code>bvxor</code>, <code>bvnot</code></td></tr>
<tr><td><strong>Arithmetic</strong></td><td><code>bvadd</code>, <code>bvsub</code>, <code>bvmul</code>, <code>bvneg</code>, <code>bvudiv</code>, <code>bvsdiv</code>, <code>bvurem</code></td></tr>
<tr><td><strong>Shift</strong></td><td><code>bvshl</code>, <code>bvlshr</code>, <code>bvashr</code></td></tr>
<tr><td><strong>Unsigned compare</strong></td><td><code>bvult</code>, <code>bvule</code>, <code>bvugt</code>, <code>bvuge</code></td></tr>
<tr><td><strong>Signed compare</strong></td><td><code>bvslt</code>, <code>bvsle</code>, <code>bvsgt</code>, <code>bvsge</code></td></tr>
<tr><td><strong>Construction</strong></td><td><code>bvzero</code>, <code>bvones</code>, <code>bvone</code>, <code>extract</code>, <code>zext</code>, <code>sext</code></td></tr>
</tbody>
</table>
</div>
<p>See <code>stdlib/bitvector.kleis</code> for the complete axiom set.</p>
<h2 id="whats-next-17"><a class="header" href="#whats-next-17">What‚Äôs Next?</a></h2>
<p>Learn about string operations and Z3‚Äôs string theory:</p>
<p>‚Üí <a href="#strings">Strings</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Kleis provides comprehensive support for <strong>string operations</strong> via Z3‚Äôs QF_SLIA (Quantifier-Free Strings and Linear Integer Arithmetic) theory. This enables formal verification of string-manipulating programs.</p>
<h2 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h2>
<pre><code class="language-kleis">define greeting : String = "Hello, World!"
define empty : String = ""
</code></pre>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h2>
<h3 id="concatenation"><a class="header" href="#concatenation">Concatenation</a></h3>
<pre><code class="language-kleis">structure StringConcat {
    // Concatenation
    axiom concat_ex : concat("Hello", " World") = "Hello World"
    
    // Empty string is identity
    axiom concat_empty_left : ‚àÄ(s : String). concat("", s) = s
    axiom concat_empty_right : ‚àÄ(s : String). concat(s, "") = s
    
    // Associativity
    axiom concat_assoc : ‚àÄ(a b c : String). 
        concat(concat(a, b), c) = concat(a, concat(b, c))
}
</code></pre>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<pre><code class="language-kleis">structure StringLength {
    axiom len_hello : strlen("Hello") = 5
    axiom len_empty : strlen("") = 0
    
    // Length of concatenation
    axiom len_concat : ‚àÄ(a b : String). 
        strlen(concat(a, b)) = strlen(a) + strlen(b)
    
    // Length is non-negative
    axiom len_nonneg : ‚àÄ(s : String). strlen(s) ‚â• 0
}
</code></pre>
<h2 id="substring-operations"><a class="header" href="#substring-operations">Substring Operations</a></h2>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<p>Check if one string contains another:</p>
<pre><code class="language-kleis">structure StringContains {
    axiom contains_ex : contains("Hello World", "World") = true
    axiom contains_empty : ‚àÄ(s : String). contains(s, "") = true
    axiom contains_self : ‚àÄ(s : String). contains(s, s) = true
}
</code></pre>
<h3 id="prefix-and-suffix"><a class="header" href="#prefix-and-suffix">Prefix and Suffix</a></h3>
<pre><code class="language-kleis">structure PrefixSuffix {
    // Prefix check
    axiom prefix_ex : hasPrefix("Hello World", "Hello") = true
    axiom prefix_empty : ‚àÄ(s : String). hasPrefix(s, "") = true
    
    // Suffix check
    axiom suffix_ex : hasSuffix("Hello World", "World") = true
    axiom suffix_empty : ‚àÄ(s : String). hasSuffix(s, "") = true
}
</code></pre>
<h3 id="substring-extraction"><a class="header" href="#substring-extraction">Substring Extraction</a></h3>
<pre><code class="language-kleis">structure Substring {
    // substr(s, start, length) extracts substring
    axiom substr_ex : substr("Hello World", 0, 5) = "Hello"
    axiom substr_middle : substr("Hello World", 6, 5) = "World"
    
    // Empty substring
    axiom substr_zero : ‚àÄ(s : String)(i : ‚Ñï). substr(s, i, 0) = ""
}
</code></pre>
<h3 id="character-access"><a class="header" href="#character-access">Character Access</a></h3>
<pre><code class="language-kleis">structure CharAt {
    // charAt(s, i) returns single character at index i
    axiom charAt_ex : charAt("Hello", 0) = "H"
    axiom charAt_last : charAt("Hello", 4) = "o"
}
</code></pre>
<h3 id="index-of"><a class="header" href="#index-of">Index Of</a></h3>
<pre><code class="language-kleis">structure IndexOf {
    // indexOf(s, pattern, start) returns first index of pattern
    axiom indexOf_ex : indexOf("Hello World", "o", 0) = 4
    axiom indexOf_second : indexOf("Hello World", "o", 5) = 7
    
    // Not found returns -1
    axiom indexOf_notfound : indexOf("Hello", "z", 0) = 0 - 1
}
</code></pre>
<h3 id="replace"><a class="header" href="#replace">Replace</a></h3>
<pre><code class="language-kleis">structure StringReplace {
    // replace(s, old, new) replaces first occurrence
    axiom replace_ex : replace("Hello World", "World", "Kleis") = "Hello Kleis"
    
    // No match means no change
    axiom replace_nomatch : ‚àÄ(s : String). 
        ¬¨contains(s, "xyz") ‚Üí replace(s, "xyz", "abc") = s
}
</code></pre>
<h2 id="string-integer-conversion"><a class="header" href="#string-integer-conversion">String-Integer Conversion</a></h2>
<h3 id="string-to-integer"><a class="header" href="#string-to-integer">String to Integer</a></h3>
<pre><code class="language-kleis">structure StrToInt {
    axiom str_to_int_ex : strToInt("42") = 42
    axiom str_to_int_neg : strToInt("-17") = 0 - 17
    axiom str_to_int_zero : strToInt("0") = 0
}
</code></pre>
<h3 id="integer-to-string"><a class="header" href="#integer-to-string">Integer to String</a></h3>
<pre><code class="language-kleis">structure IntToStr {
    axiom int_to_str_ex : intToStr(42) = "42"
    axiom int_to_str_neg : intToStr(0 - 17) = "-17"
    axiom int_to_str_zero : intToStr(0) = "0"
}
</code></pre>
<h3 id="round-trip-property"><a class="header" href="#round-trip-property">Round-trip Property</a></h3>
<pre><code class="language-kleis">structure Roundtrip {
    // Converting back and forth preserves value
    axiom roundtrip_int : ‚àÄ(n : ‚Ñ§). strToInt(intToStr(n)) = n
    
    // For valid numeric strings
    axiom roundtrip_str : ‚àÄ(s : String). 
        isDigits(s) ‚Üí intToStr(strToInt(s)) = s
}
</code></pre>
<h2 id="regular-expressions"><a class="header" href="#regular-expressions">Regular Expressions</a></h2>
<p>Kleis supports regular expression matching via Z3‚Äôs regex theory:</p>
<pre><code class="language-kleis">structure RegexMatch {
    // Check if string matches pattern
    axiom digits_match : matchesRegex("12345", "[0-9]+") = true
    axiom alpha_match : matchesRegex("Hello", "[A-Za-z]+") = true
    
    // Built-in character class predicates
    axiom is_digits : isDigits("12345") = true
    axiom is_alpha : isAlpha("Hello") = true
    axiom is_alphanum : isAlphaNum("Test123") = true
}
</code></pre>
<h2 id="z3-verification-3"><a class="header" href="#z3-verification-3">Z3 Verification</a></h2>
<p>String properties are verified using Z3‚Äôs native string theory:</p>
<pre><code class="language-kleis">structure Z3StringProofs {
    // Concatenation properties
    axiom concat_length : ‚àÄ(a b : String). 
        strlen(concat(a, b)) = strlen(a) + strlen(b)
    
    // Contains implies length relationship
    axiom contains_length : ‚àÄ(s t : String). 
        contains(s, t) ‚Üí strlen(s) ‚â• strlen(t)
    
    // Prefix implies contains
    axiom prefix_contains : ‚àÄ(s t : String). 
        hasPrefix(s, t) ‚Üí contains(s, t)
}
</code></pre>
<h2 id="monoid-structure"><a class="header" href="#monoid-structure">Monoid Structure</a></h2>
<p>Strings form a <strong>monoid</strong> under concatenation:</p>
<pre><code class="language-kleis">implements Monoid(String) {
    operation identity = ""
    operation mul = concat
}

// Monoid laws hold:
// 1. concat("", s) = s           (left identity)
// 2. concat(s, "") = s           (right identity)
// 3. concat(a, concat(b, c)) 
//    = concat(concat(a, b), c)   (associativity)
</code></pre>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="email-validation"><a class="header" href="#email-validation">Email Validation</a></h3>
<pre><code class="language-kleis">structure EmailValidation {
    define isValidEmail(email : String) : Bool =
        contains(email, "@") ‚àß 
        contains(email, ".") ‚àß
        indexOf(email, "@", 0) &lt; indexOf(email, ".", 0)
    
    axiom valid_ex : isValidEmail("user@example.com") = true
    axiom invalid_ex : isValidEmail("invalid") = false
}
</code></pre>
<h3 id="url-parsing"><a class="header" href="#url-parsing">URL Parsing</a></h3>
<pre><code class="language-kleis">structure URLParsing {
    define getProtocol(url : String) : String =
        substr(url, 0, indexOf(url, "://", 0))
    
    axiom http_ex : getProtocol("https://kleis.io") = "https"
}
</code></pre>
<h3 id="string-builder-pattern"><a class="header" href="#string-builder-pattern">String Builder Pattern</a></h3>
<pre><code class="language-kleis">structure StringBuilder {
    define join(sep : String, a : String, b : String) : String =
        concat(concat(a, sep), b)
    
    axiom join_ex : join(", ", "Hello", "World") = "Hello, World"
}
</code></pre>
<h2 id="operation-reference-1"><a class="header" href="#operation-reference-1">Operation Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Concatenate</td><td><code>concat(a, b)</code></td><td>Join two strings</td></tr>
<tr><td>Length</td><td><code>strlen(s)</code></td><td>Character count</td></tr>
<tr><td>Contains</td><td><code>contains(s, t)</code></td><td>Check substring</td></tr>
<tr><td>Prefix</td><td><code>hasPrefix(s, t)</code></td><td>Check prefix</td></tr>
<tr><td>Suffix</td><td><code>hasSuffix(s, t)</code></td><td>Check suffix</td></tr>
<tr><td>Substring</td><td><code>substr(s, i, n)</code></td><td>Extract n chars from i</td></tr>
<tr><td>Character</td><td><code>charAt(s, i)</code></td><td>Get char at index</td></tr>
<tr><td>Index</td><td><code>indexOf(s, t, i)</code></td><td>Find substring from i</td></tr>
<tr><td>Replace</td><td><code>replace(s, old, new)</code></td><td>Replace first match</td></tr>
<tr><td>To Int</td><td><code>strToInt(s)</code></td><td>Parse integer</td></tr>
<tr><td>From Int</td><td><code>intToStr(n)</code></td><td>Format integer</td></tr>
<tr><td>Regex</td><td><code>matchesRegex(s, r)</code></td><td>Match pattern</td></tr>
</tbody>
</table>
</div>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Basic operations</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Substring ops</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Regex matching</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Int conversion</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Monoid structure</td><td>‚úÖ Algebraic</td></tr>
</tbody>
</table>
</div>
<p>See <code>src/solvers/z3/capabilities.toml</code> for the complete list of supported string operations.</p>
<h2 id="whats-next-18"><a class="header" href="#whats-next-18">What‚Äôs Next?</a></h2>
<p>Explore set theory operations and Z3‚Äôs set reasoning:</p>
<p>‚Üí <a href="#set-theory">Sets</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="set-theory"><a class="header" href="#set-theory">Set Theory</a></h1>
<p>Kleis provides native set theory support backed by Z3‚Äôs set theory solver. This enables rigorous mathematical reasoning about collections, membership, and set operations.</p>
<h2 id="importing-set-theory"><a class="header" href="#importing-set-theory">Importing Set Theory</a></h2>
<pre><code class="language-kleis">import "stdlib/sets.kleis"
</code></pre>
<p>This imports the <code>SetTheory(T)</code> structure with all operations and axioms.</p>
<h2 id="constructing-sets"><a class="header" href="#constructing-sets">Constructing Sets</a></h2>
<p>Sets are built using <code>empty_set()</code> and <code>insert()</code>:</p>
<pre><code class="language-kleis">// Empty set (note the parentheses!)
empty_set()

// Singleton set {5}
insert(5, empty_set())

// Set {1, 2, 3}
insert(3, insert(2, insert(1, empty_set())))

// Shorthand: singleton(x) creates {x}
singleton(5)
</code></pre>
<p><strong>Important:</strong> Use <code>empty_set()</code> with parentheses (it‚Äôs a nullary function).</p>
<h3 id="verification-example"><a class="header" href="#verification-example">Verification Example</a></h3>
<pre><code>Œª&gt; :load stdlib/sets.kleis
Œª&gt; :sat in_set(2, insert(3, insert(2, insert(1, empty_set()))))
‚úÖ Satisfiable (2 IS in {1,2,3})

Œª&gt; :sat in_set(5, insert(3, insert(2, insert(1, empty_set()))))
‚ùå Unsatisfiable (5 is NOT in {1,2,3})

Œª&gt; :sat subset(insert(1, empty_set()), insert(2, insert(1, empty_set())))
‚úÖ Satisfiable ({1} ‚äÜ {1,2})
</code></pre>
<h2 id="basic-operations-1"><a class="header" href="#basic-operations-1">Basic Operations</a></h2>
<h3 id="set-membership"><a class="header" href="#set-membership">Set Membership</a></h3>
<pre><code class="language-kleis">// Check if element x is in set S
in_set(x, S)  // Returns Bool

// Example: Define a membership property
structure ClosedUnderAddition {
    axiom closed: ‚àÄ(S : Set(‚Ñ§), x y : ‚Ñ§). 
        in_set(x, S) ‚àß in_set(y, S) ‚Üí in_set(x + y, S)
}
</code></pre>
<h3 id="set-construction"><a class="header" href="#set-construction">Set Construction</a></h3>
<pre><code class="language-kleis">empty_set        // The empty set ‚àÖ
singleton(x)     // Set containing just x: {x}
insert(x, S)     // Add x to S: S ‚à™ {x}
remove(x, S)     // Remove x from S: S \ {x}
</code></pre>
<h3 id="set-operations"><a class="header" href="#set-operations">Set Operations</a></h3>
<pre><code class="language-kleis">union(A, B)       // Union: A ‚à™ B
intersect(A, B)   // Intersection: A ‚à© B
difference(A, B)  // Difference: A \ B
complement(A)     // Complement: ·∂úA
</code></pre>
<h3 id="set-relations"><a class="header" href="#set-relations">Set Relations</a></h3>
<pre><code class="language-kleis">subset(A, B)         // Subset: A ‚äÜ B
proper_subset(A, B)  // Proper subset: A ‚äÇ B (A ‚äÜ B and A ‚â† B)
</code></pre>
<h2 id="verification-example-1"><a class="header" href="#verification-example-1">Verification Example</a></h2>
<p>Here‚Äôs a complete example proving De Morgan‚Äôs laws:</p>
<pre><code class="language-kleis">import "stdlib/sets.kleis"

// Verify De Morgan's law: complement(A ‚à™ B) = complement(A) ‚à© complement(B)
structure DeMorganProof(T) {
    axiom de_morgan_union: ‚àÄ(A B : Set(T)).
        complement(union(A, B)) = intersect(complement(A), complement(B))
}
</code></pre>
<p>In the REPL:</p>
<pre><code>Œª&gt; :load stdlib/sets.kleis
‚úÖ Loaded stdlib/sets.kleis

Œª&gt; :verify ‚àÄ(A B : Set(‚Ñ§), x : ‚Ñ§). in_set(x, complement(union(A, B))) ‚Üî (¬¨in_set(x, A) ‚àß ¬¨in_set(x, B))
‚úÖ Valid (follows from axioms)
</code></pre>
<h2 id="mathematical-structures-with-sets"><a class="header" href="#mathematical-structures-with-sets">Mathematical Structures with Sets</a></h2>
<h3 id="open-balls-in-metric-spaces"><a class="header" href="#open-balls-in-metric-spaces">Open Balls in Metric Spaces</a></h3>
<pre><code class="language-kleis">import "stdlib/sets.kleis"

structure MetricSpace(X) {
    operation d : X ‚Üí X ‚Üí ‚Ñù
    
    // Metric axioms
    axiom positive: ‚àÄ(x y : X). d(x, y) &gt;= 0
    axiom zero_iff_equal: ‚àÄ(x y : X). d(x, y) = 0 ‚Üî x = y
    axiom symmetric: ‚àÄ(x y : X). d(x, y) = d(y, x)
    axiom triangle: ‚àÄ(x y z : X). d(x, z) &lt;= d(x, y) + d(y, z)
}

structure OpenBalls(X) {
    operation d : X ‚Üí X ‚Üí ‚Ñù
    operation ball : X ‚Üí ‚Ñù ‚Üí Set(X)
    
    // x is in ball(center, r) iff d(x, center) &lt; r
    axiom ball_def: ‚àÄ(center : X, r : ‚Ñù, x : X).
        in_set(x, ball(center, r)) ‚Üî d(x, center) &lt; r
    
    // Open balls are non-empty when radius is positive
    axiom ball_nonempty: ‚àÄ(center : X, r : ‚Ñù).
        r &gt; 0 ‚Üí in_set(center, ball(center, r))
}
</code></pre>
<h3 id="measure-spaces"><a class="header" href="#measure-spaces">Measure Spaces</a></h3>
<pre><code class="language-kleis">import "stdlib/sets.kleis"

structure MeasureSpace(X) {
    element sigma_algebra : Set(Set(X))
    operation measure : Set(X) ‚Üí ‚Ñù
    
    // œÉ-algebra contains empty set
    axiom contains_empty: in_set(empty_set, sigma_algebra)
    
    // Closed under complement
    axiom closed_complement: ‚àÄ(A : Set(X)).
        in_set(A, sigma_algebra) ‚Üí in_set(complement(A), sigma_algebra)
    
    // Measure is non-negative
    axiom measure_positive: ‚àÄ(A : Set(X)). measure(A) &gt;= 0
    
    // Measure of empty set is zero
    axiom measure_empty: measure(empty_set) = 0
}
</code></pre>
<h2 id="full-axiom-reference"><a class="header" href="#full-axiom-reference">Full Axiom Reference</a></h2>
<p>The <code>SetTheory(T)</code> structure includes these axioms:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Axiom</th><th>Statement</th></tr>
</thead>
<tbody>
<tr><td>Extensionality</td><td><code>‚àÄ(A B). (‚àÄx. x ‚àà A ‚Üî x ‚àà B) ‚Üí A = B</code></td></tr>
<tr><td>Empty Set</td><td><code>‚àÄx. ¬¨(x ‚àà ‚àÖ)</code></td></tr>
<tr><td>Singleton</td><td><code>‚àÄx y. y ‚àà {x} ‚Üî y = x</code></td></tr>
<tr><td>Union</td><td><code>‚àÄ(A B) x. x ‚àà A‚à™B ‚Üî (x ‚àà A ‚à® x ‚àà B)</code></td></tr>
<tr><td>Intersection</td><td><code>‚àÄ(A B) x. x ‚àà A‚à©B ‚Üî (x ‚àà A ‚àß x ‚àà B)</code></td></tr>
<tr><td>Difference</td><td><code>‚àÄ(A B) x. x ‚àà A\B ‚Üî (x ‚àà A ‚àß ¬¨(x ‚àà B))</code></td></tr>
<tr><td>Complement</td><td><code>‚àÄA x. x ‚àà A·∂ú ‚Üî ¬¨(x ‚àà A)</code></td></tr>
<tr><td>Subset</td><td><code>‚àÄ(A B). A ‚äÜ B ‚Üî (‚àÄx. x ‚àà A ‚Üí x ‚àà B)</code></td></tr>
<tr><td>De Morgan (Union)</td><td><code>‚àÄ(A B). (A‚à™B)·∂ú = A·∂ú ‚à© B·∂ú</code></td></tr>
<tr><td>De Morgan (Intersection)</td><td><code>‚àÄ(A B). (A‚à©B)·∂ú = A·∂ú ‚à™ B·∂ú</code></td></tr>
<tr><td>Double Complement</td><td><code>‚àÄA. (A·∂ú)·∂ú = A</code></td></tr>
</tbody>
</table>
</div>
<h2 id="unicode-operators-future"><a class="header" href="#unicode-operators-future">Unicode Operators (Future)</a></h2>
<p>Currently, you must use function-style syntax. Future versions will support:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>Function Style</th></tr>
</thead>
<tbody>
<tr><td><code>x ‚àà S</code></td><td><code>in_set(x, S)</code></td></tr>
<tr><td><code>A ‚äÜ B</code></td><td><code>subset(A, B)</code></td></tr>
<tr><td><code>A ‚à™ B</code></td><td><code>union(A, B)</code></td></tr>
<tr><td><code>A ‚à© B</code></td><td><code>intersect(A, B)</code></td></tr>
<tr><td><code>A \ B</code></td><td><code>difference(A, B)</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-19"><a class="header" href="#whats-next-19">What‚Äôs Next?</a></h2>
<p>Learn about matrix and vector operations for linear algebra:</p>
<p>‚Üí <a href="#matrices">Matrices</a></p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="#types-and-values">Types and Values</a> ‚Äî <code>Set(T)</code> type documentation</li>
<li><a href="#z3-verification">Z3 Verification</a> ‚Äî Using Z3 for proofs</li>
<li><a href="#structures">Structures</a> ‚Äî Defining mathematical structures</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="matrices"><a class="header" href="#matrices">Matrices</a></h1>
<p>Kleis provides comprehensive matrix support with both symbolic verification (via Z3) and concrete evaluation (via <code>:eval</code>).</p>
<h2 id="matrix-type"><a class="header" href="#matrix-type">Matrix Type</a></h2>
<p>Matrices are parametric types with dimensions:</p>
<pre><code class="language-kleis">Matrix(m, n, T)   // m rows √ó n columns of type T
</code></pre>
<p>Examples:</p>
<ul>
<li><code>Matrix(2, 2, ‚Ñù)</code> - 2√ó2 matrix of reals</li>
<li><code>Matrix(3, 4, ‚ÑÇ)</code> - 3√ó4 matrix of complex numbers</li>
</ul>
<h2 id="creating-matrices"><a class="header" href="#creating-matrices">Creating Matrices</a></h2>
<p>Use the <code>Matrix</code> constructor with dimensions and a list of elements (row-major order):</p>
<pre><code class="language-kleis">// 2√ó2 matrix: [[1, 2], [3, 4]]
Matrix(2, 2, [1, 2, 3, 4])

// 2√ó3 matrix: [[1, 2, 3], [4, 5, 6]]
Matrix(2, 3, [1, 2, 3, 4, 5, 6])
</code></pre>
<h2 id="arithmetic-operations-3"><a class="header" href="#arithmetic-operations-3">Arithmetic Operations</a></h2>
<h3 id="addition-and-subtraction-1"><a class="header" href="#addition-and-subtraction-1">Addition and Subtraction</a></h3>
<p>Element-wise operations for matrices of the same dimensions:</p>
<pre><code class="language-kleis">:eval matrix_add(Matrix(2, 2, [1, 2, 3, 4]), Matrix(2, 2, [5, 6, 7, 8]))
// ‚Üí Matrix(2, 2, [6, 8, 10, 12])

:eval matrix_sub(Matrix(2, 2, [10, 20, 30, 40]), Matrix(2, 2, [1, 2, 3, 4]))
// ‚Üí Matrix(2, 2, [9, 18, 27, 36])
</code></pre>
<h3 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix Multiplication</a></h3>
<p>True matrix multiplication <code>(m√ón) ¬∑ (n√óp) ‚Üí (m√óp)</code>:</p>
<pre><code class="language-kleis">:eval multiply(Matrix(2, 2, [1, 2, 3, 4]), Matrix(2, 2, [5, 6, 7, 8]))
// ‚Üí Matrix(2, 2, [19, 22, 43, 50])

// Non-square: (2√ó3) ¬∑ (3√ó2) ‚Üí (2√ó2)
:eval multiply(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), Matrix(3, 2, [1, 2, 3, 4, 5, 6]))
// ‚Üí Matrix(2, 2, [22, 28, 49, 64])
</code></pre>
<h3 id="scalar-multiplication"><a class="header" href="#scalar-multiplication">Scalar Multiplication</a></h3>
<p>Multiply all elements by a scalar:</p>
<pre><code class="language-kleis">:eval scalar_matrix_mul(3, Matrix(2, 2, [1, 2, 3, 4]))
// ‚Üí Matrix(2, 2, [3, 6, 9, 12])
</code></pre>
<h2 id="matrix-properties"><a class="header" href="#matrix-properties">Matrix Properties</a></h2>
<h3 id="transpose"><a class="header" href="#transpose">Transpose</a></h3>
<p>Swap rows and columns <code>(m√ón) ‚Üí (n√óm)</code>:</p>
<pre><code class="language-kleis">:eval transpose(Matrix(2, 3, [1, 2, 3, 4, 5, 6]))
// ‚Üí Matrix(3, 2, [1, 4, 2, 5, 3, 6])
</code></pre>
<h3 id="trace"><a class="header" href="#trace">Trace</a></h3>
<p>Sum of diagonal elements (square matrices only):</p>
<pre><code class="language-kleis">:eval trace(Matrix(3, 3, [1, 0, 0, 0, 2, 0, 0, 0, 3]))
// ‚Üí 6
</code></pre>
<h3 id="determinant"><a class="header" href="#determinant">Determinant</a></h3>
<p>Determinant for 1√ó1, 2√ó2, and 3√ó3 matrices:</p>
<pre><code class="language-kleis">:eval det(Matrix(2, 2, [4, 3, 6, 8]))
// ‚Üí 14  (4*8 - 3*6)

:eval det(Matrix(3, 3, [1, 2, 3, 0, 1, 4, 5, 6, 0]))
// ‚Üí 1
</code></pre>
<h2 id="element-extraction"><a class="header" href="#element-extraction">Element Extraction</a></h2>
<h3 id="get-single-element"><a class="header" href="#get-single-element">Get Single Element</a></h3>
<p>Access element at row <code>i</code>, column <code>j</code> (0-indexed):</p>
<pre><code class="language-kleis">:eval matrix_get(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 0, 2)
// ‚Üí 3  (row 0, column 2)

:eval matrix_get(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 1, 1)
// ‚Üí 5  (row 1, column 1)
</code></pre>
<h3 id="get-row-or-column"><a class="header" href="#get-row-or-column">Get Row or Column</a></h3>
<p>Extract entire row or column as a list:</p>
<pre><code class="language-kleis">:eval matrix_row(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 0)
// ‚Üí [1, 2, 3]

:eval matrix_row(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 1)
// ‚Üí [4, 5, 6]

:eval matrix_col(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 0)
// ‚Üí [1, 4]

:eval matrix_col(Matrix(2, 3, [1, 2, 3, 4, 5, 6]), 2)
// ‚Üí [3, 6]
</code></pre>
<h3 id="get-diagonal"><a class="header" href="#get-diagonal">Get Diagonal</a></h3>
<p>Extract diagonal elements as a list:</p>
<pre><code class="language-kleis">:eval matrix_diag(Matrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
// ‚Üí [1, 5, 9]
</code></pre>
<h2 id="row-and-column-manipulation"><a class="header" href="#row-and-column-manipulation">Row and Column Manipulation</a></h2>
<h3 id="stacking-matrices"><a class="header" href="#stacking-matrices">Stacking Matrices</a></h3>
<p>Combine matrices vertically or horizontally:</p>
<pre><code>Œª&gt; :let A = matrix([[1, 2], [3, 4]])
Œª&gt; :let B = matrix([[5, 6], [7, 8]])

Œª&gt; :eval vstack(A, B)
‚úÖ Matrix(4, 2, [1, 2, 3, 4, 5, 6, 7, 8])  // A on top, B below

Œª&gt; :eval hstack(A, B)
‚úÖ Matrix(2, 4, [1, 2, 5, 6, 3, 4, 7, 8])  // A left, B right
</code></pre>
<h3 id="appending-rows-and-columns"><a class="header" href="#appending-rows-and-columns">Appending Rows and Columns</a></h3>
<p>Add a single row or column:</p>
<pre><code>Œª&gt; :let A = matrix([[1, 2], [3, 4]])

Œª&gt; :eval append_row(A, [5, 6])
‚úÖ Matrix(3, 2, [1, 2, 3, 4, 5, 6])  // Row added at bottom

Œª&gt; :eval prepend_row([0, 0], A)
‚úÖ Matrix(3, 2, [0, 0, 1, 2, 3, 4])  // Row added at top

Œª&gt; :eval append_col(A, [10, 20])
‚úÖ Matrix(2, 3, [1, 2, 10, 3, 4, 20])  // Column added at right

Œª&gt; :eval prepend_col([10, 20], A)
‚úÖ Matrix(2, 3, [10, 1, 2, 20, 3, 4])  // Column added at left
</code></pre>
<h3 id="building-augmented-matrices"><a class="header" href="#building-augmented-matrices">Building Augmented Matrices</a></h3>
<p>Useful for linear algebra (solving <code>Ax = b</code>):</p>
<pre><code>Œª&gt; :let A = matrix([[1, 2], [3, 4]])
Œª&gt; :let b = matrix([[5], [6]])
Œª&gt; :eval hstack(A, b)
‚úÖ Matrix(2, 3, [1, 2, 5, 3, 4, 6])  // [A | b]
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Signature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>vstack(A, B)</code></td><td>m√ón, k√ón ‚Üí (m+k)√ón</td><td>Stack rows</td></tr>
<tr><td><code>hstack(A, B)</code></td><td>m√ón, m√ók ‚Üí m√ó(n+k)</td><td>Stack columns</td></tr>
<tr><td><code>append_row(M, r)</code></td><td>m√ón, [n] ‚Üí (m+1)√ón</td><td>Add row at bottom</td></tr>
<tr><td><code>prepend_row(r, M)</code></td><td>[n], m√ón ‚Üí (m+1)√ón</td><td>Add row at top</td></tr>
<tr><td><code>append_col(M, c)</code></td><td>m√ón, [m] ‚Üí m√ó(n+1)</td><td>Add column at right</td></tr>
<tr><td><code>prepend_col(c, M)</code></td><td>[m], m√ón ‚Üí m√ó(n+1)</td><td>Add column at left</td></tr>
</tbody>
</table>
</div>
<h2 id="setting-values"><a class="header" href="#setting-values">Setting Values</a></h2>
<p>Kleis matrices are immutable, but you can create new matrices with modified values:</p>
<h3 id="set-individual-element"><a class="header" href="#set-individual-element">Set Individual Element</a></h3>
<pre><code>Œª&gt; :let A = zeros(3, 3)
Œª&gt; :eval A
‚úÖ matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]])

Œª&gt; :eval set_element(A, 1, 1, 99)
‚úÖ matrix([[0, 0, 0], [0, 99, 0], [0, 0, 0]])
</code></pre>
<h3 id="set-row-or-column"><a class="header" href="#set-row-or-column">Set Row or Column</a></h3>
<pre><code>Œª&gt; :eval set_row(zeros(3, 3), 0, [1, 2, 3])
‚úÖ matrix([[1, 2, 3], [0, 0, 0], [0, 0, 0]])

Œª&gt; :eval set_col(zeros(3, 3), 2, [7, 8, 9])
‚úÖ matrix([[0, 0, 7], [0, 0, 8], [0, 0, 9]])
</code></pre>
<h3 id="set-diagonal"><a class="header" href="#set-diagonal">Set Diagonal</a></h3>
<pre><code>Œª&gt; :eval set_diag(zeros(3, 3), [1, 2, 3])
‚úÖ matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Signature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>set_element(M, i, j, v)</code></td><td>m√ón ‚Üí m√ón</td><td>Set element at (i,j)</td></tr>
<tr><td><code>set_row(M, i, [v...])</code></td><td>m√ón ‚Üí m√ón</td><td>Set row i</td></tr>
<tr><td><code>set_col(M, j, [v...])</code></td><td>m√ón ‚Üí m√ón</td><td>Set column j</td></tr>
<tr><td><code>set_diag(M, [v...])</code></td><td>n√ón ‚Üí n√ón</td><td>Set diagonal</td></tr>
</tbody>
</table>
</div>
<h2 id="matrix-size"><a class="header" href="#matrix-size">Matrix Size</a></h2>
<pre><code>Œª&gt; :let A = matrix([[1, 2, 3], [4, 5, 6]])
Œª&gt; :eval size(A)
‚úÖ [2, 3]

Œª&gt; :eval nrows(A)
‚úÖ 2

Œª&gt; :eval ncols(A)
‚úÖ 3
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Result</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>size(M)</code></td><td><code>[m, n]</code></td><td>Get dimensions as list</td></tr>
<tr><td><code>nrows(M)</code></td><td><code>m</code></td><td>Number of rows</td></tr>
<tr><td><code>ncols(M)</code></td><td><code>n</code></td><td>Number of columns</td></tr>
</tbody>
</table>
</div>
<h2 id="symbolic-matrix-operations"><a class="header" href="#symbolic-matrix-operations">Symbolic Matrix Operations</a></h2>
<p>Matrix operations support partial symbolic evaluation. When mixing concrete and symbolic values, Kleis evaluates what it can and leaves the rest symbolic:</p>
<pre><code class="language-kleis">:eval matrix_add(Matrix(2, 2, [1, 0, 0, 1]), Matrix(2, 2, [a, 0, 0, b]))
// ‚Üí Matrix(2, 2, [1+a, 0, 0, 1+b])

:eval matrix_add(Matrix(2, 2, [0, 0, 0, 0]), Matrix(2, 2, [x, y, z, w]))
// ‚Üí Matrix(2, 2, [x, y, z, w])  (0+x = x optimization)
</code></pre>
<h3 id="smart-optimizations"><a class="header" href="#smart-optimizations">Smart Optimizations</a></h3>
<p>The evaluator applies algebraic simplifications:</p>
<ul>
<li><code>0 + x = x</code></li>
<li><code>x + 0 = x</code></li>
<li><code>x - 0 = x</code></li>
<li><code>0 * x = 0</code></li>
<li><code>1 * x = x</code></li>
</ul>
<h2 id="dimension-checking"><a class="header" href="#dimension-checking">Dimension Checking</a></h2>
<p>Kleis enforces dimension constraints at the type level:</p>
<pre><code class="language-kleis">// This type-checks: same dimensions
matrix_add(Matrix(2, 2, [1, 2, 3, 4]), Matrix(2, 2, [5, 6, 7, 8]))

// This fails: dimension mismatch
matrix_add(Matrix(2, 2, [1, 2, 3, 4]), Matrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
// Error: dimension mismatch: 2x2 vs 3x3
</code></pre>
<p>For matrix multiplication, inner dimensions must match:</p>
<pre><code class="language-kleis">// OK: (2√ó3) ¬∑ (3√ó2) ‚Üí (2√ó2)
multiply(Matrix(2, 3, [...]), Matrix(3, 2, [...]))

// Error: (2√ó2) ¬∑ (3√ó2) - inner dimensions 2 ‚â† 3
multiply(Matrix(2, 2, [...]), Matrix(3, 2, [...]))
// Error: inner dimensions don't match
</code></pre>
<h2 id="complete-operations-reference"><a class="header" href="#complete-operations-reference">Complete Operations Reference</a></h2>
<h3 id="matrix-constructors"><a class="header" href="#matrix-constructors">Matrix Constructors</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constructor</th><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matrix([[...], [...]])</code></td><td><code>matrix([[1,2],[3,4]])</code></td><td><strong>Nested list syntax</strong> (recommended)</td></tr>
<tr><td><code>Matrix(m, n, [...])</code></td><td><code>Matrix(2, 2, [1,2,3,4])</code></td><td>Explicit dimensions + flat list</td></tr>
<tr><td><code>eye(n)</code></td><td><code>eye(3)</code> ‚Üí 3√ó3 identity</td><td>n√ón identity matrix</td></tr>
<tr><td><code>identity(n)</code></td><td><code>identity(2)</code> ‚Üí 2√ó2 identity</td><td>Alias for <code>eye</code></td></tr>
<tr><td><code>zeros(n)</code></td><td><code>zeros(3)</code> ‚Üí 3√ó3 zeros</td><td>n√ón zero matrix</td></tr>
<tr><td><code>zeros(m, n)</code></td><td><code>zeros(2, 3)</code> ‚Üí 2√ó3 zeros</td><td>m√ón zero matrix</td></tr>
<tr><td><code>ones(n)</code></td><td><code>ones(3)</code> ‚Üí 3√ó3 ones</td><td>n√ón matrix of ones</td></tr>
<tr><td><code>ones(m, n)</code></td><td><code>ones(2, 4)</code> ‚Üí 2√ó4 ones</td><td>m√ón matrix of ones</td></tr>
<tr><td><code>diag_matrix([...])</code></td><td><code>diag_matrix([1,2,3])</code></td><td>Diagonal matrix from list</td></tr>
</tbody>
</table>
</div>
<p><strong>Nested list syntax</strong> is recommended for readability:</p>
<pre><code>Œª&gt; :eval matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
‚úÖ Matrix(3, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9])

Œª&gt; :eval matrix([[0, -1], [1, 0]])
‚úÖ Matrix(2, 2, [0, -1, 1, 0])

Œª&gt; :eval eigenvalues(matrix([[0, -1], [1, 0]]))
‚úÖ [complex(0, 1), complex(0, -1)]
</code></pre>
<p>Other constructors:</p>
<pre><code>Œª&gt; :eval eye(3)
‚úÖ Matrix(3, 3, [1, 0, 0, 0, 1, 0, 0, 0, 1])

Œª&gt; :eval diag_matrix([5, 10, 15])
‚úÖ Matrix(3, 3, [5, 0, 0, 0, 10, 0, 0, 0, 15])
</code></pre>
<h3 id="core-matrix-operations"><a class="header" href="#core-matrix-operations">Core Matrix Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Signature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matrix_add(A, B)</code></td><td><code>(m√ón) + (m√ón) ‚Üí (m√ón)</code></td><td>Element-wise addition</td></tr>
<tr><td><code>matrix_sub(A, B)</code></td><td><code>(m√ón) - (m√ón) ‚Üí (m√ón)</code></td><td>Element-wise subtraction</td></tr>
<tr><td><code>multiply(A, B)</code></td><td><code>(m√ón) ¬∑ (n√óp) ‚Üí (m√óp)</code></td><td>Matrix multiplication</td></tr>
<tr><td><code>scalar_matrix_mul(s, A)</code></td><td><code>‚Ñù √ó (m√ón) ‚Üí (m√ón)</code></td><td>Scalar multiplication</td></tr>
<tr><td><code>transpose(A)</code></td><td><code>(m√ón) ‚Üí (n√óm)</code></td><td>Transpose</td></tr>
<tr><td><code>trace(A)</code></td><td><code>(n√ón) ‚Üí ‚Ñù</code></td><td>Sum of diagonal</td></tr>
<tr><td><code>det(A)</code></td><td><code>(n√ón) ‚Üí ‚Ñù</code></td><td>Determinant (n ‚â§ 3)</td></tr>
<tr><td><code>matrix_get(A, i, j)</code></td><td><code>(m√ón) √ó ‚Ñï √ó ‚Ñï ‚Üí T</code></td><td>Element at (i, j)</td></tr>
<tr><td><code>matrix_row(A, i)</code></td><td><code>(m√ón) √ó ‚Ñï ‚Üí List(T)</code></td><td>Row i</td></tr>
<tr><td><code>matrix_col(A, j)</code></td><td><code>(m√ón) √ó ‚Ñï ‚Üí List(T)</code></td><td>Column j</td></tr>
<tr><td><code>matrix_diag(A)</code></td><td><code>(n√ón) ‚Üí List(T)</code></td><td>Diagonal elements</td></tr>
</tbody>
</table>
</div>
<h3 id="lapack-numerical-operations"><a class="header" href="#lapack-numerical-operations">LAPACK Numerical Operations</a></h3>
<p>When compiled with the <code>numerical</code> feature, Kleis provides high-performance
numerical linear algebra via LAPACK:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Signature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>lapack_eigenvalues(A)</code></td><td><code>(n√ón) ‚Üí List(‚ÑÇ)</code></td><td>Eigenvalues</td></tr>
<tr><td><code>lapack_eig(A)</code></td><td><code>(n√ón) ‚Üí [eigenvalues, eigenvectors]</code></td><td>Full eigendecomposition</td></tr>
<tr><td><code>lapack_svd(A)</code></td><td><code>(m√ón) ‚Üí [U, S, V·µÄ]</code></td><td>Singular value decomposition</td></tr>
<tr><td><code>lapack_singular_values(A)</code></td><td><code>(m√ón) ‚Üí List(‚Ñù)</code></td><td>Singular values only</td></tr>
<tr><td><code>lapack_solve(A, b)</code></td><td><code>(n√ón) √ó (n) ‚Üí (n)</code></td><td>Solve Ax = b</td></tr>
<tr><td><code>lapack_inv(A)</code></td><td><code>(n√ón) ‚Üí (n√ón)</code></td><td>Matrix inverse</td></tr>
<tr><td><code>lapack_qr(A)</code></td><td><code>(m√ón) ‚Üí [Q, R]</code></td><td>QR decomposition</td></tr>
<tr><td><code>lapack_cholesky(A)</code></td><td><code>(n√ón) ‚Üí (n√ón)</code></td><td>Cholesky factorization L</td></tr>
<tr><td><code>lapack_rank(A)</code></td><td><code>(m√ón) ‚Üí ‚Ñï</code></td><td>Matrix rank</td></tr>
<tr><td><code>lapack_cond(A)</code></td><td><code>(m√ón) ‚Üí ‚Ñù</code></td><td>Condition number</td></tr>
<tr><td><code>lapack_norm(A)</code></td><td><code>(m√ón) ‚Üí ‚Ñù</code></td><td>Frobenius norm</td></tr>
<tr><td><code>lapack_det(A)</code></td><td><code>(n√ón) ‚Üí ‚Ñù</code></td><td>Determinant (any size)</td></tr>
<tr><td><code>schur(A)</code></td><td><code>(n√ón) ‚Üí [U, T, eigenvalues]</code></td><td>Schur decomposition (LAPACK dgees)</td></tr>
</tbody>
</table>
</div>
<h3 id="schur-decomposition-for-control-theory"><a class="header" href="#schur-decomposition-for-control-theory">Schur Decomposition for Control Theory</a></h3>
<p>The Schur decomposition A = UTU·µÄ is critical for control theory applications:</p>
<pre><code class="language-kleis">// Compute Schur decomposition
let A = Matrix(3, 3, [-2, 0, 1, 0, -1, 0, 1, 0, -3])
:eval schur(A)
// Returns [U, T, eigenvalues] where:
// - U is orthogonal (Schur vectors)
// - T is quasi-upper-triangular (Schur form)
// - eigenvalues are (real, imag) pairs
</code></pre>
<p><strong>Use cases:</strong></p>
<ul>
<li>Stability analysis (check if eigenvalues have Re(Œª) &lt; 0)</li>
<li>Lyapunov equation solvers</li>
<li>CARE/DARE (algebraic Riccati equations)</li>
<li>Pole placement algorithms</li>
</ul>
<h2 id="example-lqg-controller-design"><a class="header" href="#example-lqg-controller-design">Example: LQG Controller Design</a></h2>
<p>This complete example demonstrates designing an LQG (Linear-Quadratic-Gaussian) controller for a mass-spring-damper system using Kleis‚Äôs numerical matrix operations.</p>
<h3 id="system-definition"><a class="header" href="#system-definition">System Definition</a></h3>
<pre><code>Œª&gt; :let A = matrix([[0, 1], [-2, -3]])
Œª&gt; :let B = matrix([[0], [1]])
Œª&gt; :let C = matrix([[1, 0]])
</code></pre>
<p>The system <code>·∫ã = Ax + Bu</code>, <code>y = Cx</code> represents a 2nd-order mechanical system.</p>
<h3 id="open-loop-stability-analysis"><a class="header" href="#open-loop-stability-analysis">Open-Loop Stability Analysis</a></h3>
<pre><code>Œª&gt; :eval eigenvalues(A)
‚úÖ [-1, -2]
</code></pre>
<p>Both eigenvalues have negative real parts ‚Üí system is stable, but response is slow.</p>
<h3 id="lqr-controller-design-pole-placement"><a class="header" href="#lqr-controller-design-pole-placement">LQR Controller Design (Pole Placement)</a></h3>
<p><strong>Goal:</strong> Place closed-loop poles at -5, -5 for faster response.</p>
<p><strong>Step 1:</strong> Check controllability (det ‚â† 0 means we can place poles anywhere):</p>
<pre><code>Œª&gt; :let Wc = hstack(B, multiply(A, B))
Œª&gt; :eval Wc
‚úÖ matrix([[0, 1], [1, -3]])

Œª&gt; :eval det(Wc)
‚úÖ -1
</code></pre>
<p><strong>Step 2:</strong> Extract open-loop characteristic polynomial coefficients.</p>
<p>The open-loop characteristic polynomial is det(sI - A) = s¬≤ + a‚ÇÅs + a‚ÇÄ.
From A = [[0, 1], [-2, -3]], we get: s¬≤ + 3s + 2, so a‚ÇÅ = 3, a‚ÇÄ = 2.</p>
<pre><code>Œª&gt; :let a1 = 3
Œª&gt; :let a0 = 2
</code></pre>
<p><strong>Step 3:</strong> Set desired closed-loop characteristic polynomial.</p>
<p>For poles at -5, -5: (s+5)¬≤ = s¬≤ + 10s + 25, so Œ±‚ÇÅ = 10, Œ±‚ÇÄ = 25.</p>
<pre><code>Œª&gt; :let alpha1 = 10
Œª&gt; :let alpha0 = 25
</code></pre>
<p><strong>Step 4:</strong> Compute feedback gain K using coefficient matching.</p>
<p>For a controllable canonical form with B = [[0], [1]], the gain is K = [Œ±‚ÇÄ-a‚ÇÄ, Œ±‚ÇÅ-a‚ÇÅ]:</p>
<pre><code>Œª&gt; :let k1 = alpha0 - a0
Œª&gt; :let k2 = alpha1 - a1
Œª&gt; :eval k1
‚úÖ 23
Œª&gt; :eval k2
‚úÖ 7

Œª&gt; :let K = matrix([[k1, k2]])
Œª&gt; :eval K
‚úÖ matrix([[23, 7]])
</code></pre>
<p><strong>Step 5:</strong> Verify closed-loop eigenvalues:</p>
<pre><code>Œª&gt; :let A_cl = matrix_sub(A, multiply(B, K))
Œª&gt; :eval A_cl
‚úÖ matrix([[0, 1], [-25, -10]])

Œª&gt; :eval eigenvalues(A_cl)
‚úÖ [-5.000000042200552, -4.999999957799446]
</code></pre>
<p>Closed-loop poles are at -5 (2.5√ó faster than open-loop).</p>
<h3 id="kalman-observer-design"><a class="header" href="#kalman-observer-design">Kalman Observer Design</a></h3>
<p><strong>Goal:</strong> Design observer with poles at -10, -10 (faster than controller for separation principle).</p>
<p><strong>Step 1:</strong> Check observability:</p>
<pre><code>Œª&gt; :let Wo = vstack(C, multiply(C, A))
Œª&gt; :eval Wo
‚úÖ matrix([[1, 0], [0, 1]])

Œª&gt; :eval det(Wo)
‚úÖ 1
</code></pre>
<p><strong>Step 2:</strong> Apply duality - observer design uses A·µÄ and C·µÄ.</p>
<p>For observer error dynamics (A - LC), the characteristic polynomial is:
det(sI - A + LC) = s¬≤ + (3 + l‚ÇÅ)s + (2 + l‚ÇÇ)</p>
<p>Desired: (s+10)¬≤ = s¬≤ + 20s + 100</p>
<p><strong>Step 3:</strong> Compute observer gain L:</p>
<pre><code>Œª&gt; :let l1 = 20 - 3
Œª&gt; :let l2 = 100 - 2
Œª&gt; :eval l1
‚úÖ 17
Œª&gt; :eval l2
‚úÖ 98

Œª&gt; :let L = matrix([[l1], [l2]])
Œª&gt; :eval L
‚úÖ matrix([[17], [98]])
</code></pre>
<p><strong>Step 4:</strong> Verify observer eigenvalues:</p>
<pre><code>Œª&gt; :let A_obs = matrix_sub(A, multiply(L, C))
Œª&gt; :eval A_obs
‚úÖ matrix([[-17, 1], [-100, -3]])

Œª&gt; :eval eigenvalues(A_obs)
‚úÖ [complex(-10, 7.14), complex(-10, -7.14)]
</code></pre>
<p>Observer eigenvalues have Re(Œª) = -10 ‚Üí faster error convergence than the controller.</p>
<h3 id="controllability-and-observability"><a class="header" href="#controllability-and-observability">Controllability and Observability</a></h3>
<pre><code>Œª&gt; :let Wc = hstack(B, multiply(A, B))
Œª&gt; :eval Wc
‚úÖ matrix([[0, 1], [1, -3]])

Œª&gt; :eval det(Wc)
‚úÖ -1
</code></pre>
<p>det(Wc) ‚â† 0 ‚Üí System is <strong>controllable</strong>.</p>
<pre><code>Œª&gt; :let Wo = vstack(C, multiply(C, A))
Œª&gt; :eval Wo
‚úÖ matrix([[1, 0], [0, 1]])

Œª&gt; :eval det(Wo)
‚úÖ 1
</code></pre>
<p>det(Wo) ‚â† 0 ‚Üí System is <strong>observable</strong>.</p>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Value</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Open-loop poles</td><td>-1, -2</td><td>Stable but slow</td></tr>
<tr><td>Closed-loop poles (LQR)</td><td>-5, -5</td><td>‚úÖ 2.5√ó faster</td></tr>
<tr><td>Observer poles (Kalman)</td><td>-10 ¬± 7.14i</td><td>‚úÖ 2√ó faster than controller</td></tr>
<tr><td>Controllable</td><td>det(Wc) ‚â† 0</td><td>‚úÖ Yes</td></tr>
<tr><td>Observable</td><td>det(Wo) ‚â† 0</td><td>‚úÖ Yes</td></tr>
</tbody>
</table>
</div>
<p>The <strong>Separation Principle</strong> is satisfied: LQR and Kalman can be designed independently, and the combined LQG controller is guaranteed stable.</p>
<h2 id="see-also-1"><a class="header" href="#see-also-1">See Also</a></h2>
<ul>
<li><a href="#types-and-values">Types and Values</a> - Matrix as a parametric type</li>
<li><a href="#complex-numbers">Complex Numbers</a> - Matrices over ‚ÑÇ</li>
<li><a href="#the-repl-1">The REPL</a> - Using <code>:eval</code> for concrete computation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-a-grammar-reference"><a class="header" href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a></h1>
<p>This appendix provides a reference to Kleis syntax based on the formal grammar specification (v0.97).</p>
<blockquote>
<p><strong>Complete Grammar:</strong> See <code>vscode-kleis/docs/grammar/kleis_grammar_v097.md</code> for the full specification.</p>
<p><strong>v0.97 (Jan 2026):</strong> Added <code>and</code>, <code>or</code>, <code>not</code> as ASCII equivalents for <code>‚àß</code>, <code>‚à®</code>, <code>¬¨</code>.</p>
</blockquote>
<h2 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h2>
<pre><code class="language-ebnf">program ::= { declaration }

declaration ::= importDecl              // v0.8: Module imports
              | libraryAnnotation
              | versionAnnotation
              | structureDef
              | implementsDef
              | dataDef
              | functionDef
              | operationDecl
              | typeAlias
              | exampleBlock            // v0.93: Executable documentation
</code></pre>
<h2 id="import-statements-v08"><a class="header" href="#import-statements-v08">Import Statements (v0.8)</a></h2>
<pre><code class="language-ebnf">importDecl ::= "import" string
</code></pre>
<p>Example:</p>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"
import "stdlib/complex.kleis"
</code></pre>
<h2 id="annotations"><a class="header" href="#annotations">Annotations</a></h2>
<pre><code class="language-ebnf">libraryAnnotation ::= "@library" "(" string ")"
versionAnnotation ::= "@version" "(" string ")"
</code></pre>
<p>Example:</p>
<pre><code class="language-kleis">@library("stdlib/algebra")
@version("0.7")
</code></pre>
<h2 id="data-type-definitions"><a class="header" href="#data-type-definitions">Data Type Definitions</a></h2>
<pre><code class="language-ebnf">dataDef ::= "data" identifier [ "(" typeParams ")" ] "="
            dataVariant { "|" dataVariant }

dataVariant ::= identifier [ "(" dataFields ")" ]

dataField ::= identifier ":" type    // Named field
            | type                   // Positional field
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">data Bool = True | False

data Option(T) = None | Some(value : T)
</code></pre>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<pre><code class="language-ebnf">matchExpr ::= "match" expression "{" matchCases "}"

matchCase ::= pattern [ "if" guardExpression ] "=&gt;" expression   // v0.8: guards

pattern ::= basePattern [ "as" identifier ]  // v0.8: as-patterns

basePattern ::= "_"                              // Wildcard
              | identifier                       // Variable
              | identifier [ "(" patternArgs ")" ]  // Constructor
              | number | string | boolean        // Constant
              | tuplePattern                     // v0.8: Tuple sugar

tuplePattern ::= "()"                            // Unit
               | "(" pattern "," pattern { "," pattern } ")"  // Pair, Tuple3, etc.
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">match x { True =&gt; 1 | False =&gt; 0 }
match opt { None =&gt; 0 | Some(x) =&gt; x }
match result { Ok(Some(x)) =&gt; x | Ok(None) =&gt; 0 | Err(_) =&gt; -1 }

// v0.8: Pattern guards
match n { x if x &lt; 0 =&gt; "negative" | x if x &gt; 0 =&gt; "positive" | _ =&gt; "zero" }

// v0.8: As-patterns
match list { Cons(h, t) as whole =&gt; process(whole) | Nil =&gt; empty }
</code></pre>
<h2 id="structure-definitions"><a class="header" href="#structure-definitions">Structure Definitions</a></h2>
<pre><code class="language-ebnf">structureDef ::= "structure" identifier "(" typeParams ")"
                 [ extendsClause ] [ overClause ]
                 "{" { structureMember } "}"

extendsClause ::= "extends" identifier [ "(" typeArgs ")" ]
overClause ::= "over" "Field" "(" type ")"

structureMember ::= operationDecl
                  | elementDecl
                  | axiomDecl
                  | nestedStructure
                  | functionDef
</code></pre>
<p>Example (aspirational - <code>over</code> and <code>extends</code> not yet implemented):</p>
<pre><code class="language-kleis example">structure VectorSpace(V) over Field(F) extends AbelianGroup(V) {
    operation (¬∑) : F √ó V ‚Üí V
    
    axiom scalar_distributive : ‚àÄ(a : F)(b : F)(v : V).
        (a + b) ¬∑ v = a ¬∑ v + b ¬∑ v
}
</code></pre>
<h2 id="implements-1"><a class="header" href="#implements-1">Implements</a></h2>
<pre><code class="language-ebnf">implementsDef ::= "implements" identifier "(" typeArgs ")"
                  [ overClause ]
                  [ "{" { implMember } "}" ]

implMember ::= elementImpl | operationImpl | verifyStmt

operationImpl ::= "operation" operatorSymbol "=" implementation
                | "operation" operatorSymbol "(" params ")" "=" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-kleis">implements Ring(‚Ñù) {
    operation add = builtin_add
    operation mul = builtin_mul
    element zero = 0
    element one = 1
}
</code></pre>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<pre><code class="language-ebnf">functionDef ::= "define" identifier [ typeAnnotation ] "=" expression
              | "define" identifier "(" params ")" [ ":" type ] "=" expression

param ::= identifier [ ":" type ]
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">define pi = 3.14159
define square(x) = x * x
define add(x: ‚Ñù, y: ‚Ñù) : ‚Ñù = x + y
</code></pre>
<h2 id="type-system"><a class="header" href="#type-system">Type System</a></h2>
<pre><code class="language-ebnf">type ::= primitiveType
       | parametricType
       | functionType
       | typeVariable
       | "(" type ")"

primitiveType ::= "‚Ñù" | "‚ÑÇ" | "‚Ñ§" | "‚Ñï" | "‚Ñö"
                | "Real" | "Complex" | "Integer" | "Nat" | "Rational"
                | "Bool" | "String" | "Unit"

parametricType ::= identifier "(" typeArgs ")"
                 | "BitVec" "(" number ")"      // Fixed-size bit vectors

functionType ::= type "‚Üí" type | type "-&gt;" type

typeAlias ::= "type" identifier "=" type
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">‚Ñù                    // Real numbers
Vector(3)            // Parameterized type
‚Ñù ‚Üí ‚Ñù               // Function type
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù         // Higher-order function
type RealFunc = ‚Ñù ‚Üí ‚Ñù  // Type alias
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<pre><code class="language-ebnf">expression ::= primary
             | matchExpr
             | prefixOp expression
             | expression postfixOp
             | expression infixOp expression
             | expression "(" [ arguments ] ")"
             | "[" [ expressions ] "]"           // List literal
             | lambda
             | letBinding
             | conditional

primary ::= identifier | number | string
          | "(" expression ")"

// Note: Greek letters (œÄ, œÜ, etc.) are valid identifiers, not special constants.
// Use import "stdlib/prelude.kleis" for predefined constants like pi, e, i.
</code></pre>
<h2 id="lambda-expressions-1"><a class="header" href="#lambda-expressions-1">Lambda Expressions</a></h2>
<pre><code class="language-ebnf">lambda ::= "Œª" params "." expression
         | "lambda" params "." expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">Œª x . x + 1              // Simple lambda
Œª x y . x * y            // Multiple parameters
Œª (x : ‚Ñù) . x^2          // With type annotation
lambda x . x             // Using keyword
</code></pre>
<h2 id="let-bindings-1"><a class="header" href="#let-bindings-1">Let Bindings</a></h2>
<pre><code class="language-ebnf">letBinding ::= "let" pattern [ typeAnnotation ] "=" expression "in" expression
// Note: typeAnnotation only valid when pattern is a simple Variable
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">let x = 5 in x + x
let x : ‚Ñù = 3.14 in x * 2
let s = (a + b + c) / 2 in sqrt(s * (s-a) * (s-b) * (s-c))

// v0.8: Let destructuring
let Point(x, y) = origin in x^2 + y^2
let Some(Pair(a, b)) = opt in a + b
let Cons(h, _) = list in h
</code></pre>
<h2 id="conditionals-1"><a class="header" href="#conditionals-1">Conditionals</a></h2>
<pre><code class="language-ebnf">conditional ::= "if" expression "then" expression "else" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-kleis">if x &gt; 0 then x else -x
</code></pre>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<pre><code class="language-ebnf">forAllProp ::= ("‚àÄ" | "forall") variables [ whereClause ] "." proposition
existsProp ::= ("‚àÉ" | "exists") variables [ whereClause ] "." proposition

varDecl ::= identifier [ ":" type ]
          | "(" identifier { identifier } ":" type ")"

// Note: "x ‚àà type" syntax is NOT implemented. Use "x : type" instead.

whereClause ::= "where" expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">‚àÄ(x : ‚Ñù). x + 0 = x
‚àÉ(x : ‚Ñ§). x * x = 4
‚àÄ(a : ‚Ñù)(b : ‚Ñù) where a ‚â† 0 . a * (1/a) = 1
</code></pre>
<h2 id="v09-enhancements"><a class="header" href="#v09-enhancements">v0.9 Enhancements</a></h2>
<h3 id="nested-quantifiers-in-expressions"><a class="header" href="#nested-quantifiers-in-expressions">Nested Quantifiers in Expressions</a></h3>
<p>Quantifiers can now appear as operands in logical expressions:</p>
<pre><code class="language-kleis">// v0.9: Quantifier inside conjunction
axiom nested: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). y &gt; 0)

// Epsilon-delta limit definition
axiom epsilon_delta: ‚àÄ(Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
    (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
</code></pre>
<h3 id="function-types-in-type-annotations"><a class="header" href="#function-types-in-type-annotations">Function Types in Type Annotations</a></h3>
<p>Function types are now allowed in quantifier variable declarations:</p>
<pre><code class="language-kleis">// Function from reals to reals
axiom func: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù). f(0) = f(0)

// Higher-order function
axiom compose: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, g : ‚Ñù ‚Üí ‚Ñù). compose(f, g) = Œª x . f(g(x))

// Topology: continuity via preimages
axiom continuity: ‚àÄ(f : X ‚Üí Y, V : Set(Y)). 
    is_open(V) ‚Üí is_open(preimage(f, V))
</code></pre>
<h2 id="v095-big-operators"><a class="header" href="#v095-big-operators">v0.95 Big Operators</a></h2>
<p>Big operators (Œ£, Œ†, ‚à´, lim) can be used with function call syntax:</p>
<pre><code class="language-ebnf">bigOpExpr ::= "Œ£" "(" expr "," expr "," expr ")"
            | "Œ†" "(" expr "," expr "," expr ")"
            | "‚à´" "(" expr "," expr "," expr "," expr ")"
            | "lim" "(" expr "," expr "," expr ")"
            | ("Œ£" | "Œ†" | "‚à´") primaryExpr      // prefix form
</code></pre>
<h3 id="summation-œÉ"><a class="header" href="#summation-œÉ">Summation: Œ£</a></h3>
<pre><code class="language-kleis">// Sum of f(i) from 1 to n
Œ£(1, n, Œª i . f(i))

// Parsed as: sum_bounds(Œª i . f(i), 1, n)
</code></pre>
<h3 id="product-œÄ"><a class="header" href="#product-œÄ">Product: Œ†</a></h3>
<pre><code class="language-kleis">// Product of g(i) from 1 to n
Œ†(1, n, Œª i . g(i))

// Parsed as: prod_bounds(Œª i . g(i), 1, n)
</code></pre>
<h3 id="integral-"><a class="header" href="#integral-">Integral: ‚à´</a></h3>
<pre><code class="language-kleis">// Integral of x¬≤ from 0 to 1
‚à´(0, 1, Œª x . x * x, x)

// Parsed as: int_bounds(Œª x . x * x, 0, 1, x)
</code></pre>
<h3 id="limit-lim"><a class="header" href="#limit-lim">Limit: lim</a></h3>
<pre><code class="language-kleis">// Limit of sin(x)/x as x approaches 0
lim(x, 0, sin(x) / x)

// Parsed as: lim(sin(x) / x, x, 0)
</code></pre>
<h3 id="prefix-forms"><a class="header" href="#prefix-forms">Prefix Forms</a></h3>
<p>Simple prefix forms are also supported:</p>
<pre><code class="language-kleis">Œ£f        // Parsed as: Sum(f)
‚à´g        // Parsed as: Integrate(g)
</code></pre>
<h2 id="calculus-notation-v07"><a class="header" href="#calculus-notation-v07">Calculus Notation (v0.7)</a></h2>
<p>Kleis uses Mathematica-style notation for calculus operations:</p>
<pre><code class="language-ebnf">// Derivatives (function calls)
D(f, x)              // Partial derivative ‚àÇf/‚àÇx
D(f, x, y)           // Mixed partial ‚àÇ¬≤f/‚àÇx‚àÇy
D(f, {x, n})         // nth derivative ‚àÇ‚Åøf/‚àÇx‚Åø
Dt(f, x)             // Total derivative df/dx

// Integrals
Integrate(f, x)           // Indefinite ‚à´f dx
Integrate(f, x, a, b)     // Definite ‚à´[a,b] f dx

// Sums and Products
Sum(expr, i, 1, n)        // Œ£·µ¢‚Çå‚ÇÅ‚Åø expr
Product(expr, i, 1, n)    // Œ†·µ¢‚Çå‚ÇÅ‚Åø expr

// Limits
Limit(f, x, a)            // lim_{x‚Üía} f
</code></pre>
<p>Derivatives use function call syntax: <code>D(f, x)</code> for partial derivatives and <code>Dt(f, x)</code> for total derivatives.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<h3 id="prefix-operators"><a class="header" href="#prefix-operators">Prefix Operators</a></h3>
<pre><code class="language-ebnf">prefixOp ::= "-" | "¬¨" | "‚àá" | "‚à´" | "‚à¨" | "‚à≠" | "‚àÆ" | "‚àØ"
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>‚àö</code> is NOT a prefix operator. Use <code>sqrt(x)</code> function instead.</p>
</blockquote>
<h3 id="postfix-operators"><a class="header" href="#postfix-operators">Postfix Operators</a></h3>
<pre><code class="language-ebnf">postfixOp ::= "!" | "·µÄ" | "^T" | "‚Ä†"
</code></pre>
<blockquote>
<p><strong>Note:</strong> <code>*</code> (conjugate) and <code>^‚Ä†</code> are NOT implemented as postfix operators.</p>
</blockquote>
<h3 id="infix-operators-by-precedence-low-to-high"><a class="header" href="#infix-operators-by-precedence-low-to-high">Infix Operators (by precedence, low to high)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code> (biconditional)</td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code> (implication)</td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code> or <code>or</code> (logical or)</td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code> or <code>and</code> (logical and)</td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code> or <code>not</code> (prefix not)</td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>==</code> <code>‚â†</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>&lt;=</code> <code>‚â•</code> <code>&gt;=</code></td><td>Non-assoc</td></tr>
<tr><td>7</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>*</code> <code>√ó</code> <code>/</code> <code>¬∑</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>^</code></td><td>Right</td></tr>
<tr><td>10</td><td><code>-</code> (unary)</td><td>Prefix</td></tr>
<tr><td>11</td><td>Postfix (<code>!</code>, <code>·µÄ</code>, <code>^T</code>, <code>‚Ä†</code>)</td><td>Postfix</td></tr>
<tr><td>12</td><td>Function application</td><td>Left</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note (v0.97):</strong> <code>and</code>, <code>or</code>, <code>not</code> now work as ASCII equivalents for <code>‚àß</code>, <code>‚à®</code>, <code>¬¨</code> in all expression contexts.</p>
<p><strong>Note:</strong> Set operators use function-call syntax:</p>
<ul>
<li><code>x ‚àà S</code> ‚Üí <code>in_set(x, S)</code></li>
<li><code>x ‚àâ S</code> ‚Üí <code>¬¨in_set(x, S)</code></li>
<li><code>A ‚äÜ B</code> ‚Üí <code>subset(A, B)</code></li>
<li><code>A ‚äÇ B</code> ‚Üí <code>proper_subset(A, B)</code></li>
<li><code>‚âà</code> and <code>‚â°</code> are not implemented</li>
</ul>
</blockquote>
<h2 id="comments-1"><a class="header" href="#comments-1">Comments</a></h2>
<pre><code class="language-ebnf">lineComment ::= "//" { any character except newline } newline
blockComment ::= "/*" { any character } "*/"
</code></pre>
<p><strong>Note:</strong> Kleis uses C-style comments (<code>//</code> and <code>/* */</code>), not Haskell-style (<code>--</code> and <code>{- -}</code>).</p>
<h2 id="unicode-and-ascii-equivalents"><a class="header" href="#unicode-and-ascii-equivalents">Unicode and ASCII Equivalents</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td><td>Universal quantifier</td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td><td>Existential quantifier</td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td><td>Function type / implies</td></tr>
<tr><td><code>√ó</code></td><td>‚Äî</td><td>Product type (Unicode only; <code>*</code> is multiplication)</td></tr>
<tr><td><code>‚àß</code></td><td><code>and</code></td><td>Logical and (<strong>v0.97</strong>: <code>and</code> works everywhere)</td></tr>
<tr><td><code>‚à®</code></td><td><code>or</code></td><td>Logical or (<strong>v0.97</strong>: <code>or</code> works everywhere)</td></tr>
<tr><td><code>¬¨</code></td><td><code>not</code></td><td>Logical not (<strong>v0.97</strong>: <code>not</code> works everywhere)</td></tr>
<tr><td><code>‚â§</code></td><td><code>&lt;=</code></td><td>Less or equal</td></tr>
<tr><td><code>‚â•</code></td><td><code>&gt;=</code></td><td>Greater or equal</td></tr>
<tr><td><code>‚â†</code></td><td><code>!=</code></td><td>Not equal</td></tr>
<tr><td><code>‚Ñï</code></td><td><code>Nat</code></td><td>Natural numbers</td></tr>
<tr><td><code>‚Ñ§</code></td><td><code>Int</code></td><td>Integers</td></tr>
<tr><td><code>‚Ñö</code></td><td><code>Rational</code></td><td>Rational numbers</td></tr>
<tr><td><code>‚Ñù</code></td><td><code>Real</code></td><td>Real numbers</td></tr>
<tr><td><code>‚ÑÇ</code></td><td><code>Complex</code></td><td>Complex numbers</td></tr>
<tr><td><code>Œª</code></td><td><code>lambda</code></td><td>Lambda</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> <code>*</code> is the multiplication operator in expressions, not an ASCII equivalent for <code>√ó</code> in product types. Use Unicode <code>√ó</code> for product types like <code>Int √ó Int ‚Üí Int</code>.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> Greek letters like <code>œÄ</code>, <code>Œ±</code>, <code>Œ≤</code> are valid identifiers. Use <code>import "stdlib/prelude.kleis"</code> for common constants like <code>pi</code>.</p>
</blockquote>
<blockquote>
<p><strong>Note (v0.97):</strong> <code>and</code>, <code>or</code>, <code>not</code> are now reserved keywords and work in all expression contexts, including axioms, assertions, and function bodies.</p>
</blockquote>
<h2 id="lexical-elements"><a class="header" href="#lexical-elements">Lexical Elements</a></h2>
<pre><code class="language-ebnf">identifier ::= letter { letter | digit | "_" }

number ::= integer | decimal | scientific
integer ::= digit { digit }
decimal ::= digit { digit } "." { digit }
scientific ::= decimal ("e" | "E") ["+"|"-"] digit { digit }

string ::= '"' { character } '"'

letter ::= "a".."z" | "A".."Z" | greekLetter
digit ::= "0".."9"

greekLower ::= "Œ±" | "Œ≤" | "Œ≥" | "Œ¥" | "Œµ" | "Œ∂" | "Œ∑" | "Œ∏"
             | "Œπ" | "Œ∫" | "Œª" | "Œº" | "ŒΩ" | "Œæ" | "Œø" | "œÄ"
             | "œÅ" | "œÉ" | "œÑ" | "œÖ" | "œÜ" | "œá" | "œà" | "œâ"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-operators"><a class="header" href="#appendix-operators">Appendix: Operators</a></h1>
<p>This appendix covers all operators in the Kleis language. For built-in functions, see <a href="#appendix-built-in-functions">Built-in Functions</a>. For numerical linear algebra, see <a href="#appendix-lapack-functions">LAPACK Functions</a>.</p>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td></td><td>Addition</td><td><code>3 + 4</code></td><td><code>7</code></td></tr>
<tr><td><code>-</code></td><td></td><td>Subtraction</td><td><code>10 - 3</code></td><td><code>7</code></td></tr>
<tr><td><code>*</code></td><td><code>√ó</code></td><td>Multiplication</td><td><code>6 √ó 7</code></td><td><code>42</code></td></tr>
<tr><td><code>/</code></td><td><code>√∑</code></td><td>Division</td><td><code>15 / 3</code></td><td><code>5</code></td></tr>
<tr><td><code>^</code></td><td></td><td>Exponentiation</td><td><code>2 ^ 10</code></td><td><code>1024</code></td></tr>
<tr><td><code>-</code> (unary)</td><td></td><td>Negation</td><td><code>-5</code></td><td><code>-5</code></td></tr>
<tr><td><code>¬∑</code></td><td></td><td>Dot product</td><td><code>a ¬∑ b</code></td><td>scalar</td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>=</code></td><td></td><td>Equality</td><td><code>x = y</code></td></tr>
<tr><td><code>==</code></td><td></td><td>Equality (alt)</td><td><code>x == y</code></td></tr>
<tr><td><code>!=</code></td><td><code>‚â†</code></td><td>Inequality</td><td><code>x ‚â† y</code></td></tr>
<tr><td><code>&lt;</code></td><td></td><td>Less than</td><td><code>x &lt; y</code></td></tr>
<tr><td><code>&gt;</code></td><td></td><td>Greater than</td><td><code>x &gt; y</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>‚â§</code></td><td>Less or equal</td><td><code>x ‚â§ y</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>‚â•</code></td><td>Greater or equal</td><td><code>x ‚â• y</code></td></tr>
</tbody>
</table>
</div>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>and</code></td><td><code>‚àß</code></td><td>Conjunction</td><td><code>P ‚àß Q</code></td></tr>
<tr><td><code>or</code></td><td><code>‚à®</code></td><td>Disjunction</td><td><code>P ‚à® Q</code></td></tr>
<tr><td><code>not</code></td><td><code>¬¨</code></td><td>Negation</td><td><code>¬¨P</code></td></tr>
<tr><td><code>implies</code></td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code></td><td>Implication</td><td><code>P ‚Üí Q</code></td></tr>
<tr><td><code>iff</code></td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code></td><td>Biconditional</td><td><code>P ‚Üî Q</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td></td><td>Conjunction (alt)</td><td><code>P &amp;&amp; Q</code></td></tr>
<tr><td><code>||</code></td><td></td><td>Disjunction (alt)</td><td><code>P || Q</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> All Unicode variants for implication (<code>‚Üí</code>, <code>‚áí</code>, <code>‚üπ</code>) and biconditional (<code>‚Üî</code>, <code>‚áî</code>, <code>‚ü∫</code>) are equivalent.</p>
</blockquote>
<h2 id="postfix-operators-1"><a class="header" href="#postfix-operators-1">Postfix Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>!</code></td><td>Factorial</td><td><code>5!</code></td><td><code>120</code></td></tr>
<tr><td><code>·µÄ</code></td><td>Transpose</td><td><code>A·µÄ</code></td><td>transposed matrix</td></tr>
<tr><td><code>‚Ä†</code></td><td>Dagger/Adjoint</td><td><code>A‚Ä†</code></td><td>conjugate transpose</td></tr>
<tr><td><code>‚Ä≤</code></td><td>Prime</td><td><code>f‚Ä≤</code></td><td>derivative notation</td></tr>
<tr><td><code>‚Ä≥</code></td><td>Double prime</td><td><code>f‚Ä≥</code></td><td>second derivative</td></tr>
<tr><td><code>‚Ä¥</code></td><td>Triple prime</td><td><code>f‚Ä¥</code></td><td>third derivative</td></tr>
<tr><td><code>‚Å∫</code></td><td>Superscript plus</td><td><code>A‚Å∫</code></td><td>pseudo-inverse</td></tr>
<tr><td><code>‚Åª</code></td><td>Superscript minus</td><td><code>A‚Åª</code></td><td>inverse notation</td></tr>
</tbody>
</table>
</div>
<h2 id="prefix-operators-1"><a class="header" href="#prefix-operators-1">Prefix Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>-</code></td><td>Negation</td><td><code>-x</code></td><td>negated value</td></tr>
<tr><td><code>‚àá</code></td><td>Gradient/Del</td><td><code>‚àáf</code></td><td>gradient of f</td></tr>
<tr><td><code>‚à´</code></td><td>Integral</td><td><code>‚à´f</code></td><td>integral of f</td></tr>
<tr><td><code>¬¨</code></td><td>Logical not</td><td><code>¬¨P</code></td><td>negation of P</td></tr>
</tbody>
</table>
</div>
<h2 id="big-operators-v095"><a class="header" href="#big-operators-v095">Big Operators (v0.95)</a></h2>
<p>Kleis supports big operator syntax for summations, products, integrals, and limits:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Syntax</th><th>Translates to</th></tr>
</thead>
<tbody>
<tr><td><code>Œ£</code></td><td>Summation</td><td><code>Œ£(from, to, body)</code></td><td><code>sum_bounds(body, from, to)</code></td></tr>
<tr><td><code>Œ†</code></td><td>Product</td><td><code>Œ†(from, to, body)</code></td><td><code>prod_bounds(body, from, to)</code></td></tr>
<tr><td><code>‚à´</code></td><td>Integral</td><td><code>‚à´(lower, upper, body, var)</code></td><td><code>int_bounds(body, lower, upper, var)</code></td></tr>
<tr><td><code>lim</code></td><td>Limit</td><td><code>lim(var, target, body)</code></td><td><code>lim(body, var, target)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples</a></h3>
<pre><code class="language-kleis">// Sum from i=1 to n
Œ£(1, n, i^2)

// Product from k=1 to 5
Œ†(1, 5, k)

// Integral from 0 to 1
‚à´(0, 1, x^2, x)

// Limit as x approaches 0
lim(x, 0, sin(x)/x)
</code></pre>
<h2 id="custom-mathematical-operators"><a class="header" href="#custom-mathematical-operators">Custom Mathematical Operators</a></h2>
<p>Kleis recognizes many Unicode mathematical symbols as <strong>infix binary operators</strong>. These can be used directly in expressions like <code>a ‚Ä¢ b</code>.</p>
<h3 id="complete-operator-table"><a class="header" href="#complete-operator-table">Complete Operator Table</a></h3>
<p>These operators are <strong>syntactic only</strong> ‚Äî they are parsed as infix operators but have <strong>no built-in semantics</strong>. They remain symbolic: <code>2 ‚Ä¢ 3</code> evaluates to <code>‚Ä¢(2, 3)</code>, not a number.</p>
<p><strong>These operators cannot be used for computation.</strong> Kleis does not connect <code>‚Ä¢</code> to any function ‚Äî <code>u ‚Ä¢ v</code> will always stay symbolic as <code>‚Ä¢(u, v)</code>.</p>
<p>To compute, use a named function instead: define <code>dot(u, v)</code> and call it directly. The <code>‚Ä¢</code> operator is only useful for notation in axioms.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Typical Mathematical Use</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ä¢</code></td><td>U+2022</td><td>Bullet</td><td>Inner/dot product notation</td></tr>
<tr><td><code>‚àò</code></td><td>U+2218</td><td>Ring operator</td><td>Function composition notation</td></tr>
<tr><td><code>‚äó</code></td><td>U+2297</td><td>Circled times</td><td>Tensor product notation</td></tr>
<tr><td><code>‚äï</code></td><td>U+2295</td><td>Circled plus</td><td>Direct sum notation</td></tr>
<tr><td><code>‚äô</code></td><td>U+2299</td><td>Circled dot</td><td>Hadamard product notation</td></tr>
<tr><td><code>‚äõ</code></td><td>U+229B</td><td>Circled asterisk</td><td>Convolution notation</td></tr>
<tr><td><code>‚äò</code></td><td>U+2298</td><td>Circled slash</td><td>(user-defined)</td></tr>
<tr><td><code>‚äö</code></td><td>U+229A</td><td>Circled ring</td><td>(user-defined)</td></tr>
<tr><td><code>‚äù</code></td><td>U+229D</td><td>Circled minus</td><td>(user-defined)</td></tr>
<tr><td><code>‚äû</code></td><td>U+229E</td><td>Squared plus</td><td>(user-defined)</td></tr>
<tr><td><code>‚äü</code></td><td>U+229F</td><td>Squared minus</td><td>(user-defined)</td></tr>
<tr><td><code>‚ä†</code></td><td>U+22A0</td><td>Squared times</td><td>(user-defined)</td></tr>
<tr><td><code>‚ä°</code></td><td>U+22A1</td><td>Squared dot</td><td>(user-defined)</td></tr>
<tr><td><code>‚à™</code></td><td>U+222A</td><td>Union</td><td>Set union notation</td></tr>
<tr><td><code>‚à©</code></td><td>U+2229</td><td>Intersection</td><td>Set intersection notation</td></tr>
<tr><td><code>‚äî</code></td><td>U+2294</td><td>Square cup</td><td>Join/supremum notation</td></tr>
<tr><td><code>‚äì</code></td><td>U+2293</td><td>Square cap</td><td>Meet/infimum notation</td></tr>
<tr><td><code>‚ñ≥</code></td><td>U+25B3</td><td>Triangle up</td><td>Symmetric difference notation</td></tr>
<tr><td><code>‚ñΩ</code></td><td>U+25BD</td><td>Triangle down</td><td>(user-defined)</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Important:</strong> These operators do NOT compute values. <code>2 ‚Ä¢ 3</code> returns <code>‚Ä¢(2, 3)</code> symbolically. To give them meaning, define functions and use those instead.</p>
</blockquote>
<h3 id="what-they-actually-do"><a class="header" href="#what-they-actually-do">What They Actually Do</a></h3>
<p>These operators are parsed but <strong>stay symbolic</strong>:</p>
<pre><code>Œª&gt; :eval 2 ‚Ä¢ 3
‚úÖ ‚Ä¢(2, 3)      ‚Üê NOT computed to 6!

Œª&gt; :eval A ‚äó B
‚úÖ ‚äó(A, B)      ‚Üê stays symbolic
</code></pre>
<h3 id="when-to-use-them"><a class="header" href="#when-to-use-them">When to Use Them</a></h3>
<p>Use these operators in <strong>axioms and symbolic expressions</strong> where you want readable mathematical notation:</p>
<pre><code class="language-kleis">structure VectorSpace(V) {
    // Use ‚Ä¢ for notation in axioms
    axiom symmetric : ‚àÄ(u : V)(v : V). u ‚Ä¢ v = v ‚Ä¢ u
    axiom bilinear : ‚àÄ(a : ‚Ñù)(u : V)(v : V). (a * u) ‚Ä¢ v = a * (u ‚Ä¢ v)
}
</code></pre>
<h3 id="for-actual-computation"><a class="header" href="#for-actual-computation">For Actual Computation</a></h3>
<p>If you need operators that <strong>compute values</strong>, use:</p>
<ol>
<li>Built-in operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code></li>
<li>Function calls: <code>dot(u, v)</code>, <code>tensor(A, B)</code>, <code>union(s1, s2)</code></li>
</ol>
<pre><code class="language-kleis">// These compute actual values:
define sum = 2 + 3           // ‚Üí 5
define product = times(4, 5)  // ‚Üí 20

// These stay symbolic (for axioms):
define symbolic = a ‚Ä¢ b      // ‚Üí ‚Ä¢(a, b)
</code></pre>
<h2 id="type-operators"><a class="header" href="#type-operators">Type Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>‚Üí</code></td><td>Function type</td><td><code>‚Ñù ‚Üí ‚Ñù</code></td></tr>
<tr><td><code>√ó</code></td><td>Product type</td><td><code>‚Ñù √ó ‚Ñù</code></td></tr>
<tr><td><code>:</code></td><td>Type annotation</td><td><code>x : ‚Ñù</code></td></tr>
</tbody>
</table>
</div>
<h2 id="precedence-table"><a class="header" href="#precedence-table">Precedence Table</a></h2>
<p>From lowest to highest precedence:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code> (biconditional)</td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code> (implication)</td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code> <code>or</code> <code>||</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code> <code>and</code> <code>&amp;&amp;</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code> <code>not</code></td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>‚â†</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>‚â•</code></td><td>Non-associative</td></tr>
<tr><td>7</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>*</code> <code>/</code> <code>√ó</code> <code>¬∑</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>^</code> (power)</td><td>Right</td></tr>
<tr><td>10</td><td><code>-</code> (unary negation)</td><td>Prefix</td></tr>
<tr><td>11</td><td><code>!</code> <code>·µÄ</code> <code>‚Ä†</code> <code>‚Ä≤</code> (postfix)</td><td>Postfix</td></tr>
<tr><td>12</td><td>Function application</td><td>Left</td></tr>
</tbody>
</table>
</div>
<h2 id="examples-1-1"><a class="header" href="#examples-1-1">Examples</a></h2>
<h3 id="arithmetic-precedence"><a class="header" href="#arithmetic-precedence">Arithmetic Precedence</a></h3>
<pre><code class="language-kleis">define ex1 = 2 + 3 * 4        // 14 (not 20)
define ex2 = (2 + 3) * 4      // 20
define ex3 = 2 ^ 3 ^ 2        // 512 (= 2^9, right associative)
define neg_sq(x) = -x^2       // -(x^2), not (-x)^2
</code></pre>
<h3 id="logical-precedence"><a class="header" href="#logical-precedence">Logical Precedence</a></h3>
<pre><code class="language-kleis">define logic1(P, Q, R) = P ‚àß Q ‚à® R        // (P ‚àß Q) ‚à® R
define logic2(P, Q, R) = P ‚Üí Q ‚Üí R        // P ‚Üí (Q ‚Üí R)
define logic3(P, Q) = ¬¨P ‚àß Q              // (¬¨P) ‚àß Q
</code></pre>
<h3 id="postfix-with-power"><a class="header" href="#postfix-with-power">Postfix with Power</a></h3>
<pre><code class="language-kleis">n!^2        // (n!)^2 - factorial first, then square
A·µÄ·µÄ         // (A·µÄ)·µÄ = A - transpose twice
</code></pre>
<h3 id="type-expressions"><a class="header" href="#type-expressions">Type Expressions</a></h3>
<pre><code class="language-kleis">‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù        // ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù) (curried binary function)
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù      // Higher-order: takes function, returns value
‚Ñù √ó ‚Ñù ‚Üí ‚Ñù        // Takes pair, returns value
</code></pre>
<h2 id="see-also-2"><a class="header" href="#see-also-2">See Also</a></h2>
<ul>
<li><a href="#appendix-built-in-functions">Built-in Functions</a> - List, string, matrix operations</li>
<li><a href="#appendix-lapack-functions">LAPACK Functions</a> - Numerical linear algebra</li>
<li><a href="#complex-numbers">Complex Numbers</a> - Complex number operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-built-in-functions"><a class="header" href="#appendix-built-in-functions">Appendix: Built-in Functions</a></h1>
<p>This appendix covers built-in functions for basic operations. For numerical linear algebra (eigenvalues, SVD, etc.), see <a href="#appendix-lapack-functions">LAPACK Functions</a>.</p>
<h2 id="output-functions"><a class="header" href="#output-functions">Output Functions</a></h2>
<p>Functions for displaying values:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>out(x)</code></td><td><code>show(x)</code>, <code>print(x)</code></td><td>Pretty-print value and return it</td></tr>
</tbody>
</table>
</div>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<pre><code class="language-kleis">out([[1, 2], [3, 4]])
// Prints:
// ‚îå      ‚îê
// ‚îÇ 1  2 ‚îÇ
// ‚îÇ 3  4 ‚îÇ
// ‚îî      ‚îò
</code></pre>
<h2 id="arithmetic-functions"><a class="header" href="#arithmetic-functions">Arithmetic Functions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>negate(x)</code></td><td></td><td>Unary negation</td><td><code>negate(5)</code> ‚Üí <code>-5</code></td></tr>
<tr><td><code>abs(x)</code></td><td><code>fabs</code></td><td>Absolute value</td><td><code>abs(-3)</code> ‚Üí <code>3</code></td></tr>
<tr><td><code>sqrt(x)</code></td><td></td><td>Square root</td><td><code>sqrt(16)</code> ‚Üí <code>4</code></td></tr>
<tr><td><code>pow(x, y)</code></td><td><code>power</code></td><td>x^y</td><td><code>pow(2, 3)</code> ‚Üí <code>8</code></td></tr>
<tr><td><code>floor(x)</code></td><td></td><td>Round down</td><td><code>floor(3.7)</code> ‚Üí <code>3</code></td></tr>
<tr><td><code>ceil(x)</code></td><td><code>ceiling</code></td><td>Round up</td><td><code>ceil(3.2)</code> ‚Üí <code>4</code></td></tr>
<tr><td><code>round(x)</code></td><td></td><td>Round to nearest</td><td><code>round(3.5)</code> ‚Üí <code>4</code></td></tr>
<tr><td><code>trunc(x)</code></td><td><code>truncate</code></td><td>Truncate toward zero</td><td><code>trunc(-3.7)</code> ‚Üí <code>-3</code></td></tr>
<tr><td><code>frac(x)</code></td><td><code>fract</code></td><td>Fractional part</td><td><code>frac(3.7)</code> ‚Üí <code>0.7</code></td></tr>
<tr><td><code>sign(x)</code></td><td><code>signum</code></td><td>Sign (-1, 0, or 1)</td><td><code>sign(-5)</code> ‚Üí <code>-1</code></td></tr>
<tr><td><code>min(x, y)</code></td><td></td><td>Minimum</td><td><code>min(3, 7)</code> ‚Üí <code>3</code></td></tr>
<tr><td><code>max(x, y)</code></td><td></td><td>Maximum</td><td><code>max(3, 7)</code> ‚Üí <code>7</code></td></tr>
<tr><td><code>mod(x, y)</code></td><td><code>fmod</code>, <code>remainder</code></td><td>Modulo/remainder</td><td><code>mod(7, 3)</code> ‚Üí <code>1</code></td></tr>
<tr><td><code>hypot(x, y)</code></td><td></td><td>‚àö(x¬≤ + y¬≤) stable</td><td><code>hypot(3, 4)</code> ‚Üí <code>5</code></td></tr>
</tbody>
</table>
</div>
<h2 id="trigonometric-functions-radians"><a class="header" href="#trigonometric-functions-radians">Trigonometric Functions (radians)</a></h2>
<p>All trigonometric functions use radians, not degrees. Use <code>radians(deg)</code> to convert.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>sin(x)</code></td><td></td><td>Sine</td><td><code>sin(0)</code> ‚Üí <code>0</code></td></tr>
<tr><td><code>cos(x)</code></td><td></td><td>Cosine</td><td><code>cos(0)</code> ‚Üí <code>1</code></td></tr>
<tr><td><code>tan(x)</code></td><td></td><td>Tangent</td><td><code>tan(0)</code> ‚Üí <code>0</code></td></tr>
<tr><td><code>asin(x)</code></td><td><code>arcsin</code></td><td>Arcsine</td><td><code>asin(1)</code> ‚Üí <code>œÄ/2</code></td></tr>
<tr><td><code>acos(x)</code></td><td><code>arccos</code></td><td>Arccosine</td><td><code>acos(1)</code> ‚Üí <code>0</code></td></tr>
<tr><td><code>atan(x)</code></td><td><code>arctan</code></td><td>Arctangent</td><td><code>atan(1)</code> ‚Üí <code>œÄ/4</code></td></tr>
<tr><td><code>atan2(y, x)</code></td><td><code>arctan2</code></td><td>2-arg arctangent</td><td><code>atan2(1, 1)</code> ‚Üí <code>œÄ/4</code></td></tr>
<tr><td><code>radians(deg)</code></td><td><code>deg_to_rad</code></td><td>Degrees to radians</td><td><code>radians(180)</code> ‚Üí <code>œÄ</code></td></tr>
</tbody>
</table>
</div>
<h2 id="hyperbolic-functions"><a class="header" href="#hyperbolic-functions">Hyperbolic Functions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sinh(x)</code></td><td></td><td>Hyperbolic sine</td></tr>
<tr><td><code>cosh(x)</code></td><td></td><td>Hyperbolic cosine</td></tr>
<tr><td><code>tanh(x)</code></td><td></td><td>Hyperbolic tangent</td></tr>
<tr><td><code>asinh(x)</code></td><td><code>arcsinh</code></td><td>Inverse hyperbolic sine</td></tr>
<tr><td><code>acosh(x)</code></td><td><code>arccosh</code></td><td>Inverse hyperbolic cosine</td></tr>
<tr><td><code>atanh(x)</code></td><td><code>arctanh</code></td><td>Inverse hyperbolic tangent</td></tr>
</tbody>
</table>
</div>
<p><strong>Identity:</strong> <code>cosh(x)¬≤ - sinh(x)¬≤ = 1</code></p>
<h2 id="exponential-and-logarithmic-1"><a class="header" href="#exponential-and-logarithmic-1">Exponential and Logarithmic</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>exp(x)</code></td><td></td><td>e^x</td><td><code>exp(1)</code> ‚Üí <code>2.718...</code></td></tr>
<tr><td><code>exp2(x)</code></td><td></td><td>2^x</td><td><code>exp2(3)</code> ‚Üí <code>8</code></td></tr>
<tr><td><code>log(x)</code></td><td><code>ln</code></td><td>Natural logarithm</td><td><code>log(e())</code> ‚Üí <code>1</code></td></tr>
<tr><td><code>log10(x)</code></td><td></td><td>Base-10 logarithm</td><td><code>log10(100)</code> ‚Üí <code>2</code></td></tr>
<tr><td><code>log2(x)</code></td><td></td><td>Base-2 logarithm</td><td><code>log2(8)</code> ‚Üí <code>3</code></td></tr>
</tbody>
</table>
</div>
<h2 id="list-operations"><a class="header" href="#list-operations">List Operations</a></h2>
<p>Kleis uses cons-lists with <code>Cons</code> and <code>Nil</code>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>Cons(x, xs)</code></td><td><code>cons</code></td><td>Prepend element</td><td><code>Cons(1, Nil)</code></td></tr>
<tr><td><code>Nil</code></td><td><code>nil</code></td><td>Empty list</td><td><code>Nil</code></td></tr>
<tr><td><code>head(xs)</code></td><td><code>car</code></td><td>First element</td><td><code>head([1,2,3])</code> ‚Üí <code>1</code></td></tr>
<tr><td><code>tail(xs)</code></td><td><code>cdr</code></td><td>Rest of list</td><td><code>tail([1,2,3])</code> ‚Üí <code>[2,3]</code></td></tr>
<tr><td><code>length(xs)</code></td><td></td><td>List length</td><td><code>length([1,2,3])</code> ‚Üí <code>3</code></td></tr>
<tr><td><code>nth(xs, n)</code></td><td></td><td>Get nth element</td><td><code>nth([1,2,3], 1)</code> ‚Üí <code>2</code></td></tr>
</tbody>
</table>
</div>
<h3 id="list-literal-syntax"><a class="header" href="#list-literal-syntax">List Literal Syntax</a></h3>
<pre><code class="language-kleis">[1, 2, 3]           // Shorthand for Cons(1, Cons(2, Cons(3, Nil)))
[]                  // Empty list (Nil)
</code></pre>
<h2 id="string-operations"><a class="header" href="#string-operations">String Operations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>concat(a, b)</code></td><td>Concatenate strings</td><td><code>concat("hello", "world")</code> ‚Üí <code>"helloworld"</code></td></tr>
<tr><td><code>strlen(s)</code></td><td>String length</td><td><code>strlen("hello")</code> ‚Üí <code>5</code></td></tr>
<tr><td><code>contains(s, sub)</code></td><td>Check substring</td><td><code>contains("hello", "ell")</code> ‚Üí <code>true</code></td></tr>
<tr><td><code>substr(s, start, len)</code></td><td>Extract substring</td><td><code>substr("hello", 1, 3)</code> ‚Üí <code>"ell"</code></td></tr>
<tr><td><code>replace(s, old, new)</code></td><td>Replace substring</td><td><code>replace("hello", "l", "L")</code> ‚Üí <code>"heLLo"</code></td></tr>
</tbody>
</table>
</div>
<h2 id="matrix-operations-basic"><a class="header" href="#matrix-operations-basic">Matrix Operations (Basic)</a></h2>
<p>For advanced operations (eigenvalues, SVD), see <a href="#appendix-lapack-functions">LAPACK Functions</a>.</p>
<h3 id="matrix-creation"><a class="header" href="#matrix-creation">Matrix Creation</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>matrix(rows, cols, elements)</code></td><td></td><td>Create matrix</td><td><code>matrix(2, 2, [1,2,3,4])</code></td></tr>
<tr><td><code>eye(n)</code></td><td><code>identity(n)</code></td><td>Identity matrix</td><td><code>eye(3)</code></td></tr>
<tr><td><code>zeros(m, n)</code></td><td></td><td>Zero matrix</td><td><code>zeros(2, 3)</code></td></tr>
<tr><td><code>ones(m, n)</code></td><td></td><td>Matrix of ones</td><td><code>ones(2, 3)</code></td></tr>
<tr><td><code>diag_matrix(elements)</code></td><td><code>diagonal</code></td><td>Diagonal matrix</td><td><code>diag_matrix([1,2,3])</code></td></tr>
</tbody>
</table>
</div>
<h3 id="matrix-literals"><a class="header" href="#matrix-literals">Matrix Literals</a></h3>
<pre><code class="language-kleis">[[1, 2, 3],
 [4, 5, 6]]         // 2√ó3 matrix
</code></pre>
<h3 id="matrix-properties-1"><a class="header" href="#matrix-properties-1">Matrix Properties</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>size(A)</code></td><td><code>shape</code>, <code>dims</code></td><td>Dimensions <code>[rows, cols]</code></td></tr>
<tr><td><code>nrows(A)</code></td><td><code>num_rows</code></td><td>Number of rows</td></tr>
<tr><td><code>ncols(A)</code></td><td><code>num_cols</code></td><td>Number of columns</td></tr>
</tbody>
</table>
</div>
<h3 id="element-access"><a class="header" href="#element-access">Element Access</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matrix_get(A, i, j)</code></td><td><code>element</code></td><td>Get element at (i, j)</td></tr>
<tr><td><code>matrix_row(A, i)</code></td><td><code>row</code></td><td>Get row i</td></tr>
<tr><td><code>matrix_col(A, j)</code></td><td><code>col</code></td><td>Get column j</td></tr>
<tr><td><code>matrix_diag(A)</code></td><td><code>diag</code></td><td>Get diagonal</td></tr>
</tbody>
</table>
</div>
<h3 id="element-modification"><a class="header" href="#element-modification">Element Modification</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>set_element(A, i, j, val)</code></td><td>Set element at (i, j)</td></tr>
<tr><td><code>set_row(A, i, row)</code></td><td>Set row i</td></tr>
<tr><td><code>set_col(A, j, col)</code></td><td>Set column j</td></tr>
<tr><td><code>set_diag(A, diag)</code></td><td>Set diagonal</td></tr>
</tbody>
</table>
</div>
<h3 id="basic-arithmetic-2"><a class="header" href="#basic-arithmetic-2">Basic Arithmetic</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>matrix_add(A, B)</code></td><td><code>builtin_matrix_add</code></td><td>A + B</td></tr>
<tr><td><code>matrix_sub(A, B)</code></td><td><code>builtin_matrix_sub</code></td><td>A - B</td></tr>
<tr><td><code>multiply(A, B)</code></td><td><code>matmul</code>, <code>builtin_matrix_mul</code></td><td>A √ó B</td></tr>
<tr><td><code>scalar_matrix_mul(c, A)</code></td><td><code>builtin_matrix_scalar_mul</code></td><td>c √ó A</td></tr>
<tr><td><code>transpose(A)</code></td><td><code>builtin_transpose</code></td><td>A·µÄ</td></tr>
<tr><td><code>trace(A)</code></td><td><code>builtin_trace</code></td><td>tr(A)</td></tr>
<tr><td><code>det(A)</code></td><td><code>builtin_determinant</code></td><td>det(A)</td></tr>
</tbody>
</table>
</div>
<h3 id="matrix-stacking"><a class="header" href="#matrix-stacking">Matrix Stacking</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>vstack(A, B)</code></td><td><code>append_rows</code></td><td>Stack vertically</td></tr>
<tr><td><code>hstack(A, B)</code></td><td><code>append_cols</code></td><td>Stack horizontally</td></tr>
<tr><td><code>prepend_row(A, row)</code></td><td></td><td>Add row at top</td></tr>
<tr><td><code>append_row(A, row)</code></td><td></td><td>Add row at bottom</td></tr>
<tr><td><code>prepend_col(A, col)</code></td><td></td><td>Add column at left</td></tr>
<tr><td><code>append_col(A, col)</code></td><td></td><td>Add column at right</td></tr>
</tbody>
</table>
</div>
<h2 id="mathematical-constants"><a class="header" href="#mathematical-constants">Mathematical Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Unicode</th><th>Value</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>pi()</code></td><td><code>œÄ</code></td><td>3.14159‚Ä¶</td><td>Pi</td></tr>
<tr><td><code>e()</code></td><td></td><td>2.71828‚Ä¶</td><td>Euler‚Äôs number</td></tr>
<tr><td><code>tau()</code></td><td><code>œÑ</code></td><td>6.28318‚Ä¶</td><td>œÑ = 2œÄ</td></tr>
<tr><td><code>i</code></td><td></td><td>‚àö(-1)</td><td>Imaginary unit</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> <code>pi()</code>, <code>e()</code>, and <code>tau()</code> are zero-argument functions.</p>
<h2 id="boolean-constants"><a class="header" href="#boolean-constants">Boolean Constants</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Constant</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>True</code> / <code>true</code></td><td>Boolean true</td></tr>
<tr><td><code>False</code> / <code>false</code></td><td>Boolean false</td></tr>
</tbody>
</table>
</div>
<h2 id="see-also-3"><a class="header" href="#see-also-3">See Also</a></h2>
<ul>
<li><a href="#appendix-operators">Operators</a> - Operator reference</li>
<li><a href="#appendix-lapack-functions">LAPACK Functions</a> - Numerical linear algebra</li>
<li><a href="#matrices">Matrices</a> - Matrix chapter</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-lapack-functions"><a class="header" href="#appendix-lapack-functions">Appendix: LAPACK Functions</a></h1>
<p>Kleis provides comprehensive numerical linear algebra operations through LAPACK integration. These functions are available when Kleis is compiled with the <code>numerical</code> feature.</p>
<blockquote>
<p><strong>Note:</strong> These operations perform concrete numerical computation. For symbolic matrix operations, see <a href="#appendix-built-in-functions">Built-in Functions</a>.</p>
</blockquote>
<h2 id="eigenvalues-and-eigenvectors"><a class="header" href="#eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>eigenvalues(A)</code></td><td><code>eigvals</code></td><td>Compute eigenvalues</td><td>List of eigenvalues</td></tr>
<tr><td><code>eig(A)</code></td><td></td><td>Eigenvalues + eigenvectors</td><td><code>[eigenvalues, eigenvectors]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<pre><code class="language-kleis">// 2√ó2 matrix
let A = [[4, 2], [1, 3]] in
eigenvalues(A)   // ‚Üí [-5.0, 2.0] (approximately)
</code></pre>
<h2 id="singular-value-decomposition"><a class="header" href="#singular-value-decomposition">Singular Value Decomposition</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>svd(A)</code></td><td></td><td>Full SVD decomposition</td><td><code>[U, S, Vt]</code></td></tr>
<tr><td><code>singular_values(A)</code></td><td><code>svdvals</code></td><td>Singular values only</td><td>List of singular values</td></tr>
</tbody>
</table>
</div>
<h3 id="example-1-1"><a class="header" href="#example-1-1">Example</a></h3>
<pre><code class="language-kleis">let A = [[1, 2], [3, 4], [5, 6]] in
let [U, S, Vt] = svd(A) in
// A ‚âà U √ó diag(S) √ó Vt
singular_values(A)   // ‚Üí [9.52..., 0.51...]
</code></pre>
<h2 id="matrix-decompositions"><a class="header" href="#matrix-decompositions">Matrix Decompositions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th><th>Returns</th></tr>
</thead>
<tbody>
<tr><td><code>qr(A)</code></td><td></td><td>QR decomposition</td><td><code>[Q, R]</code></td></tr>
<tr><td><code>cholesky(A)</code></td><td><code>chol</code></td><td>Cholesky decomposition</td><td>Lower triangular L</td></tr>
<tr><td><code>schur(A)</code></td><td><code>schur_decomp</code></td><td>Schur decomposition</td><td><code>[T, Z]</code></td></tr>
</tbody>
</table>
</div>
<h3 id="qr-example"><a class="header" href="#qr-example">QR Example</a></h3>
<pre><code class="language-kleis">let A = [[1, 2], [3, 4], [5, 6]] in
let [Q, R] = qr(A) in
// A = Q √ó R, where Q is orthogonal, R is upper triangular
</code></pre>
<h3 id="cholesky-example"><a class="header" href="#cholesky-example">Cholesky Example</a></h3>
<pre><code class="language-kleis">// Positive definite matrix
let A = [[4, 2], [2, 3]] in
let L = cholesky(A) in
// A = L √ó L·µÄ
</code></pre>
<h2 id="linear-systems"><a class="header" href="#linear-systems">Linear Systems</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>solve(A, b)</code></td><td><code>linsolve</code></td><td>Solve Ax = b</td></tr>
<tr><td><code>inv(A)</code></td><td><code>inverse</code></td><td>Matrix inverse A‚Åª¬π</td></tr>
</tbody>
</table>
</div>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<pre><code class="language-kleis">let A = [[3, 1], [1, 2]] in
let b = [9, 8] in
solve(A, b)   // ‚Üí [2, 3] (solution x where Ax = b)

inv(A)        // ‚Üí [[0.4, -0.2], [-0.2, 0.6]]
</code></pre>
<h2 id="matrix-properties-2"><a class="header" href="#matrix-properties-2">Matrix Properties</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>rank(A)</code></td><td><code>matrix_rank</code></td><td>Matrix rank</td></tr>
<tr><td><code>cond(A)</code></td><td><code>condition_number</code></td><td>Condition number</td></tr>
<tr><td><code>norm(A)</code></td><td><code>matrix_norm</code></td><td>Matrix norm (Frobenius)</td></tr>
<tr><td><code>det_lapack(A)</code></td><td></td><td>Determinant (via LU)</td></tr>
</tbody>
</table>
</div>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<pre><code class="language-kleis">let A = [[1, 2], [3, 4]] in
rank(A)    // ‚Üí 2
cond(A)    // ‚Üí 14.93... (Œ∫(A))
norm(A)    // ‚Üí 5.47... (Frobenius norm)
</code></pre>
<h2 id="matrix-functions"><a class="header" href="#matrix-functions">Matrix Functions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>expm(A)</code></td><td><code>matrix_exp</code></td><td>Matrix exponential e^A</td></tr>
<tr><td><code>mpow(A, n)</code></td><td><code>matrix_pow</code></td><td>Matrix power A^n</td></tr>
</tbody>
</table>
</div>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<pre><code class="language-kleis">let A = [[0, 1], [-1, 0]] in
expm(A)   // ‚Üí rotation matrix (since A is skew-symmetric)

let B = [[1, 1], [0, 1]] in
mpow(B, 3)   // ‚Üí [[1, 3], [0, 1]]
</code></pre>
<hr>
<h2 id="complex-matrix-operations"><a class="header" href="#complex-matrix-operations">Complex Matrix Operations</a></h2>
<p>For complex matrices, use the <code>cmat_*</code> variants:</p>
<h3 id="eigenvalues-and-decompositions"><a class="header" href="#eigenvalues-and-decompositions">Eigenvalues and Decompositions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cmat_eigenvalues(A)</code></td><td><code>cmat_eigvals</code></td><td>Complex eigenvalues</td></tr>
<tr><td><code>cmat_eig(A)</code></td><td></td><td>Complex eigenvalues + eigenvectors</td></tr>
<tr><td><code>cmat_svd(A)</code></td><td></td><td>Complex SVD</td></tr>
<tr><td><code>cmat_singular_values(A)</code></td><td><code>cmat_svdvals</code></td><td>Complex singular values</td></tr>
<tr><td><code>cmat_schur(A)</code></td><td><code>schur_complex</code></td><td>Complex Schur decomposition</td></tr>
</tbody>
</table>
</div>
<h3 id="linear-systems-1"><a class="header" href="#linear-systems-1">Linear Systems</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cmat_solve(A, b)</code></td><td><code>cmat_linsolve</code></td><td>Solve complex Ax = b</td></tr>
<tr><td><code>cmat_inv(A)</code></td><td><code>cmat_inverse</code></td><td>Complex inverse</td></tr>
<tr><td><code>cmat_qr(A)</code></td><td></td><td>Complex QR decomposition</td></tr>
</tbody>
</table>
</div>
<h3 id="matrix-properties-1-1"><a class="header" href="#matrix-properties-1-1">Matrix Properties</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cmat_rank(A)</code></td><td><code>cmat_matrix_rank</code></td><td>Complex matrix rank</td></tr>
<tr><td><code>cmat_cond(A)</code></td><td><code>cmat_condition_number</code></td><td>Complex condition number</td></tr>
<tr><td><code>cmat_norm(A)</code></td><td><code>cmat_matrix_norm</code></td><td>Complex matrix norm</td></tr>
<tr><td><code>cmat_det(A)</code></td><td><code>cmat_determinant</code></td><td>Complex determinant</td></tr>
</tbody>
</table>
</div>
<h3 id="matrix-functions-1"><a class="header" href="#matrix-functions-1">Matrix Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cmat_expm(A)</code></td><td><code>cmat_matrix_exp</code></td><td>Complex matrix exponential</td></tr>
<tr><td><code>cmat_mpow(A, n)</code></td><td><code>cmat_matrix_pow</code></td><td>Complex matrix power</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="complex-matrix-utilities"><a class="header" href="#complex-matrix-utilities">Complex Matrix Utilities</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>cmat_zero(m, n)</code></td><td><code>builtin_cmat_zero</code></td><td>Complex zero matrix</td></tr>
<tr><td><code>cmat_eye(n)</code></td><td><code>builtin_cmat_eye</code></td><td>Complex identity</td></tr>
<tr><td><code>cmat_from_real(A)</code></td><td><code>as_complex</code></td><td>Real ‚Üí complex matrix</td></tr>
<tr><td><code>cmat_from_imag(A)</code></td><td><code>as_imaginary</code></td><td>Imag ‚Üí complex matrix</td></tr>
<tr><td><code>cmat_real(A)</code></td><td><code>real_part_matrix</code></td><td>Extract real part</td></tr>
<tr><td><code>cmat_imag(A)</code></td><td><code>imag_part_matrix</code></td><td>Extract imaginary part</td></tr>
<tr><td><code>cmat_add(A, B)</code></td><td></td><td>Complex addition</td></tr>
<tr><td><code>cmat_sub(A, B)</code></td><td></td><td>Complex subtraction</td></tr>
<tr><td><code>cmat_mul(A, B)</code></td><td></td><td>Complex multiplication</td></tr>
<tr><td><code>cmat_conj(A)</code></td><td></td><td>Element-wise conjugate</td></tr>
<tr><td><code>cmat_transpose(A)</code></td><td></td><td>Transpose</td></tr>
<tr><td><code>cmat_dagger(A)</code></td><td><code>cmat_adjoint</code></td><td>Conjugate transpose (A‚Ä†)</td></tr>
<tr><td><code>cmat_trace(A)</code></td><td></td><td>Complex trace</td></tr>
<tr><td><code>cmat_scale_real(c, A)</code></td><td></td><td>Scale by real scalar</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="matrix-conversion"><a class="header" href="#matrix-conversion">Matrix Conversion</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Aliases</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>realify(A)</code></td><td><code>builtin_realify</code></td><td>Complex n√ón ‚Üí Real 2n√ó2n</td></tr>
<tr><td><code>complexify(A)</code></td><td><code>builtin_complexify</code></td><td>Real 2n√ó2n ‚Üí Complex n√ón</td></tr>
</tbody>
</table>
</div>
<p>These functions convert between complex matrices and their real-valued block representations:</p>
<pre><code>Complex matrix:     Real representation:
[a+bi  c+di]   ‚Üí    [a  -b  c  -d]
[e+fi  g+hi]        [b   a  d   c]
                    [e  -f  g  -h]
                    [f   e  h   g]
</code></pre>
<hr>
<h2 id="jupyter-notebook-usage"><a class="header" href="#jupyter-notebook-usage">Jupyter Notebook Usage</a></h2>
<p>When using Kleis Numeric kernel in Jupyter:</p>
<pre><code class="language-kleis">// Define a matrix
let A = [[1, 2], [3, 4]]

// Compute eigenvalues
eigenvalues(A)

// Pretty-print with out()
out(inv(A))
</code></pre>
<h2 id="see-also-4"><a class="header" href="#see-also-4">See Also</a></h2>
<ul>
<li><a href="#appendix-built-in-functions">Built-in Functions</a> - Basic matrix operations</li>
<li><a href="#appendix-operators">Operators</a> - Operator reference</li>
<li><a href="#jupyter-notebook">Jupyter Notebook</a> - Using numerical Kleis</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-ode-solver"><a class="header" href="#appendix-ode-solver">Appendix: ODE Solver</a></h1>
<p>Kleis provides numerical integration of ordinary differential equations through the <code>ode45</code> function. This implements the Dormand-Prince 5(4) adaptive step-size method, suitable for non-stiff initial value problems.</p>
<blockquote>
<p><strong>Note:</strong> The ODE solver is available when Kleis is compiled with the <code>numerical</code> feature.</p>
</blockquote>
<h2 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h2>
<pre><code class="language-kleis">ode45(dynamics, y0, t_span, dt)
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Argument</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>dynamics</code></td><td>Lambda</td><td>System dynamics function (see below)</td></tr>
<tr><td><code>y0</code></td><td>List</td><td>Initial state vector</td></tr>
<tr><td><code>t_span</code></td><td><code>[t0, t1]</code></td><td>Time interval</td></tr>
<tr><td><code>dt</code></td><td>Number</td><td>Output time step (optional, default 0.1)</td></tr>
</tbody>
</table>
</div>
<h3 id="the-dynamics-function"><a class="header" href="#the-dynamics-function">The Dynamics Function</a></h3>
<p>The <code>dynamics</code> argument is a lambda of the form:</p>
<pre><code class="language-kleis">lambda t y . [dy0/dt, dy1/dt, ...]
</code></pre>
<p>where:</p>
<ul>
<li><code>t</code> is the current time (scalar)</li>
<li><code>y</code> is the current state vector <code>[y0, y1, ...]</code></li>
<li>The return value is a list of derivatives, same length as <code>y</code></li>
</ul>
<p><strong>For higher-order ODEs</strong>, convert to a system of first-order equations by introducing auxiliary state variables:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Original Equation</th><th>State Vector</th><th>Dynamics Return</th></tr>
</thead>
<tbody>
<tr><td>y‚Äô = f(t, y)</td><td><code>[y]</code></td><td><code>[f(t, y)]</code></td></tr>
<tr><td>y‚Äô‚Äô = f(t, y, y‚Äô)</td><td><code>[y, y']</code></td><td><code>[y', f(t, y, y')]</code></td></tr>
<tr><td>y‚Äô‚Äò‚Äô = f(t, y, y‚Äô, y‚Äô‚Äô)</td><td><code>[y, y', y'']</code></td><td><code>[y', y'', f(...)]</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example</strong>: The second-order equation y‚Äô‚Äô + y = 0 becomes:</p>
<ul>
<li>State: <code>[y, v]</code> where v = y‚Äô</li>
<li>Dynamics: <code>[v, -y]</code> since y‚Äô = v and v‚Äô = -y</li>
</ul>
<h3 id="accessing-state-components"><a class="header" href="#accessing-state-components">Accessing State Components</a></h3>
<p>Use <code>nth(list, index)</code> to extract elements from the state vector (0-indexed):</p>
<pre><code class="language-kleis">lambda t y .
  let x = nth(y, 0) in    // first component
  let v = nth(y, 1) in    // second component
  [v, negate(x)]          // return [dx/dt, dv/dt]
</code></pre>
<h3 id="returns"><a class="header" href="#returns">Returns</a></h3>
<p>A list of <code>[t, [y0, y1, ...]]</code> pairs representing the trajectory.</p>
<h2 id="simple-example-exponential-decay"><a class="header" href="#simple-example-exponential-decay">Simple Example: Exponential Decay</a></h2>
<p>The equation dy/dt = -y with y(0) = 1 has the solution y(t) = e^(-t).</p>
<pre><code class="language-kleis">let decay = lambda t y . [negate(nth(y, 0))] in
let traj = ode45(decay, [1.0], [0, 3], 0.5) in
traj
// ‚Üí [[0, [1.0]], [0.5, [0.606...]], [1.0, [0.367...]], ...]
</code></pre>
<h2 id="harmonic-oscillator"><a class="header" href="#harmonic-oscillator">Harmonic Oscillator</a></h2>
<p>A second-order ODE like x‚Äô‚Äô = -x is converted to a first-order system:</p>
<ul>
<li>State: <code>[x, v]</code> where v = x‚Äô</li>
<li>Dynamics: <code>[x', v'] = [v, -x]</code></li>
</ul>
<pre><code class="language-kleis">let oscillator = lambda t y .
  let x = nth(y, 0) in
  let v = nth(y, 1) in
  [v, negate(x)]
in
ode45(oscillator, [1, 0], [0, 6.28], 0.1)
// Completes one period, returns to [1, 0]
</code></pre>
<hr>
<h2 id="control-systems-inverted-pendulum-with-lqr"><a class="header" href="#control-systems-inverted-pendulum-with-lqr">Control Systems: Inverted Pendulum with LQR</a></h2>
<p>This example demonstrates a complete control system workflow:</p>
<ol>
<li><strong>System modeling</strong> - Nonlinear pendulum dynamics</li>
<li><strong>LQR design</strong> - Optimal feedback gains via CARE</li>
<li><strong>Simulation</strong> - Closed-loop response with <code>ode45</code></li>
<li><strong>Visualization</strong> - State and control trajectories</li>
</ol>
<h3 id="problem-setup"><a class="header" href="#problem-setup">Problem Setup</a></h3>
<p>An inverted pendulum on an acceleration-controlled cart:</p>
<ul>
<li><strong>State</strong>: <code>[Œ∏, œâ]</code> where Œ∏ is angle from vertical, œâ is angular velocity</li>
<li><strong>Control</strong>: u = cart acceleration (m/s¬≤)</li>
<li><strong>Dynamics</strong>: Œ∏‚Äô‚Äô = (g/L)¬∑sin(Œ∏) + (u/L)¬∑cos(Œ∏)</li>
</ul>
<h3 id="linearized-system"><a class="header" href="#linearized-system">Linearized System</a></h3>
<p>Around the upright equilibrium (Œ∏ = 0):</p>
<pre><code>A = [0,    1  ]     B = [0  ]
    [g/L,  0  ]         [1/L]
</code></pre>
<p>With L = 0.5m and g = 9.81 m/s¬≤, the open-loop eigenvalues are ¬±4.43 ‚Äî one unstable pole.</p>
<h3 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h3>
<pre><code class="language-kleis">// Physical parameters
define ell = 0.5        // pendulum length (m)
define grav = 9.81      // gravity (m/s¬≤)

// Linearized system matrices
define a_matrix = [[0, 1], [grav / ell, 0]]
define b_matrix = [[0], [1 / ell]]

// LQR cost weights
define q_matrix = [[10, 0], [0, 1]]  // Penalize angle more than velocity
define r_matrix = [[1]]

// Helper functions
define get_time(pt) = nth(pt, 0)
define get_theta(pt) = nth(nth(pt, 1), 0)
define get_omega(pt) = nth(nth(pt, 1), 1)

example "LQR pendulum stabilization" {
  // Compute optimal LQR gains by solving CARE
  let result = lqr(a_matrix, b_matrix, q_matrix, r_matrix) in
  let k1 = nth(nth(nth(result, 0), 0), 0) in
  let k2 = nth(nth(nth(result, 0), 0), 1) in
  
  out("LQR gains: k1, k2 =")
  out(k1)  // ‚âà 20.12
  out(k2)  // ‚âà 4.60
  
  out("Open-loop eigenvalues (unstable):")
  out(eigenvalues(a_matrix))  // [4.43, -4.43]
  
  // Nonlinear dynamics with LQR feedback: u = -K¬∑x
  let dyn = lambda t y .
    let th = nth(y, 0) in
    let om = nth(y, 1) in
    let u = negate(k1*th + k2*om) in
    [om, (grav/ell)*sin(th) + (u/ell)*cos(th)]
  in
  
  // Simulate from 17¬∞ initial tilt
  let traj = ode45(dyn, [0.3, 0], [0, 5], 0.05) in
  
  // Extract time series
  let times = list_map(lambda p . get_time(p), traj) in
  let thetas = list_map(lambda p . get_theta(p), traj) in
  let omegas = list_map(lambda p . get_omega(p), traj) in
  let controls = list_map(lambda p . 
    negate(20.12*get_theta(p) + 4.60*get_omega(p)), traj) in
  
  // Plot state and control
  diagram(
    plot(times, thetas, color = "red", label = "theta (rad)"),
    plot(times, omegas, color = "blue", label = "omega (rad/s)"),
    plot(times, controls, color = "green", label = "u (m/s^2)"),
    title = "Inverted Pendulum - LQR Stabilization",
    xlabel = "Time (s)",
    ylabel = "State / Control",
    legend = "right + bottom",
    width = 16,
    height = 10
  )
}
</code></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<p><img src="images/inverted-pendulum-lqr.png" alt="Inverted Pendulum LQR Stabilization"></p>
<p>The plot shows:</p>
<ul>
<li><strong>Œ∏ (red)</strong>: Angle smoothly decays from 0.3 rad to 0</li>
<li><strong>œâ (blue)</strong>: Angular velocity with brief negative swing, then settles</li>
<li><strong>u (green)</strong>: Initial -6 m/s¬≤ control effort (cart accelerates backward to catch falling pendulum), then decays to zero</li>
</ul>
<p>The LQR controller stabilizes the pendulum in approximately 2 seconds with no overshoot ‚Äî optimal behavior for the given Q and R weights.</p>
<hr>
<h2 id="technical-notes"><a class="header" href="#technical-notes">Technical Notes</a></h2>
<h3 id="adaptive-step-size"><a class="header" href="#adaptive-step-size">Adaptive Step Size</a></h3>
<p>The Dormand-Prince 5(4) method adapts its internal step size for accuracy while outputting at the requested <code>dt</code> intervals. This handles stiff transients automatically.</p>
<h3 id="lambda-closures"><a class="header" href="#lambda-closures">Lambda Closures</a></h3>
<p>The dynamics lambda can capture variables from the enclosing scope:</p>
<pre><code class="language-kleis">let k = 2.0 in
let dyn = lambda t y . [negate(k * nth(y, 0))] in
ode45(dyn, [1], [0, 1], 0.1)
// k is captured in the closure
</code></pre>
<hr>
<h2 id="see-also-5"><a class="header" href="#see-also-5">See Also</a></h2>
<ul>
<li><a href="#appendix-lapack-functions">LAPACK Functions</a> - Matrix decompositions, <code>lqr()</code>, <code>eigenvalues()</code></li>
<li><a href="#jupyter-notebook">Jupyter Notebook</a> - Interactive plotting</li>
<li><a href="#appendix-built-in-functions">Built-in Functions</a> - <code>list_map</code>, <code>nth</code>, etc.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-c-standard-library"><a class="header" href="#appendix-c-standard-library">Appendix C: Standard Library</a></h1>
<p>The Kleis standard library provides foundational types, structures, and operations.</p>
<h2 id="core-types-1"><a class="header" href="#core-types-1">Core Types</a></h2>
<h3 id="numeric-types-2"><a class="header" href="#numeric-types-2">Numeric Types</a></h3>
<pre><code class="language-kleis">// These are primitive types built into Kleis:
‚Ñï  (or Nat)      // Natural numbers (0, 1, 2, ...)
‚Ñ§  (or Int)      // Integers (..., -1, 0, 1, ...)
‚Ñù  (or Real)     // Real numbers
‚ÑÇ  (or Complex)  // Complex numbers
</code></pre>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h3>
<pre><code class="language-kleis">Bool  // True or False
</code></pre>
<h3 id="string-type"><a class="header" href="#string-type">String Type</a></h3>
<pre><code class="language-kleis">String  // Text literals: "hello", "world"
</code></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h3>
<pre><code class="language-kleis">Unit  // Single value: ()
</code></pre>
<h2 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h2>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<pre><code class="language-kleis">structure List(T) {
    operation head : T
    operation tail : List(T)
    operation length : ‚Ñï
    operation append : List(T) ‚Üí List(T)
    operation map : (T ‚Üí U) ‚Üí List(U)
    operation filter : (T ‚Üí Bool) ‚Üí List(T)
}
</code></pre>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï, T) {
    operation get : ‚Ñï ‚Üí T
    operation length : ‚Ñï
    operation dot : Vector(n, T) ‚Üí T
    operation magnitude : ‚Ñù
    operation normalize : Vector(n, T)
}
</code></pre>
<h3 id="matrix"><a class="header" href="#matrix">Matrix</a></h3>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation get : ‚Ñï √ó ‚Ñï ‚Üí T
    operation rows : ‚Ñï
    operation cols : ‚Ñï
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    operation mul : Matrix(n, p, T) ‚Üí Matrix(m, p, T)
}

structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    operation eigenvalues : List(‚ÑÇ)
}
</code></pre>
<h2 id="complex-numbers-1"><a class="header" href="#complex-numbers-1">Complex Numbers</a></h2>
<p>The complex number type <code>‚ÑÇ</code> has full arithmetic support:</p>
<h3 id="construction-and-extraction-1"><a class="header" href="#construction-and-extraction-1">Construction and Extraction</a></h3>
<pre><code class="language-kleis">// Create complex number: complex(real_part, imaginary_part)
define z = complex(3, 4)        // 3 + 4i

// The imaginary unit
define i_unit = i               // = complex(0, 1)

// Extract parts
define x = re(z)                // 3
define y = im(z)                // 4
</code></pre>
<h3 id="arithmetic-operations-4"><a class="header" href="#arithmetic-operations-4">Arithmetic Operations</a></h3>
<pre><code class="language-kleis">// All operations are explicit (no operator overloading yet)
complex_add(z1, z2)      // z1 + z2
complex_sub(z1, z2)      // z1 - z2
complex_mul(z1, z2)      // z1 √ó z2
complex_div(z1, z2)      // z1 / z2
neg_complex(z)           // -z
complex_inverse(z)       // 1/z
</code></pre>
<h3 id="conjugate-and-magnitude"><a class="header" href="#conjugate-and-magnitude">Conjugate and Magnitude</a></h3>
<pre><code class="language-kleis">conj(z)                  // Complex conjugate (a - bi)
abs_squared(z)           // |z|¬≤ = a¬≤ + b¬≤
</code></pre>
<h3 id="operation-reference-2"><a class="header" href="#operation-reference-2">Operation Reference</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Create</td><td><code>complex(a, b)</code></td><td><code>complex(3, 4)</code></td><td>3 + 4i</td></tr>
<tr><td>Real part</td><td><code>re(z)</code></td><td><code>re(complex(3, 4))</code></td><td>3</td></tr>
<tr><td>Imaginary part</td><td><code>im(z)</code></td><td><code>im(complex(3, 4))</code></td><td>4</td></tr>
<tr><td>Add</td><td><code>complex_add(z1, z2)</code></td><td><code>complex_add(complex(1,2), complex(3,4))</code></td><td>complex(4, 6)</td></tr>
<tr><td>Subtract</td><td><code>complex_sub(z1, z2)</code></td><td><code>complex_sub(complex(5,3), complex(2,1))</code></td><td>complex(3, 2)</td></tr>
<tr><td>Multiply</td><td><code>complex_mul(z1, z2)</code></td><td><code>complex_mul(complex(1,2), complex(3,4))</code></td><td>complex(-5, 10)</td></tr>
<tr><td>Divide</td><td><code>complex_div(z1, z2)</code></td><td><code>complex_div(complex(1,0), complex(0,1))</code></td><td>complex(0, -1)</td></tr>
<tr><td>Negate</td><td><code>neg_complex(z)</code></td><td><code>neg_complex(complex(3, 4))</code></td><td>complex(-3, -4)</td></tr>
<tr><td>Inverse</td><td><code>complex_inverse(z)</code></td><td><code>complex_inverse(i)</code></td><td>complex(0, -1)</td></tr>
<tr><td>Conjugate</td><td><code>conj(z)</code></td><td><code>conj(complex(3, 4))</code></td><td>complex(3, -4)</td></tr>
<tr><td>Magnitude¬≤</td><td><code>abs_squared(z)</code></td><td><code>abs_squared(complex(3, 4))</code></td><td>25</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#complex-numbers">Chapter 14: Complex Numbers</a> for detailed examples.</p>
<h2 id="algebraic-structures"><a class="header" href="#algebraic-structures">Algebraic Structures</a></h2>
<h3 id="monoid"><a class="header" href="#monoid">Monoid</a></h3>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M                         // Identity element
    operation mul : M √ó M ‚Üí M     // Binary operation
    
    axiom identity_left : ‚àÄ(x : M). mul(e, x) = x
    axiom identity_right : ‚àÄ(x : M). mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h3 id="group"><a class="header" href="#group">Group</a></h3>
<pre><code class="language-kleis">structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G         // Inverse
    
    axiom inverse_left : ‚àÄ(x : G). mul(inv(x), x) = e
    axiom inverse_right : ‚àÄ(x : G). mul(x, inv(x)) = e
}
</code></pre>
<h3 id="ring"><a class="header" href="#ring">Ring</a></h3>
<pre><code class="language-kleis">structure Ring(R) {
    operation zero : R
    operation one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    // (R, add, zero) is an abelian group
    // (R, mul, one) is a monoid
    // mul distributes over add
}
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<pre><code class="language-kleis">structure Field(F) extends Ring(F) {
    operation inv : F ‚Üí F  // Multiplicative inverse (for non-zero)
    
    axiom mul_inverse : ‚àÄ(x : F). x ‚â† zero ‚Üí mul(x, inv(x)) = one
    axiom mul_commutative : ‚àÄ(x : F)(y : F). mul(x, y) = mul(y, x)
}
</code></pre>
<h3 id="vector-space"><a class="header" href="#vector-space">Vector Space</a></h3>
<pre><code class="language-kleis">structure VectorSpace(V, F) over Field(F) {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    zero : V
    
    // (V, add, zero) is an abelian group
    // scale distributes over add
    // scale is associative with field multiplication
}
</code></pre>
<h2 id="geometric-structures"><a class="header" href="#geometric-structures">Geometric Structures</a></h2>
<h3 id="metric-space"><a class="header" href="#metric-space">Metric Space</a></h3>
<pre><code class="language-kleis">structure MetricSpace(M) {
    operation distance : M √ó M ‚Üí ‚Ñù
    
    axiom non_negative : ‚àÄ(x : M)(y : M). distance(x, y) ‚â• 0
    axiom identity : ‚àÄ(x : M)(y : M). distance(x, y) = 0 ‚Üî x = y
    axiom symmetric : ‚àÄ(x : M)(y : M). distance(x, y) = distance(y, x)
    axiom triangle : ‚àÄ(x : M)(y : M)(z : M).
        distance(x, z) ‚â§ distance(x, y) + distance(y, z)
}
</code></pre>
<h3 id="manifold"><a class="header" href="#manifold">Manifold</a></h3>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(dim)
    operation chart : M ‚Üí Vector(dim, ‚Ñù)  // Local coordinates
}
</code></pre>
<h3 id="riemannian-manifold"><a class="header" href="#riemannian-manifold">Riemannian Manifold</a></h3>
<pre><code class="language-kleis">structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation metric : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation scalar_curvature : M ‚Üí ‚Ñù
}
</code></pre>
<h2 id="option-and-result-types"><a class="header" href="#option-and-result-types">Option and Result Types</a></h2>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<pre><code class="language-kleis">data Option(T) = Some(value : T) | None

// Operations
define is_some(opt) =
    match opt {
        Some(_) =&gt; True
        None =&gt; False
    }

define unwrap_or(opt, default) =
    match opt {
        Some(v) =&gt; v
        None =&gt; default
    }
</code></pre>
<h3 id="result-1"><a class="header" href="#result-1">Result</a></h3>
<pre><code class="language-kleis">data Result(T, E) = Ok(value : T) | Err(error : E)

// Operations
define is_ok(res) =
    match res {
        Ok(_) =&gt; True
        Err(_) =&gt; False
    }

define map_result(res, f) =
    match res {
        Ok(v) =&gt; Ok(f(v))
        Err(e) =&gt; Err(e)
    }
</code></pre>
<h2 id="loading-the-standard-library"><a class="header" href="#loading-the-standard-library">Loading the Standard Library</a></h2>
<p>In the REPL:</p>
<pre><code>kleis&gt; :load stdlib/prelude.kleis
Loaded standard library.
</code></pre>
<p>In files:</p>
<pre><code class="language-kleis example">import "stdlib/prelude.kleis"
import "stdlib/linear_algebra.kleis"
import "stdlib/differential_geometry.kleis"
</code></pre>
<h2 id="file-organization"><a class="header" href="#file-organization">File Organization</a></h2>
<pre><code>stdlib/
‚îú‚îÄ‚îÄ prelude.kleis          // Core types and functions (includes complex)
‚îú‚îÄ‚îÄ complex.kleis          // Complex number axioms and properties
‚îú‚îÄ‚îÄ numeric.kleis          // Numeric operations
‚îú‚îÄ‚îÄ text.kleis             // String processing operations
‚îú‚îÄ‚îÄ collections.kleis      // List, Vector, Matrix
‚îú‚îÄ‚îÄ algebraic.kleis        // Group, Ring, Field, etc.
‚îú‚îÄ‚îÄ linear_algebra.kleis   // Matrix operations
‚îú‚îÄ‚îÄ differential_geometry.kleis  // Manifolds, tensors
‚îî‚îÄ‚îÄ category_theory.kleis  // Categories, functors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-lisp-interpreter-in-kleis"><a class="header" href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter in Kleis</a></h1>
<p>This appendix presents a LISP interpreter written entirely in Kleis. This is a <strong>demonstration</strong> of Kleis‚Äôs power as a meta-language ‚Äî proving that Kleis can parse and execute programs written in other languages.</p>
<blockquote>
<p><strong>Note:</strong> This is a proof-of-concept, not a production LISP implementation. See <a href="#known-limitations">Known Limitations</a> for details.</p>
</blockquote>
<p>The interpreter includes:</p>
<ul>
<li><strong>Recursive descent S-expression parser</strong></li>
<li><strong>Full evaluator</strong> with special forms, arithmetic, comparisons, and list operations</li>
<li><strong>Lexical closures</strong> with <code>lambda</code></li>
<li><strong>Recursive functions</strong> with <code>letrec</code></li>
</ul>
<h2 id="running-in-the-repl"><a class="header" href="#running-in-the-repl">Running in the REPL</a></h2>
<pre><code>$ cargo run --bin repl
üßÆ Kleis REPL v0.1.0

Œª&gt; :load examples/meta-programming/lisp_parser.kleis
‚úÖ Loaded: 2 files, 60 functions, 15 structures, 5 data types

Œª&gt; :eval run("(+ 2 3)")
‚úÖ VNum(5)

Œª&gt; :eval run("(* 4 5)")  
‚úÖ VNum(20)

Œª&gt; :eval run("(if (&lt; 3 5) 100 200)")
‚úÖ VNum(100)

Œª&gt; :eval run("((lambda (x) (* x x)) 7)")
‚úÖ VNum(49)

Œª&gt; :eval run("(let ((x 10)) (+ x 5))")
‚úÖ VNum(15)
</code></pre>
<h3 id="factorial"><a class="header" href="#factorial">Factorial</a></h3>
<pre><code>Œª&gt; :eval run("(letrec ((fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))) (fact 5))")
‚úÖ VNum(120)
</code></pre>
<h3 id="fibonacci"><a class="header" href="#fibonacci">Fibonacci</a></h3>
<pre><code>Œª&gt; :eval run("(letrec ((fib (lambda (n) (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 10))")
‚úÖ VNum(55)
</code></pre>
<hr>
<h2 id="complete-source-code"><a class="header" href="#complete-source-code">Complete Source Code</a></h2>
<p>The complete LISP interpreter is in <code>examples/meta-programming/lisp_parser.kleis</code>. Below is the full implementation.</p>
<h3 id="part-1-s-expression-data-types"><a class="header" href="#part-1-s-expression-data-types">Part 1: S-Expression Data Types</a></h3>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"

// S-Expression: atoms and lists
data SExpr =
    SAtom(value: String)
  | SList(elements: List(SExpr))

// Parser result: success with remaining input, or error
data ParseResult =
    ParseOK(expr: SExpr, rest: String)
  | ParseErr(message: String)
</code></pre>
<h3 id="part-2-parser-helper-functions"><a class="header" href="#part-2-parser-helper-functions">Part 2: Parser Helper Functions</a></h3>
<pre><code class="language-kleis">// Check if character is whitespace
define is_ws(c: String) : Bool =
    or(eq(c, " "), or(eq(c, "\n"), eq(c, "\t")))

// Check if character is a delimiter
define is_delim(c: String) : Bool =
    or(is_ws(c), or(eq(c, "("), eq(c, ")")))

// Skip leading whitespace
define skip_ws(s: String) : String =
    if le(strlen(s), 0) then s
    else if is_ws(charAt(s, 0)) then skip_ws(substr(s, 1, strlen(s) - 1))
    else s

// Read atom characters until delimiter
define read_atom(s: String, acc: String) : ParseResult =
    if le(strlen(s), 0) then ParseOK(SAtom(acc), "")
    else if is_delim(charAt(s, 0)) then ParseOK(SAtom(acc), s)
    else read_atom(substr(s, 1, strlen(s) - 1), concat(acc, charAt(s, 0)))
</code></pre>
<h3 id="part-3-recursive-descent-parser"><a class="header" href="#part-3-recursive-descent-parser">Part 3: Recursive Descent Parser</a></h3>
<pre><code class="language-kleis">// Parse a single S-expression
define parse_sexpr(s: String) : ParseResult =
    let trimmed = skip_ws(s) in
    if le(strlen(trimmed), 0) then ParseErr("Unexpected end of input")
    else if eq(charAt(trimmed, 0), "(") then 
        parse_list(substr(trimmed, 1, strlen(trimmed) - 1), Nil)
    else read_atom(trimmed, "")

// Parse list elements until ")"
define parse_list(s: String, acc: List(SExpr)) : ParseResult =
    let trimmed = skip_ws(s) in
    if le(strlen(trimmed), 0) then ParseErr("Expected ')'")
    else if eq(charAt(trimmed, 0), ")") then 
        ParseOK(SList(rev(acc)), substr(trimmed, 1, strlen(trimmed) - 1))
    else 
        match parse_sexpr(trimmed) {
            ParseOK(expr, rest) =&gt; parse_list(rest, Cons(expr, acc))
          | ParseErr(msg) =&gt; ParseErr(msg)
        }

// Reverse a list
define rev(xs: List(SExpr)) : List(SExpr) =
    rev_acc(xs, Nil)

define rev_acc(xs: List(SExpr), acc: List(SExpr)) : List(SExpr) =
    match xs {
        Nil =&gt; acc
      | Cons(h, t) =&gt; rev_acc(t, Cons(h, acc))
    }

// User-facing parse function
define parse(s: String) : SExpr =
    match parse_sexpr(s) {
        ParseOK(expr, rest) =&gt; expr
      | ParseErr(msg) =&gt; SAtom(concat("Error: ", msg))
    }
</code></pre>
<h3 id="part-4-lisp-value-types-and-environment"><a class="header" href="#part-4-lisp-value-types-and-environment">Part 4: LISP Value Types and Environment</a></h3>
<pre><code class="language-kleis">// Values in our LISP
data LispVal =
    VNum(n: ‚Ñ§)                              // Integer
  | VSym(s: String)                         // Symbol (for errors/unbound)
  | VList(xs: List(LispVal))                // List value
  | VBool(b: Bool)                          // Boolean
  | VLambda(params: List(String), body: SExpr, env: Env)  // Closure

// Environment: list of (name, value) bindings
data Binding = Bind(name: String, val: LispVal)
data Env = Env(bindings: List(Binding))

// Empty environment
define empty_env : Env = Env(Nil)

// Look up a variable in the environment
define lookup(name: String, env: Env) : LispVal =
    match env {
        Env(bindings) =&gt; lookup_list(name, bindings)
    }

define lookup_list(name: String, bs: List(Binding)) : LispVal =
    match bs {
        Nil =&gt; VSym(concat("Unbound: ", name))
      | Cons(Bind(n, v), rest) =&gt; 
            if eq(n, name) then v else lookup_list(name, rest)
    }

// Extend environment with a new binding
define extend(name: String, val: LispVal, env: Env) : Env =
    match env {
        Env(bindings) =&gt; Env(Cons(Bind(name, val), bindings))
    }

// Extend with multiple bindings (for function application)
define extend_all(names: List(String), vals: List(LispVal), env: Env) : Env =
    match names {
        Nil =&gt; env
      | Cons(n, ns) =&gt; 
            match vals {
                Nil =&gt; env
              | Cons(v, vs) =&gt; extend_all(ns, vs, extend(n, v, env))
            }
    }
</code></pre>
<h3 id="part-5-integer-parsing"><a class="header" href="#part-5-integer-parsing">Part 5: Integer Parsing</a></h3>
<pre><code class="language-kleis">define is_digit_char(c: String) : Bool =
    or(eq(c, "0"), or(eq(c, "1"), or(eq(c, "2"), or(eq(c, "3"), or(eq(c, "4"),
    or(eq(c, "5"), or(eq(c, "6"), or(eq(c, "7"), or(eq(c, "8"), eq(c, "9"))))))))))

define is_number_str(s: String) : Bool =
    if le(strlen(s), 0) then false
    else if eq(charAt(s, 0), "-") then 
        if le(strlen(s), 1) then false 
        else all_digits(substr(s, 1, strlen(s) - 1))
    else all_digits(s)

define all_digits(s: String) : Bool =
    if le(strlen(s), 0) then true
    else if is_digit_char(charAt(s, 0)) then all_digits(substr(s, 1, strlen(s) - 1))
    else false

define parse_int(s: String) : ‚Ñ§ =
    if eq(charAt(s, 0), "-") then 0 - parse_int_pos(substr(s, 1, strlen(s) - 1))
    else parse_int_pos(s)

define parse_int_pos(s: String) : ‚Ñ§ =
    parse_int_acc(s, 0)

define parse_int_acc(s: String, acc: ‚Ñ§) : ‚Ñ§ =
    if le(strlen(s), 0) then acc
    else 
        let d = digit_val(charAt(s, 0)) in
        parse_int_acc(substr(s, 1, strlen(s) - 1), acc * 10 + d)

define digit_val(c: String) : ‚Ñ§ =
    if eq(c, "0") then 0 else if eq(c, "1") then 1 else if eq(c, "2") then 2
    else if eq(c, "3") then 3 else if eq(c, "4") then 4 else if eq(c, "5") then 5
    else if eq(c, "6") then 6 else if eq(c, "7") then 7 else if eq(c, "8") then 8
    else 9
</code></pre>
<h3 id="part-6-main-evaluator"><a class="header" href="#part-6-main-evaluator">Part 6: Main Evaluator</a></h3>
<pre><code class="language-kleis">define eval_lisp(expr: SExpr, env: Env) : LispVal =
    match expr {
        SAtom(s) =&gt; 
            if is_number_str(s) then VNum(parse_int(s))
            else if eq(s, "true") then VBool(true)
            else if eq(s, "false") then VBool(false)
            else lookup(s, env)
      | SList(elements) =&gt; eval_list(elements, env)
    }

define eval_list(elements: List(SExpr), env: Env) : LispVal =
    match elements {
        Nil =&gt; VList(Nil)  // Empty list is a value
      | Cons(head, rest) =&gt; eval_form(head, rest, env)
    }

// Evaluate a special form or function call
define eval_form(head: SExpr, args: List(SExpr), env: Env) : LispVal =
    match head {
        SAtom(op) =&gt; 
            // Special forms
            if eq(op, "if") then eval_if(args, env)
            else if eq(op, "quote") then eval_quote(args)
            else if eq(op, "lambda") then eval_lambda(args, env)
            else if eq(op, "let") then eval_let(args, env)
            else if eq(op, "letrec") then eval_letrec(args, env)
            // Arithmetic
            else if eq(op, "+") then eval_add(args, env)
            else if eq(op, "-") then eval_sub(args, env)
            else if eq(op, "*") then eval_mul(args, env)
            else if eq(op, "/") then eval_div(args, env)
            // Comparison
            else if eq(op, "&lt;") then eval_lt(args, env)
            else if eq(op, "&gt;") then eval_gt(args, env)
            else if eq(op, "=") then eval_eq(args, env)
            else if eq(op, "&lt;=") then eval_le(args, env)
            else if eq(op, "&gt;=") then eval_ge(args, env)
            // List operations
            else if eq(op, "list") then eval_list_op(args, env)
            else if eq(op, "car") then eval_car(args, env)
            else if eq(op, "cdr") then eval_cdr(args, env)
            else if eq(op, "cons") then eval_cons(args, env)
            else if eq(op, "null?") then eval_null(args, env)
            // Function call
            else eval_call(op, args, env)
      | SList(_) =&gt; 
            // First element is an expression (e.g., lambda)
            let fn_val = eval_lisp(head, env) in
            eval_apply(fn_val, args, env)
    }
</code></pre>
<h3 id="part-7-special-forms"><a class="header" href="#part-7-special-forms">Part 7: Special Forms</a></h3>
<pre><code class="language-kleis">define eval_if(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(cond, Cons(then_br, Cons(else_br, Nil))) =&gt;
            let cv = eval_lisp(cond, env) in
            if is_truthy(cv) then eval_lisp(then_br, env) else eval_lisp(else_br, env)
      | _ =&gt; VSym("Error: if requires 3 arguments")
    }

define is_truthy(v: LispVal) : Bool =
    match v {
        VBool(b) =&gt; b
      | VNum(n) =&gt; not(eq(n, 0))
      | VList(Nil) =&gt; false
      | VList(_) =&gt; true
      | VSym(_) =&gt; false
      | VLambda(_, _, _) =&gt; true
    }

define eval_quote(args: List(SExpr)) : LispVal =
    match args {
        Cons(expr, Nil) =&gt; sexpr_to_val(expr)
      | _ =&gt; VSym("Error: quote requires 1 argument")
    }

define sexpr_to_val(expr: SExpr) : LispVal =
    match expr {
        SAtom(s) =&gt; if is_number_str(s) then VNum(parse_int(s)) else VSym(s)
      | SList(elements) =&gt; VList(map_sexpr_to_val(elements))
    }

define map_sexpr_to_val(xs: List(SExpr)) : List(LispVal) =
    match xs {
        Nil =&gt; Nil
      | Cons(h, t) =&gt; Cons(sexpr_to_val(h), map_sexpr_to_val(t))
    }

define eval_lambda(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(params), Cons(body, Nil)) =&gt;
            VLambda(extract_param_names(params), body, env)
      | _ =&gt; VSym("Error: lambda requires (params) body")
    }

define extract_param_names(params: List(SExpr)) : List(String) =
    match params {
        Nil =&gt; Nil
      | Cons(SAtom(name), rest) =&gt; Cons(name, extract_param_names(rest))
      | _ =&gt; Nil
    }

define eval_let(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(bindings), Cons(body, Nil)) =&gt;
            let new_env = eval_let_bindings(bindings, env) in
            eval_lisp(body, new_env)
      | _ =&gt; VSym("Error: let requires ((bindings)) body")
    }

define eval_let_bindings(bindings: List(SExpr), env: Env) : Env =
    match bindings {
        Nil =&gt; env
      | Cons(SList(Cons(SAtom(name), Cons(val_expr, Nil))), rest) =&gt;
            let val = eval_lisp(val_expr, env) in
            eval_let_bindings(rest, extend(name, val, env))
      | _ =&gt; env
    }

// letrec: evaluate lambda in an environment that already contains the binding
// This enables recursion: (letrec ((fact (lambda (n) ...))) (fact 5))
define eval_letrec(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(bindings), Cons(body, Nil)) =&gt;
            let rec_env = eval_letrec_bindings(bindings, env) in
            eval_lisp(body, rec_env)
      | _ =&gt; VSym("Error: letrec requires ((bindings)) body")
    }

define eval_letrec_bindings(bindings: List(SExpr), env: Env) : Env =
    match bindings {
        Nil =&gt; env
      | Cons(SList(Cons(SAtom(name), Cons(SList(Cons(SAtom(lambda_kw), 
            Cons(SList(params), Cons(body, Nil)))), Nil))), rest) =&gt;
            let dummy_env = extend(name, VSym("placeholder"), env) in
            let lambda_val = VLambda(extract_param_names(params), body, dummy_env) in
            let new_env = extend(name, lambda_val, env) in
            let fixed_lambda = VLambda(extract_param_names(params), body, new_env) in
            eval_letrec_bindings(rest, extend(name, fixed_lambda, env))
      | _ =&gt; env
    }
</code></pre>
<h3 id="part-8-arithmetic-operations"><a class="header" href="#part-8-arithmetic-operations">Part 8: Arithmetic Operations</a></h3>
<pre><code class="language-kleis">define eval_add(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x + y)
                  | _ =&gt; VSym("Error: + requires numbers")
                }
              | _ =&gt; VSym("Error: + requires numbers")
            }
      | _ =&gt; VSym("Error: + requires 2 arguments")
    }

define eval_sub(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x - y)
                  | _ =&gt; VSym("Error: - requires numbers")
                }
              | _ =&gt; VSym("Error: - requires numbers")
            }
      | _ =&gt; VSym("Error: - requires 2 arguments")
    }

define eval_mul(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x * y)
                  | _ =&gt; VSym("Error: * requires numbers")
                }
              | _ =&gt; VSym("Error: * requires numbers")
            }
      | _ =&gt; VSym("Error: * requires 2 arguments")
    }

define eval_div(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; if eq(y, 0) then VSym("Error: division by zero") 
                               else VNum(x / y)
                  | _ =&gt; VSym("Error: / requires numbers")
                }
              | _ =&gt; VSym("Error: / requires numbers")
            }
      | _ =&gt; VSym("Error: / requires 2 arguments")
    }
</code></pre>
<h3 id="part-9-comparison-operations"><a class="header" href="#part-9-comparison-operations">Part 9: Comparison Operations</a></h3>
<pre><code class="language-kleis">define eval_lt(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(lt(x, y))
                  | _ =&gt; VSym("Error: &lt; requires numbers")
                }
              | _ =&gt; VSym("Error: &lt; requires numbers")
            }
      | _ =&gt; VSym("Error: &lt; requires 2 arguments")
    }

define eval_gt(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(gt(x, y))
                  | _ =&gt; VSym("Error: &gt; requires numbers")
                }
              | _ =&gt; VSym("Error: &gt; requires numbers")
            }
      | _ =&gt; VSym("Error: &gt; requires 2 arguments")
    }

define eval_eq(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(eq(x, y))
                  | _ =&gt; VSym("Error: = requires numbers")
                }
              | _ =&gt; VSym("Error: = requires numbers")
            }
      | _ =&gt; VSym("Error: = requires 2 arguments")
    }

define eval_le(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(le(x, y))
                  | _ =&gt; VSym("Error: &lt;= requires numbers")
                }
              | _ =&gt; VSym("Error: &lt;= requires numbers")
            }
      | _ =&gt; VSym("Error: &lt;= requires 2 arguments")
    }

define eval_ge(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(ge(x, y))
                  | _ =&gt; VSym("Error: &gt;= requires numbers")
                }
              | _ =&gt; VSym("Error: &gt;= requires numbers")
            }
      | _ =&gt; VSym("Error: &gt;= requires 2 arguments")
    }
</code></pre>
<h3 id="part-10-list-operations"><a class="header" href="#part-10-list-operations">Part 10: List Operations</a></h3>
<pre><code class="language-kleis">define eval_list_op(args: List(SExpr), env: Env) : LispVal =
    VList(eval_all(args, env))

define eval_all(args: List(SExpr), env: Env) : List(LispVal) =
    match args {
        Nil =&gt; Nil
      | Cons(h, t) =&gt; Cons(eval_lisp(h, env), eval_all(t, env))
    }

define eval_car(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Cons(h, _)) =&gt; h
              | _ =&gt; VSym("Error: car requires non-empty list")
            }
      | _ =&gt; VSym("Error: car requires 1 argument")
    }

define eval_cdr(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Cons(_, t)) =&gt; VList(t)
              | _ =&gt; VSym("Error: cdr requires non-empty list")
            }
      | _ =&gt; VSym("Error: cdr requires 1 argument")
    }

define eval_cons(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(h, Cons(t, Nil)) =&gt;
            let hv = eval_lisp(h, env) in
            match eval_lisp(t, env) {
                VList(lst) =&gt; VList(Cons(hv, lst))
              | _ =&gt; VSym("Error: cons requires list as second arg")
            }
      | _ =&gt; VSym("Error: cons requires 2 arguments")
    }

define eval_null(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Nil) =&gt; VBool(true)
              | VList(_) =&gt; VBool(false)
              | _ =&gt; VSym("Error: null? requires list")
            }
      | _ =&gt; VSym("Error: null? requires 1 argument")
    }
</code></pre>
<h3 id="part-11-function-application"><a class="header" href="#part-11-function-application">Part 11: Function Application</a></h3>
<pre><code class="language-kleis">define eval_call(name: String, args: List(SExpr), env: Env) : LispVal =
    let fn_val = lookup(name, env) in
    eval_apply(fn_val, args, env)

define eval_apply(fn_val: LispVal, args: List(SExpr), env: Env) : LispVal =
    match fn_val {
        VLambda(params, body, closure_env) =&gt;
            let arg_vals = eval_all(args, env) in
            // Merge current env into closure env for recursive calls
            let merged_env = merge_envs(env, closure_env) in
            let new_env = extend_all(params, arg_vals, merged_env) in
            eval_lisp(body, new_env)
      | VSym(msg) =&gt; VSym(msg)  // Error propagation
      | _ =&gt; VSym("Error: not a function")
    }

// Merge two environments: first takes precedence
// This allows letrec functions to see their own definitions
define merge_envs(e1: Env, e2: Env) : Env =
    match e1 {
        Env(b1) =&gt; match e2 {
            Env(b2) =&gt; Env(append_bindings(b1, b2))
        }
    }

define append_bindings(b1: List(Binding), b2: List(Binding)) : List(Binding) =
    match b1 {
        Nil =&gt; b2
      | Cons(h, t) =&gt; Cons(h, append_bindings(t, b2))
    }
</code></pre>
<h3 id="part-12-user-facing-run-function"><a class="header" href="#part-12-user-facing-run-function">Part 12: User-Facing Run Function</a></h3>
<pre><code class="language-kleis">// Run a LISP program from string
define run(code: String) : LispVal =
    eval_lisp(parse(code), empty_env)

// Run with an environment (for multiple expressions)
define run_with_env(code: String, env: Env) : LispVal =
    eval_lisp(parse(code), env)
</code></pre>
<hr>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<p>This LISP interpreter is a <strong>demonstration</strong>, not a production-level implementation. It proves that Kleis can parse and execute programs, but has known limitations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Issue</th><th>Description</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>Trailing junk ignored</strong></td><td><code>parse("(+ 1 2) garbage")</code> parses successfully, ignoring ‚Äúgarbage‚Äù</td><td>Known</td></tr>
<tr><td><strong>Errors as atoms</strong></td><td>Parse errors return <code>SAtom("Error: ...")</code> instead of a proper error type</td><td>Known</td></tr>
<tr><td><strong>No quote syntax</strong></td><td>Standard LISP <code>'(1 2 3)</code> is not supported; use <code>(list 1 2 3)</code> instead</td><td>Known</td></tr>
<tr><td><strong>Limited special forms</strong></td><td>Only <code>if</code>, <code>lambda</code>, <code>let</code>, <code>letrec</code>, <code>define</code> are implemented</td><td>By design</td></tr>
<tr><td><strong>No macros</strong></td><td>LISP macros are not supported</td><td>By design</td></tr>
<tr><td><strong>Integer-only arithmetic</strong></td><td>No floating-point numbers</td><td>By design</td></tr>
</tbody>
</table>
</div>
<h3 id="why-these-limitations-exist"><a class="header" href="#why-these-limitations-exist">Why These Limitations Exist</a></h3>
<p>This interpreter demonstrates <strong>Kleis‚Äôs meta-language capabilities</strong>, not LISP completeness. The goal is to show:</p>
<ol>
<li>Kleis can parse arbitrary grammars using recursive descent</li>
<li>Kleis can build and traverse ASTs (S-expressions as Kleis data types)</li>
<li>Kleis can execute recursive programs via <code>:eval</code></li>
<li>Kleis is Turing-complete</li>
</ol>
<p>For production LISP, use Racket, SBCL, or Clojure.</p>
<hr>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>This LISP interpreter demonstrates that <strong>Kleis is Turing-complete</strong> and can serve as a host language for other programming languages. The implementation uses:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Kleis Construct</th></tr>
</thead>
<tbody>
<tr><td><strong>Data types</strong></td><td><code>data SExpr</code>, <code>data LispVal</code>, <code>data Env</code></td></tr>
<tr><td><strong>Pattern matching</strong></td><td><code>match expr { ... }</code></td></tr>
<tr><td><strong>Recursion</strong></td><td>Recursive function definitions</td></tr>
<tr><td><strong>Higher-order functions</strong></td><td><code>lambda</code>, closures with captured environments</td></tr>
<tr><td><strong>String operations</strong></td><td><code>charAt</code>, <code>substr</code>, <code>concat</code>, <code>strlen</code></td></tr>
<tr><td><strong>List operations</strong></td><td><code>Cons</code>, <code>Nil</code>, pattern matching on lists</td></tr>
</tbody>
</table>
</div>
<h3 id="key-insights"><a class="header" href="#key-insights">Key Insights</a></h3>
<ol>
<li>
<p><strong><code>:eval</code> enables execution</strong> ‚Äî The <code>:eval</code> REPL command executes Kleis functions directly, without going through Z3‚Äôs symbolic unrolling.</p>
</li>
<li>
<p><strong>Environment merging for recursion</strong> ‚Äî <code>letrec</code> works by merging the current environment (which contains the function binding) into the closure‚Äôs environment.</p>
</li>
<li>
<p><strong>60 pure functions</strong> ‚Äî The entire interpreter is implemented in ~560 lines of pure functional Kleis code.</p>
</li>
<li>
<p><strong>Meta-circular potential</strong> ‚Äî With minor extensions, this could interpret a subset of Kleis itself, demonstrating meta-circularity.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vs-code-debugging"><a class="header" href="#vs-code-debugging">VS Code Debugging</a></h1>
<p>This appendix explains how to set up and use the VS Code debugger with Kleis.</p>
<p><img src="images/vscode-debugger.png" alt="VS Code Debugger with Kleis"></p>
<p><em>VS Code debugging a Kleis file: breakpoint on line 69, Variables panel showing expression AST, Call Stack showing evaluation context, and Debug Console with status messages.</em></p>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ol>
<li><strong>VS Code</strong> installed</li>
<li><strong>Kleis extension</strong> installed (provides syntax highlighting + debugging)</li>
<li><strong>Kleis binaries</strong> built:
<pre><code class="language-bash">cargo build --release --bin kleis --bin kleis-lsp
</code></pre>
</li>
</ol>
<h2 id="extension-setup"><a class="header" href="#extension-setup">Extension Setup</a></h2>
<p>The Kleis VS Code extension is located in <code>vscode-kleis/</code>. Install it:</p>
<pre><code class="language-bash">cd vscode-kleis
npm install
npm run compile
code --install-extension kleis-*.vsix
</code></pre>
<p>Or for development, open the extension folder in VS Code and press F5 to launch an Extension Development Host.</p>
<h2 id="workspace-settings"><a class="header" href="#workspace-settings">Workspace Settings</a></h2>
<p>Create <code>.vscode/settings.json</code> in your project to configure the extension:</p>
<pre><code class="language-json">{
  "kleis.serverPath": "${workspaceFolder}/target/release/kleis",
  "kleis.replPath": "${workspaceFolder}/target/release/repl",
  "kleis.trace.server": "off"
}
</code></pre>
<h3 id="settings-reference"><a class="header" href="#settings-reference">Settings Reference</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Setting</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>kleis.serverPath</code></td><td>Path to the <code>kleis</code> binary (used for LSP and DAP)</td></tr>
<tr><td><code>kleis.replPath</code></td><td>Path to the <code>repl</code> binary (used for REPL panel)</td></tr>
<tr><td><code>kleis.trace.server</code></td><td>Logging level: <code>"off"</code>, <code>"messages"</code>, or <code>"verbose"</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> Use absolute paths for reliability. Example for a typical setup:</p>
<pre><code class="language-json">{
  "kleis.serverPath": "/Users/yourname/git/kleis/target/release/kleis",
  "kleis.replPath": "/Users/yourname/git/kleis/target/release/repl",
  "kleis.trace.server": "off"
}
</code></pre>
<p>Set <code>"kleis.trace.server": "verbose"</code> when debugging extension issues.</p>
<h2 id="launch-configuration"><a class="header" href="#launch-configuration">Launch Configuration</a></h2>
<p>Create <code>.vscode/launch.json</code> in your project:</p>
<pre><code class="language-json">{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "kleis",
            "request": "launch",
            "name": "Debug Kleis File",
            "program": "${file}",
            "stopOnEntry": false
        }
    ]
}
</code></pre>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Option</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>program</code></td><td>string</td><td>Path to .kleis file to debug</td></tr>
<tr><td><code>stopOnEntry</code></td><td>boolean</td><td>Stop at first line (default: false)</td></tr>
</tbody>
</table>
</div>
<h2 id="setting-breakpoints"><a class="header" href="#setting-breakpoints">Setting Breakpoints</a></h2>
<p>Click in the gutter (left margin) next to any line in an example block:</p>
<pre><code class="language-kleis">example "my test" {
    let x = 5          // ‚Üê Click here to set breakpoint
    let y = double(x)  // ‚Üê Or here
    assert(y = 10)
}
</code></pre>
<h3 id="where-breakpoints-work"><a class="header" href="#where-breakpoints-work">Where Breakpoints Work</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Location</th><th>Works?</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Inside example blocks</td><td>‚úÖ Yes</td><td><code>let</code>, <code>assert</code>, expressions</td></tr>
<tr><td>Function body lines</td><td>‚úÖ Yes</td><td>Stops when function is called</td></tr>
<tr><td>Top-level definitions</td><td>‚ùå No</td><td>Declarations, not executable</td></tr>
<tr><td>Imported files</td><td>‚úÖ Yes</td><td>Set breakpoints in helper files</td></tr>
</tbody>
</table>
</div>
<h3 id="breakpoints-in-imported-files"><a class="header" href="#breakpoints-in-imported-files">Breakpoints in Imported Files</a></h3>
<p>You can set breakpoints in imported files:</p>
<pre><code class="language-kleis">// helpers.kleis
define double(n) =
    n + n    // ‚Üê Breakpoint here catches all calls to double()

// main.kleis
import "helpers.kleis"

example "cross-file breakpoint" {
    let x = double(5)  // Stops at the breakpoint in helpers.kleis
}
</code></pre>
<p><strong>Tip:</strong> Open the imported file and set breakpoints before starting the debug session.</p>
<h2 id="starting-a-debug-session"><a class="header" href="#starting-a-debug-session">Starting a Debug Session</a></h2>
<ol>
<li>Open a <code>.kleis</code> file with example blocks</li>
<li>Set breakpoints on lines you want to inspect</li>
<li>Press <strong>F5</strong> or click <strong>Run ‚Üí Start Debugging</strong></li>
<li>Select ‚ÄúDebug Kleis File‚Äù configuration</li>
</ol>
<h2 id="debug-controls"><a class="header" href="#debug-controls">Debug Controls</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Action</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>F5</td><td>Continue</td><td>Run until next breakpoint</td></tr>
<tr><td>F10</td><td>Step Over</td><td>Execute current line, don‚Äôt enter functions</td></tr>
<tr><td>F11</td><td>Step Into</td><td>Enter function calls</td></tr>
<tr><td>Shift+F11</td><td>Step Out</td><td>Finish current function, return to caller</td></tr>
<tr><td>Shift+F5</td><td>Stop</td><td>End debug session</td></tr>
</tbody>
</table>
</div>
<h2 id="inspecting-variables"><a class="header" href="#inspecting-variables">Inspecting Variables</a></h2>
<p>The <strong>Variables</strong> panel (left sidebar) shows:</p>
<ul>
<li><strong>Local variables</strong> ‚Äî Let bindings in current scope</li>
<li><strong>Function parameters</strong> ‚Äî Arguments passed to current function</li>
<li><strong>Inferred types</strong> ‚Äî When available, types are displayed</li>
</ul>
<p><strong>Important:</strong> Variables are displayed as <strong>AST expressions</strong>, not just values:</p>
<pre><code class="language-kleis">example "inspection demo" {
    let x = 5
    let y = x + 1
    // Variables panel shows:
    //   x = Const("5")
    //   y = Operation { name: "plus", args: [Const("5"), Const("1")] }
}
</code></pre>
<h3 id="type-aware-variable-display"><a class="header" href="#type-aware-variable-display">Type-Aware Variable Display</a></h3>
<p>When type information is available, variables show their inferred types:</p>
<pre><code class="language-kleis">example "typed variables" {
    let M = matrix2x3([[1,2,3],[4,5,6]])
    let v = vector3([1, 2, 3])
    let c = complex(1, 2)
    
    // Variables panel shows:
    //   M : Matrix(2,3,‚Ñù) = [[1,2,3],[4,5,6]]
    //   v : Vector(3,‚Ñù) = [1, 2, 3]
    //   c : ‚ÑÇ = 1+2i
}
</code></pre>
<p>This is intentional! Kleis is a <strong>symbolic mathematics system</strong>. Variables hold expressions that represent mathematical objects, not just computed values. This enables:</p>
<ol>
<li><strong>Symbolic manipulation</strong> ‚Äî See the structure of expressions</li>
<li><strong>Z3 verification</strong> ‚Äî Pass expressions to the theorem prover</li>
<li><strong>Provenance tracking</strong> ‚Äî Understand where values came from</li>
<li><strong>Type checking</strong> ‚Äî Verify types match expectations</li>
</ol>
<h2 id="call-stack"><a class="header" href="#call-stack">Call Stack</a></h2>
<p>The <strong>Call Stack</strong> panel shows the execution path:</p>
<pre><code>fibonacci (n=5)          ‚Üê Currently here
fibonacci (n=6)
example "fib test"       ‚Üê Entry point
</code></pre>
<p>Click any frame to see its local variables and source location.</p>
<h2 id="cross-file-debugging-1"><a class="header" href="#cross-file-debugging-1">Cross-File Debugging</a></h2>
<p>When stepping into imported functions, VS Code opens the source file:</p>
<pre><code class="language-kleis">// main.kleis
import "helpers.kleis"

example "cross-file" {
    let result = helper_function(5)  // ‚Üê Step Into (F11)
    // VS Code opens helpers.kleis at helper_function definition
}
</code></pre>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<p>Every expression carries its <strong>source location</strong> (line, column, file path). When the evaluator processes an expression from an imported file, the debugger reports that file‚Äôs location to VS Code, which opens it automatically.</p>
<h2 id="debug-console"><a class="header" href="#debug-console">Debug Console</a></h2>
<p>The Debug Console (bottom panel) shows:</p>
<ul>
<li>Evaluation progress</li>
<li>Assertion results (pass/fail)</li>
<li>Error messages</li>
</ul>
<p>You can also evaluate expressions in the console during a paused debug session.</p>
<h2 id="assert-with-z3-verification"><a class="header" href="#assert-with-z3-verification">Assert with Z3 Verification</a></h2>
<p><strong>New in v0.93:</strong> Assertions in example blocks use Z3 for symbolic verification!</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How It Works</a></h3>
<p>When you write <code>assert(expr)</code>:</p>
<ol>
<li><strong>Concrete values</strong> ‚Äî Checked via structural equality</li>
<li><strong>Symbolic expressions</strong> ‚Äî Verified using Z3 theorem prover</li>
</ol>
<pre><code class="language-kleis">structure CommutativeRing(R) {
    operation (+) : R √ó R ‚Üí R
    axiom commutativity: ‚àÄ(a b : R). a + b = b + a
}

example "symbolic verification" {
    // ‚úÖ Z3 verifies using commutativity axiom!
    assert(x + y = y + x)
    
    // ‚ùå Z3 disproves with counterexample
    // assert(x + y = y + y)  // "Counterexample: y!1 -&gt; 1, x!0 -&gt; 0"
    
    // ‚úÖ Concrete: structural equality
    let a = 5
    assert(a = 5)
}
</code></pre>
<h3 id="assertion-results"><a class="header" href="#assertion-results">Assertion Results</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Result</th><th>Badge</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>Passed</code></td><td>‚úì</td><td>Concrete values match structurally</td></tr>
<tr><td><code>Verified</code></td><td>‚úì</td><td>Z3 proved the symbolic claim</td></tr>
<tr><td><code>Failed { expected, actual }</code></td><td>‚úó</td><td>Concrete values differ</td></tr>
<tr><td><code>Disproved { counterexample }</code></td><td>‚úó</td><td>Z3 found a counterexample</td></tr>
<tr><td><code>Unknown</code></td><td>‚úó</td><td>Could not verify (treated as failure)</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> The debugger displays verification badges (‚úì/‚úó) next to assertion variables in the Variables panel, so you can see at a glance which assertions passed or failed.</p>
<h3 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h3>
<ul>
<li>Structure axioms must be defined for the operations used</li>
<li>Z3 must be able to load the relevant axioms</li>
<li>Works best with algebraic properties (commutativity, associativity, etc.)</li>
</ul>
<h2 id="numerical-computations"><a class="header" href="#numerical-computations">Numerical Computations</a></h2>
<p>For concrete numerical computations, build with the <code>numerical</code> feature:</p>
<pre><code class="language-bash">cargo build --release --features numerical
</code></pre>
<p>This enables LAPACK-backed operations:</p>
<pre><code class="language-kleis">example "numerical" {
    let A = Matrix(2, 2, [4, 1, 1, 4])
    
    // Compute eigenvalues (requires numerical feature)
    let eigs = eigenvalues(A)
    // eigs = [5, 3]
    
    // Matrix multiplication
    let B = Matrix(2, 2, [1, 0, 0, 2])
    let C = matmul(A, B)
    
    // SVD decomposition
    let usv = svd(A)  // Returns [U, S, V]
}
</code></pre>
<h3 id="available-numerical-operations"><a class="header" href="#available-numerical-operations">Available Numerical Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>eigenvalues(M)</code></td><td>Compute eigenvalues</td></tr>
<tr><td><code>eig(M)</code></td><td>Eigenvalues and eigenvectors</td></tr>
<tr><td><code>svd(M)</code></td><td>Singular value decomposition</td></tr>
<tr><td><code>solve(A, b)</code></td><td>Solve linear system Ax = b</td></tr>
<tr><td><code>inv(M)</code></td><td>Matrix inverse</td></tr>
<tr><td><code>det(M)</code></td><td>Determinant</td></tr>
<tr><td><code>cholesky(M)</code></td><td>Cholesky decomposition</td></tr>
<tr><td><code>qr(M)</code></td><td>QR factorization</td></tr>
<tr><td><code>matmul(A, B)</code></td><td>Matrix multiplication</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> Numerical operations require concrete values. Symbolic matrices remain symbolic.</p>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="breakpoints-not-hitting"><a class="header" href="#breakpoints-not-hitting">Breakpoints Not Hitting</a></h3>
<p><strong>Problem:</strong> Breakpoint shows as gray (unverified) or never hits.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>Ensure breakpoint is on a line inside an example block</li>
<li>Ensure the example block is actually executed</li>
<li>Rebuild the Kleis binaries: <code>cargo build --release</code></li>
</ol>
<h3 id="file-not-found-errors"><a class="header" href="#file-not-found-errors">‚ÄúFile not found‚Äù Errors</a></h3>
<p><strong>Problem:</strong> Debugger can‚Äôt find imported files.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>Use relative paths in imports: <code>import "stdlib/complex.kleis"</code></li>
<li>Run debug session from the project root directory</li>
<li>Check that the imported file exists at the specified path</li>
</ol>
<h3 id="slow-stepping"><a class="header" href="#slow-stepping">Slow Stepping</a></h3>
<p><strong>Problem:</strong> Each step takes several seconds.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>Use release builds: <code>cargo build --release</code></li>
<li>Avoid stepping through deeply recursive functions</li>
<li>Use ‚ÄúStep Over‚Äù (F10) instead of ‚ÄúStep Into‚Äù (F11) for library functions</li>
</ol>
<h3 id="debug-session-wont-start"><a class="header" href="#debug-session-wont-start">Debug Session Won‚Äôt Start</a></h3>
<p><strong>Problem:</strong> F5 does nothing or shows an error.</p>
<p><strong>Solutions:</strong></p>
<ol>
<li>Check <code>.vscode/launch.json</code> exists and is valid JSON</li>
<li>Ensure Kleis extension is installed and enabled</li>
<li>Check the Output panel (View ‚Üí Output ‚Üí Kleis) for error messages</li>
<li>Verify binaries exist: <code>ls target/release/kleis*</code></li>
</ol>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>The debugging system uses the <strong>Debug Adapter Protocol (DAP)</strong>:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      DAP         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   VS Code   ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ‚îÇ kleis server ‚îÇ
‚îÇ   (client)  ‚îÇ    JSON-RPC      ‚îÇ   (adapter)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                        ‚îÇ
                                        ‚ñº
                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                  ‚îÇ  Evaluator   ‚îÇ
                                  ‚îÇ  + DebugHook ‚îÇ
                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<ol>
<li>VS Code sends DAP commands (setBreakpoints, next, stepIn, etc.)</li>
<li>Kleis server translates to evaluator debug hook calls</li>
<li>Evaluator pauses at breakpoints, reports current expression‚Äôs span</li>
<li>Server sends stopped events with location (line, column, file)</li>
<li>VS Code highlights the current line</li>
</ol>
<h3 id="source-span-tracking"><a class="header" href="#source-span-tracking">Source Span Tracking</a></h3>
<p>The key to accurate debugging is <strong>SourceSpan</strong>:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SourceSpan {
    pub line: u32,
    pub column: u32,
    pub end_line: u32,
    pub end_column: u32,
    pub file: Option&lt;Arc&lt;PathBuf&gt;&gt;,  // File path (Arc for cheap cloning)
}
<span class="boring">}</span></code></pre>
<p>Every <code>Expression</code> node has an optional span. The parser attaches the span during parsing. When evaluating, the span travels with the expression, so the debugger always knows the source location.</p>
<h2 id="understanding-symbolic-debugging"><a class="header" href="#understanding-symbolic-debugging">Understanding Symbolic Debugging</a></h2>
<p>Kleis debugging differs from traditional debuggers because Kleis is a <strong>symbolic mathematics system</strong>, not an imperative programming language.</p>
<h3 id="what-execution-means-in-kleis"><a class="header" href="#what-execution-means-in-kleis">What ‚ÄúExecution‚Äù Means in Kleis</a></h3>
<p>In Kleis, ‚Äúexecution‚Äù means <strong>symbolic evaluation</strong>:</p>
<ol>
<li><strong>Substitution</strong> ‚Äî Replace function calls with their definitions</li>
<li><strong>Pattern matching</strong> ‚Äî Dispatch based on structure</li>
<li><strong>Simplification</strong> ‚Äî Apply algebraic rules</li>
</ol>
<p>There‚Äôs no ‚Äúprogram counter‚Äù moving through instructions. Instead, expressions transform into simpler expressions.</p>
<h3 id="variables-hold-expressions-not-values"><a class="header" href="#variables-hold-expressions-not-values">Variables Hold Expressions, Not Values</a></h3>
<pre><code class="language-kleis">let y = sin(x) + cos(x)
// y doesn't hold a number
// y holds: Operation { name: "plus", args: [sin(x), cos(x)] }
</code></pre>
<p>This is intentional! It enables:</p>
<ul>
<li>Passing expressions to Z3 for verification</li>
<li>Symbolic differentiation, integration</li>
<li>Algebraic manipulation</li>
</ul>
<h3 id="when-to-use-the-debugger"><a class="header" href="#when-to-use-the-debugger">When to Use the Debugger</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Use Case</th><th>Debugger Helps?</th></tr>
</thead>
<tbody>
<tr><td>Understanding expression evaluation</td><td>‚úÖ Excellent</td></tr>
<tr><td>Verifying axiom applications</td><td>‚úÖ See Z3 results</td></tr>
<tr><td>Finding structural issues</td><td>‚úÖ See AST in Variables</td></tr>
<tr><td>Computing numeric values</td><td>üî∂ Need <code>numerical</code> feature</td></tr>
<tr><td>Traditional imperative debugging</td><td>‚ùå Wrong mental model</td></tr>
</tbody>
</table>
</div>
<h2 id="tips-for-effective-debugging"><a class="header" href="#tips-for-effective-debugging">Tips for Effective Debugging</a></h2>
<ol>
<li><strong>Start with simple examples</strong> ‚Äî Debug small example blocks first</li>
<li><strong>Use Step Over for library code</strong> ‚Äî Don‚Äôt step into stdlib functions unless needed</li>
<li><strong>Watch the Variables panel</strong> ‚Äî See how expressions transform as you step</li>
<li><strong>Set multiple breakpoints</strong> ‚Äî Mark key points in your logic</li>
<li><strong>Use the Call Stack</strong> ‚Äî Understand the substitution chain</li>
<li><strong>Think symbolically</strong> ‚Äî Variables hold AST, not computed values</li>
<li><strong>Use Z3 for verification</strong> ‚Äî Let <code>assert()</code> prove symbolic claims</li>
</ol>
<h2 id="see-also-6"><a class="header" href="#see-also-6">See Also</a></h2>
<ul>
<li><a href="#example-blocks-v093">Example Blocks</a> ‚Äî How to write debuggable code</li>
<li><a href="#the-repl-1">The REPL</a> ‚Äî Interactive exploration</li>
<li><a href="#appendix-a-grammar-reference">Grammar Reference</a> ‚Äî Full language syntax</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-cartan-geometry-and-tensor-computation"><a class="header" href="#appendix-cartan-geometry-and-tensor-computation">Appendix: Cartan Geometry and Tensor Computation</a></h1>
<p>This appendix demonstrates Kleis‚Äôs capability to perform <strong>symbolic tensor calculus</strong> for general relativity, computing actual curvature tensors from metric specifications.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Kleis implements Cartan‚Äôs formalism for differential geometry:</p>
<pre><code>Metric ‚Üí Tetrad ‚Üí Connection ‚Üí Curvature ‚Üí Ricci ‚Üí Einstein
</code></pre>
<p>This is the same computational pipeline used in research-grade general relativity software like xAct (Mathematica) and Cadabra.</p>
<h2 id="the-cartan-pipeline"><a class="header" href="#the-cartan-pipeline">The Cartan Pipeline</a></h2>
<h3 id="1-expression-ast"><a class="header" href="#1-expression-ast">1. Expression AST</a></h3>
<p>Symbolic expressions are represented using the <code>Expression</code> algebraic data type, consistent with <code>kleis_in_kleis.kleis</code>:</p>
<pre><code class="language-kleis">data Expression = 
    ENumber(value : ‚Ñù)
  | EVariable(name : String)
  | EOperation(name : String, args : List(Expression))
</code></pre>
<p>This representation allows any operation to be encoded uniformly via <code>EOperation</code>. Helper constructors provide cleaner syntax:</p>
<pre><code class="language-kleis">// Value constructors
define num(n) = ENumber(n)
define var(x) = EVariable(x)

// Operation constructors (e_ prefix avoids builtin conflicts)
define e_add(a, b) = EOperation("plus", Cons(a, Cons(b, Nil)))
define e_mul(a, b) = EOperation("times", Cons(a, Cons(b, Nil)))
define e_pow(a, b) = EOperation("power", Cons(a, Cons(b, Nil)))
define e_sin(a) = EOperation("sin", Cons(a, Nil))
define e_cos(a) = EOperation("cos", Cons(a, Nil))
define e_sqrt(a) = EOperation("sqrt", Cons(a, Nil))
// ... etc
</code></pre>
<h3 id="2-symbolic-differentiation"><a class="header" href="#2-symbolic-differentiation">2. Symbolic Differentiation</a></h3>
<p>The <code>diff</code> function computes derivatives by pattern matching on the <code>Expression</code> AST:</p>
<pre><code class="language-kleis">define diff(e, var_name) = match e {
    // Constant rule: d/dx(c) = 0
    ENumber(_) =&gt; num(0)
    
    // Variable rule: d/dx(x) = 1, d/dx(y) = 0 if y ‚â† x
    // Note: str_eq() is used for concrete string comparison
    EVariable(name) =&gt; if str_eq(name, var_name) then num(1) else num(0)
    
    // Operation rules - dispatch by operation name
    EOperation(op_name, args) =&gt; diff_op(op_name, args, var_name)
}

define diff_op(op_name, args, var_name) = match op_name {
    "plus" =&gt; match args {
        Cons(f, Cons(g, Nil)) =&gt; e_add(diff(f, var_name), diff(g, var_name))
        | _ =&gt; num(0)
    }
    "times" =&gt; match args {
        // Product rule: d/dx(f * g) = f' * g + f * g'
        Cons(f, Cons(g, Nil)) =&gt; 
            e_add(e_mul(diff(f, var_name), g), e_mul(f, diff(g, var_name)))
        | _ =&gt; num(0)
    }
    "power" =&gt; match args {
        // Power rule with constant exponent
        Cons(f, Cons(ENumber(n), Nil)) =&gt; 
            e_mul(e_mul(num(n), e_pow(f, num(n - 1))), diff(f, var_name))
        // General power rule
        | _ =&gt; num(0)
    }
    "sin" =&gt; match args {
        Cons(f, Nil) =&gt; e_mul(e_cos(f), diff(f, var_name))
        | _ =&gt; num(0)
    }
    // ... more rules
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> We use <code>str_eq(name, var_name)</code> instead of pattern matching because Kleis patterns <strong>bind</strong> variables rather than compare them. The <code>str_eq</code> builtin provides concrete string equality.</p>
</blockquote>
<h3 id="3-differential-forms"><a class="header" href="#3-differential-forms">3. Differential Forms</a></h3>
<p>1-forms and 2-forms are represented as coefficient lists:</p>
<pre><code class="language-kleis">// 1-form: œâ = œâ_t dt + œâ_r dr + œâ_Œ∏ dŒ∏ + œâ_œÜ dœÜ
// Represented as [œâ_t, œâ_r, œâ_Œ∏, œâ_œÜ]

define dt = [num(1), num(0), num(0), num(0)]
define dr = [num(0), num(1), num(0), num(0)]
define dtheta = [num(0), num(0), num(1), num(0)]
define dphi = [num(0), num(0), num(0), num(1)]
</code></pre>
<h3 id="4-exterior-derivative"><a class="header" href="#4-exterior-derivative">4. Exterior Derivative</a></h3>
<pre><code class="language-kleis">// d(f) = ‚àÇf/‚àÇt dt + ‚àÇf/‚àÇr dr + ‚àÇf/‚àÇŒ∏ dŒ∏ + ‚àÇf/‚àÇœÜ dœÜ
define d0(f) = [
    simplify(diff_t(f)),
    simplify(diff_r(f)),
    simplify(diff_theta(f)),
    simplify(diff_phi(f))
]

// Coordinate-specific derivatives
define diff_t(e) = diff(e, "t")
define diff_r(e) = diff(e, "r")
define diff_theta(e) = diff(e, "theta")
define diff_phi(e) = diff(e, "phi")
</code></pre>
<h3 id="5-wedge-product"><a class="header" href="#5-wedge-product">5. Wedge Product</a></h3>
<pre><code class="language-kleis">// (Œ± ‚àß Œ≤)_ŒºŒΩ = Œ±_Œº Œ≤_ŒΩ - Œ±_ŒΩ Œ≤_Œº
define wedge(a, b) =
    let a0 = nth(a, 0) in let a1 = nth(a, 1) in
    let a2 = nth(a, 2) in let a3 = nth(a, 3) in
    let b0 = nth(b, 0) in let b1 = nth(b, 1) in
    let b2 = nth(b, 2) in let b3 = nth(b, 3) in
    [
        [num(0),
         simplify(e_sub(e_mul(a0, b1), e_mul(a1, b0))),
         ...],
        ...
    ]
</code></pre>
<h2 id="example-schwarzschild-black-hole"><a class="header" href="#example-schwarzschild-black-hole">Example: Schwarzschild Black Hole</a></h2>
<p>The Schwarzschild metric describes spacetime around a non-rotating black hole:</p>
<pre><code>ds¬≤ = -(1 - 2M/r)dt¬≤ + dr¬≤/(1 - 2M/r) + r¬≤dŒ∏¬≤ + r¬≤sin¬≤Œ∏ dœÜ¬≤
</code></pre>
<h3 id="tetrad-definition"><a class="header" href="#tetrad-definition">Tetrad Definition</a></h3>
<pre><code class="language-kleis">define schwarzschild_tetrad(M) =
    let f = e_sub(num(1), e_div(e_mul(num(2), M), var("r"))) in
    let sqrt_f = e_sqrt(f) in
    [
        scale1(sqrt_f, dt),                              // e‚Å∞ = ‚àöf dt
        scale1(e_div(num(1), sqrt_f), dr),              // e¬π = dr/‚àöf
        scale1(var("r"), dtheta),                        // e¬≤ = r dŒ∏
        scale1(e_mul(var("r"), e_sin(var("theta"))), dphi)  // e¬≥ = r sin(Œ∏) dœÜ
    ]
</code></pre>
<h3 id="computing-curvature"><a class="header" href="#computing-curvature">Computing Curvature</a></h3>
<pre><code class="language-kleis">define compute_riemann(tetrad) =
    let omega = solve_connection(tetrad) in
    compute_curvature(omega)

define schwarzschild_curvature(M) = 
    compute_riemann(schwarzschild_tetrad(M))
</code></pre>
<h3 id="results"><a class="header" href="#results">Results</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Computation</th><th>Size</th><th>Time</th></tr>
</thead>
<tbody>
<tr><td>Tetrad</td><td>~300 chars</td><td>instant</td></tr>
<tr><td>Connection œâ^a_b</td><td>~2,400 chars</td><td>~1s</td></tr>
<tr><td>Curvature R^a_b</td><td>~22,000 chars</td><td>~4s</td></tr>
</tbody>
</table>
</div>
<h2 id="literature-verification"><a class="header" href="#literature-verification">Literature Verification</a></h2>
<p>The computed results match known properties from the literature:</p>
<h3 id="minkowski-flat-space"><a class="header" href="#minkowski-flat-space">Minkowski (Flat Space)</a></h3>
<ul>
<li><strong>Expected:</strong> All curvature components = 0</li>
<li><strong>Computed:</strong> 238/256 components are <code>ENumber(0)</code> ‚úì</li>
<li><strong>Reference:</strong> Misner, Thorne, Wheeler ‚ÄúGravitation‚Äù (1973)</li>
</ul>
<h3 id="schwarzschild"><a class="header" href="#schwarzschild">Schwarzschild</a></h3>
<ul>
<li><strong>Expected:</strong> Curvature depends on M, r, angular coordinates</li>
<li><strong>Computed:</strong> Contains <code>EVariable("M")</code>, <code>EVariable("r")</code>, <code>sin</code>, <code>cos</code> ‚úì</li>
<li><strong>Expected:</strong> Contains metric factor ‚àö(1-2M/r)</li>
<li><strong>Computed:</strong> Contains <code>e_sqrt(e_sub(num(1), e_div(...)))</code> ‚úì</li>
<li><strong>Reference:</strong> Carroll ‚ÄúSpacetime and Geometry‚Äù (2004)</li>
</ul>
<h2 id="implementation-notes"><a class="header" href="#implementation-notes">Implementation Notes</a></h2>
<h3 id="why-e_-prefix"><a class="header" href="#why-e_-prefix">Why <code>e_*</code> Prefix?</a></h3>
<p>Functions like <code>pow</code>, <code>add</code>, <code>mul</code> conflict with Kleis builtins. When you write <code>pow(var("x"), num(2))</code>, Kleis interprets <code>pow</code> as the built-in power operation and tries to compute <code>EVariable("x") ^ ENumber(2)</code> numerically‚Äîwhich fails.</p>
<p>The <code>e_*</code> prefix (<code>e_pow</code>, <code>e_add</code>, etc.) ensures these are treated as user-defined functions that construct <code>EOperation</code> nodes.</p>
<h3 id="why-str_eq-instead-of-pattern-matching"><a class="header" href="#why-str_eq-instead-of-pattern-matching">Why <code>str_eq</code> Instead of Pattern Matching?</a></h3>
<p>In Kleis (and ML-family languages), pattern variables <strong>bind</strong> rather than compare:</p>
<pre><code class="language-kleis">// This BINDS 'x' to whatever name contains, always matches!
EVariable(name) =&gt; match name { x =&gt; num(1) | _ =&gt; num(0) }

// This COMPARES name to var_name using str_eq
EVariable(name) =&gt; if str_eq(name, var_name) then num(1) else num(0)
</code></pre>
<p>The <code>str_eq</code> builtin provides concrete string equality that returns <code>true</code> or <code>false</code>.</p>
<h2 id="z3-verification-4"><a class="header" href="#z3-verification-4">Z3 Verification</a></h2>
<p>While the Cartan computation runs in the Kleis evaluator, the results can be verified using Z3:</p>
<pre><code class="language-kleis">// Verify Riemann tensor symmetries
axiom riemann_antisym : ‚àÄ R Œº ŒΩ œÅ œÉ .
    component(R, Œº, ŒΩ, œÅ, œÉ) = negate(component(R, ŒΩ, Œº, œÅ, œÉ))

// Verify Bianchi identity
axiom bianchi : ‚àÄ R Œª œÅ œÉ Œº ŒΩ .
    plus(plus(
        nabla(R, Œª, œÅ, œÉ, Œº, ŒΩ),
        nabla(R, œÅ, œÉ, Œª, Œº, ŒΩ)),
        nabla(R, œÉ, Œª, œÅ, Œº, ŒΩ)) = 0
</code></pre>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>stdlib/symbolic_diff.kleis</code></td><td>Expression AST and symbolic differentiation</td></tr>
<tr><td><code>stdlib/cartan_geometry.kleis</code></td><td>Axiomatic framework (structures, axioms for Z3)</td></tr>
<tr><td><code>stdlib/cartan_compute.kleis</code></td><td>Computational implementation (actually computes)</td></tr>
<tr><td><code>tests/symbolic_diff_test.rs</code></td><td>25 tests for differentiation</td></tr>
<tr><td><code>tests/cartan_compute_test.rs</code></td><td>22 tests including literature verification</td></tr>
</tbody>
</table>
</div>
<h3 id="two-complementary-approaches"><a class="header" href="#two-complementary-approaches">Two Complementary Approaches</a></h3>
<p><strong><code>cartan_geometry.kleis</code></strong> defines the <em>theory</em>:</p>
<pre><code class="language-kleis">structure CurvatureForm(dim: Nat) {
    operation curvature : List(List(DifferentialForm(1, dim))) ‚Üí ...
    axiom curvature_def : ‚àÄ omega . R^a_b = dœâ^a_b + œâ^a_c ‚àß œâ^c_b
    axiom bianchi : ...  // Formal Bianchi identity for Z3
}
</code></pre>
<p><strong><code>cartan_compute.kleis</code></strong> provides the <em>computation</em>:</p>
<pre><code class="language-kleis">define compute_curvature(omega) = [
    [curvature_ab(omega, 0, 0), curvature_ab(omega, 0, 1), ...],
    ...  // Actually evaluates to Expression values
]
</code></pre>
<p>Both now use the same <code>Expression</code> AST from <code>symbolic_diff.kleis</code>.</p>
<h2 id="research-applications"><a class="header" href="#research-applications">Research Applications</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Domain</th><th>Application</th></tr>
</thead>
<tbody>
<tr><td><strong>General Relativity</strong></td><td>Compute curvature for new metrics</td></tr>
<tr><td><strong>Cosmology</strong></td><td>Verify FLRW, de Sitter models</td></tr>
<tr><td><strong>Modified Gravity</strong></td><td>Check f(R) theory consistency</td></tr>
<tr><td><strong>Numerical Relativity</strong></td><td>Verify constraint equations</td></tr>
<tr><td><strong>Education</strong></td><td>Interactive GR computations</td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-to-other-tools"><a class="header" href="#comparison-to-other-tools">Comparison to Other Tools</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Tool</th><th>Symbolic</th><th>Verification</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Mathematica + xAct</td><td>‚úì‚úì‚úì</td><td>‚úó</td><td>Industry standard, expensive</td></tr>
<tr><td>Cadabra</td><td>‚úì‚úì</td><td>‚úó</td><td>Open source tensor algebra</td></tr>
<tr><td>SageMath</td><td>‚úì‚úì</td><td>‚úó</td><td>General purpose</td></tr>
<tr><td><strong>Kleis</strong></td><td>‚úì‚úì</td><td>‚úì‚úì</td><td>Combines both!</td></tr>
</tbody>
</table>
</div>
<p>Kleis occupies a unique niche: <strong>symbolic mathematics with formal verification</strong>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
