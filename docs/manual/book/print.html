<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn You Some Kleis</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A fun, illustrated guide to the Kleis mathematical language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-bb6a65d2.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-1ed044a1.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn You Some Kleis</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/eatikrh/kleis" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="learn-you-some-kleis-for-great-good"><a class="header" href="#learn-you-some-kleis-for-great-good">Learn You Some Kleis for Great Good!</a></h1>
<blockquote>
<p><em>‚ÄúMathematics is the language with which God has written the universe.‚Äù</em> ‚Äî Galileo Galilei</p>
</blockquote>
<p>Welcome to <strong>Learn You Some Kleis</strong>, an illustrated guide to the Kleis mathematical language!</p>
<h2 id="what-is-kleis"><a class="header" href="#what-is-kleis">What is Kleis?</a></h2>
<p>Kleis is a <strong>mathematical expression language</strong> designed for:</p>
<ul>
<li>üìê <strong>Symbolic mathematics</strong> ‚Äî work with expressions, not just numbers</li>
<li>‚úÖ <strong>Formal verification</strong> ‚Äî prove properties with Z3 theorem prover</li>
<li>üèóÔ∏è <strong>Extensible structures</strong> ‚Äî define your own mathematical objects</li>
<li>üî¨ <strong>Scientific computing</strong> ‚Äî differential geometry, tensor calculus, and more</li>
</ul>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is This For?</a></h2>
<p>This guide is for anyone who:</p>
<ul>
<li>Wants to express mathematical ideas precisely</li>
<li>Is curious about formal verification</li>
<li>Enjoys functional programming (Haskell, ML, etc.)</li>
<li>Works with differential geometry or tensor calculus</li>
</ul>
<h2 id="how-to-read-this-guide"><a class="header" href="#how-to-read-this-guide">How to Read This Guide</a></h2>
<p>Each chapter builds on the previous ones. We start with the basics:</p>
<ol>
<li><strong>Types</strong> ‚Äî the foundation of everything</li>
<li><strong>Functions</strong> ‚Äî defining computations</li>
<li><strong>Structures</strong> ‚Äî building mathematical objects</li>
</ol>
<p>Then we explore advanced features:</p>
<ol start="4">
<li><strong>Pattern matching</strong> ‚Äî elegant case analysis</li>
<li><strong>Verification</strong> ‚Äî proving things with Z3</li>
<li><strong>Applications</strong> ‚Äî real-world examples</li>
</ol>
<h2 id="a-taste-of-kleis"><a class="header" href="#a-taste-of-kleis">A Taste of Kleis</a></h2>
<p>Here‚Äôs what Kleis looks like:</p>
<pre><code class="language-kleis">// Define a function
define square(x) = x * x

// With type annotation
define double(x : ‚Ñù) : ‚Ñù = x + x

// Create a structure
structure Vector(n : ‚Ñï) {
    axiom dimension : n ‚â• 1
    operation dot : Vector(n) ‚Üí ‚Ñù
}
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready? Let‚Äôs dive in!</p>
<p>‚Üí <a href="#starting-out">Start with Chapter 1: Starting Out</a></p>
<hr>
<p><em>This guide is inspired by <a href="https://learnyouahaskell.github.io/">Learn You a Haskell</a> and <a href="https://learnyousomeerlang.com/">Learn You Some Erlang</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starting-out"><a class="header" href="#starting-out">Starting Out</a></h1>
<h2 id="your-first-kleis-expression"><a class="header" href="#your-first-kleis-expression">Your First Kleis Expression</a></h2>
<p>The simplest things in Kleis are <strong>expressions</strong>. An expression is anything that has a value:</p>
<pre><code class="language-kleis">define answer = 42              // A number
define pi_approx = 3.14159      // A decimal
define sum(x, y) = x + y        // An arithmetic expression
define angle_sin(Œ∏) = sin(Œ∏)    // A function call
</code></pre>
<h2 id="the-repl"><a class="header" href="#the-repl">The REPL</a></h2>
<p>The easiest way to experiment with Kleis is the <strong>REPL</strong> (Read-Eval-Print Loop):</p>
<pre><code class="language-bash">$ cargo run --bin repl
üßÆ Kleis REPL v0.1.0
   Type :help for commands, :quit to exit

Œª&gt; 2 + 2
2 + 2

Œª&gt;  let x = 5 in x * x
times(5, 5)
</code></pre>
<h2 id="basic-arithmetic"><a class="header" href="#basic-arithmetic">Basic Arithmetic</a></h2>
<p>Kleis supports the usual arithmetic operations:</p>
<pre><code class="language-kleis">define add_example = 2 + 3       // Addition: 5
define sub_example = 10 - 4      // Subtraction: 6
define mul_example = 3 * 7       // Multiplication: 21
define div_example = 15 / 3      // Division: 5
define pow_example = 2 ^ 10      // Exponentiation: 1024
</code></pre>
<h2 id="variables-and-definitions"><a class="header" href="#variables-and-definitions">Variables and Definitions</a></h2>
<p>Use <code>define</code> to create named values:</p>
<pre><code class="language-kleis">define pi = 3.14159
define e = 2.71828
define golden_ratio = (1 + sqrt(5)) / 2
</code></pre>
<p>Functions are defined similarly:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define area_circle(r) = pi * r^2
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Kleis uses C-style comments:</p>
<pre><code class="language-kleis">// This is a single-line comment
define x = 42  // Inline comment

/* 
   Multi-line comments
   use slash-star syntax
*/
</code></pre>
<h2 id="unicode-support"><a class="header" href="#unicode-support">Unicode Support</a></h2>
<p>Kleis embraces mathematical notation with full Unicode support:</p>
<pre><code class="language-kleis example">// Greek letters
define Œ± = 0.5
define Œ≤ = 1.0
define Œ∏ = œÄ / 4

// Mathematical symbols in axioms
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x           // Universal quantifier
axiom positive_exists : ‚àÉ(y : ‚Ñù). y &gt; 0       // Existential quantifier
</code></pre>
<p>You can use ASCII alternatives too:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII Alternative</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Now that you can write basic expressions, let‚Äôs learn about the type system!</p>
<p>‚Üí <a href="#types-and-values">Next: Types and Values</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types-and-values"><a class="header" href="#types-and-values">Types and Values</a></h1>
<h2 id="why-types-matter"><a class="header" href="#why-types-matter">Why Types Matter</a></h2>
<p>Types are the foundation of Kleis. Every expression has a type, and the type system catches errors before they become problems.</p>
<pre><code class="language-kleis">define answer = 42                // 42 is an integer
define pi_val = 3.14              // 3.14 is a real number
define flag = True                // True is a boolean
</code></pre>
<h2 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h2>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>ASCII</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td>Natural</td><td><code>‚Ñï</code></td><td><code>Nat</code></td><td><code>N</code></td><td><code>0</code>, <code>42</code>, <code>100</code></td></tr>
<tr><td>Integer</td><td><code>‚Ñ§</code></td><td><code>Int</code></td><td><code>Z</code></td><td><code>-5</code>, <code>0</code>, <code>17</code></td></tr>
<tr><td>Rational</td><td><code>‚Ñö</code></td><td><code>Rational</code></td><td><code>Q</code></td><td><code>rational(1, 2)</code>, <code>rational(3, 4)</code></td></tr>
<tr><td>Real</td><td><code>‚Ñù</code></td><td><code>Real</code> or <code>Scalar</code></td><td><code>R</code></td><td><code>3.14</code>, <code>-2.5</code>, <code>‚àö2</code></td></tr>
<tr><td>Complex</td><td><code>‚ÑÇ</code></td><td><code>Complex</code></td><td><code>C</code></td><td><code>3 + 4i</code>, <code>i</code></td></tr>
</tbody>
</table>
</div>
<h3 id="other-basic-types"><a class="header" href="#other-basic-types">Other Basic Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td>Boolean</td><td><code>ùîπ</code></td><td><code>Bool</code></td><td><code>True</code>, <code>False</code></td></tr>
<tr><td>String</td><td>‚Äî</td><td><code>String</code></td><td><code>"hello"</code>, <code>"world"</code></td></tr>
<tr><td>Unit</td><td>‚Äî</td><td><code>Unit</code></td><td><code>()</code></td></tr>
</tbody>
</table>
</div>
<h3 id="parameterized-primitive-types"><a class="header" href="#parameterized-primitive-types">Parameterized Primitive Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Bit-Vector</td><td><code>BitVec(n)</code></td><td>n-bit binary vector (e.g., <code>BitVec(8)</code>, <code>BitVec(32)</code>)</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Boolean values
define flag = True
define not_flag = False

// Boolean in quantified expressions (inside structures)
structure BoolExamples {
    axiom reflexive_unicode : ‚àÄ(p : ùîπ). p = p
    axiom reflexive_full    : ‚àÄ(q : Bool). q = q
}
</code></pre>
<h3 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h3>
<p>The <code>Unit</code> type represents ‚Äúno meaningful value‚Äù ‚Äî like <code>void</code> in C or <code>()</code> in Rust/Haskell. It has exactly one value: <code>()</code>.</p>
<p><strong>When to use Unit:</strong></p>
<ol>
<li><strong>Result types that can fail but return nothing on success:</strong></li>
</ol>
<pre><code class="language-kleis">// A validation that succeeds with () or fails with an error message
data ValidationResult = Ok(Unit) | Err(String)

define validate_positive(x : ‚Ñù) : ValidationResult =
    if x &gt; 0 then Ok(()) else Err("must be positive")
</code></pre>
<ol start="2">
<li><strong>Optional values where presence matters, not content:</strong></li>
</ol>
<pre><code class="language-kleis">// Option type - Some(value) or None
data Option(T) = Some(T) | None

// A flag that's either set or not (no associated value)
define flag_set : Option(Unit) = Some(())
define flag_unset : Option(Unit) = None
</code></pre>
<ol start="3">
<li><strong>Proof terms with no computational content:</strong></li>
</ol>
<pre><code class="language-kleis">// A theorem that x = x (the proof itself carries no data)
structure Reflexivity {
    axiom refl : ‚àÄ(x : ‚Ñù). x = x
}
// The "witness" of this axiom would have type Unit
</code></pre>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>You can explicitly annotate types with <code>:</code>:</p>
<pre><code class="language-kleis">// Variable annotation
define typed_let = let x : ‚Ñù = 3.14 in x * 2

// Function parameter and return types
define f(x : ‚Ñù) : ‚Ñù = x * x

// Expression-level annotation (ascription)
define sum_typed(a, b) = (a + b) : ‚Ñù
</code></pre>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Functions have types too! The notation <code>A ‚Üí B</code> means ‚Äúa function from A to B‚Äù:</p>
<pre><code class="language-kleis">// square takes a Real and returns a Real
define square(x : ‚Ñù) : ‚Ñù = x * x
// Type: ‚Ñù ‚Üí ‚Ñù

// add takes two Reals and returns a Real
define add(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = x + y
// Type: ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù (or equivalently: ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù)
</code></pre>
<h3 id="higher-order-function-types"><a class="header" href="#higher-order-function-types">Higher-Order Function Types</a></h3>
<p>Functions can take other functions as arguments or return functions. These are called <strong>higher-order functions</strong>:</p>
<pre><code class="language-kleis">// A function that takes a function as an argument
define apply_twice(f : ‚Ñù ‚Üí ‚Ñù, x : ‚Ñù) : ‚Ñù = f(f(x))
// Type: (‚Ñù ‚Üí ‚Ñù) √ó ‚Ñù ‚Üí ‚Ñù

// A function that returns a function
define make_adder(n : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù = ???
// Type: ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)
</code></pre>
<p>The parentheses matter! Compare:</p>
<ul>
<li><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code> ‚Äî takes a function, returns a number</li>
<li><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code> ‚Äî takes a number, returns a function</li>
<li><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code> ‚Äî curried function (associates right: <code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code>)</li>
</ul>
<h3 id="function-type-examples"><a class="header" href="#function-type-examples">Function Type Examples</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ñù ‚Üí ‚Ñù</code></td><td>Function from real to real</td></tr>
<tr><td><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code></td><td>Curried binary function</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code></td><td>Takes a function, returns a value (e.g., definite integral)</td></tr>
<tr><td><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Returns a function (function factory)</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Function transformer (e.g., derivative operator)</td></tr>
</tbody>
</table>
</div>
<h2 id="parametric-types"><a class="header" href="#parametric-types">Parametric Types</a></h2>
<p>Types can have parameters:</p>
<pre><code class="language-kleis">// Parametric type examples:
List(‚Ñ§)           // List of integers
Matrix(3, 3, ‚Ñù)   // 3√ó3 matrix of reals
Vector(4)         // 4-dimensional vector
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Kleis often infers types automatically:</p>
<pre><code class="language-kleis">define double(x) = x + x
// Kleis infers: double : ‚Ñù ‚Üí ‚Ñù (or more general)

define square_five = let y = 5 in y * y
// Kleis infers: y : ‚Ñ§
</code></pre>
<p>But explicit types make code clearer and catch errors earlier!</p>
<h2 id="the-type-hierarchy"><a class="header" href="#the-type-hierarchy">The Type Hierarchy</a></h2>
<pre><code>              Any
         /    |    \
     Scalar  String  Collection
     /    \              |
    ‚ÑÇ    Bool          List
    |                 /    \
    ‚Ñù            Vector   Matrix
    |
    ‚Ñö
    |
    ‚Ñ§
    |
    ‚Ñï
</code></pre>
<p>Note: <code>‚Ñï ‚äÇ ‚Ñ§ ‚äÇ ‚Ñö ‚äÇ ‚Ñù ‚äÇ ‚ÑÇ</code> (naturals ‚äÇ integers ‚äÇ rationals ‚äÇ reals ‚äÇ complex)</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What‚Äôs Next?</a></h2>
<p>Types are the foundation. Now let‚Äôs see how to define functions!</p>
<p>‚Üí <a href="#functions">Next: Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>Functions are defined with <code>define</code>:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define add(x, y) = x + y
</code></pre>
<h2 id="functions-with-type-annotations"><a class="header" href="#functions-with-type-annotations">Functions with Type Annotations</a></h2>
<p>For clarity and safety, add type annotations:</p>
<pre><code class="language-kleis">define square(x : ‚Ñù) : ‚Ñù = x * x

define distance(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = sqrt(x^2 + y^2)

define normalize(v : Vector(3)) : Vector(3) = v / magnitude(v)
</code></pre>
<h2 id="multi-parameter-functions"><a class="header" href="#multi-parameter-functions">Multi-Parameter Functions</a></h2>
<p>Functions can take multiple parameters:</p>
<pre><code class="language-kleis">define add(x, y) = x + y
define volume_box(l, w, h) = l * w * h
define dot_product(a, b, c, x, y, z) = a*x + b*y + c*z
</code></pre>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Functions can call themselves:</p>
<pre><code class="language-kleis">define factorial(n : ‚Ñï) : ‚Ñï =
    if n = 0 then 1
    else n * factorial(n - 1)

define fibonacci(n : ‚Ñï) : ‚Ñï =
    if n ‚â§ 1 then n
    else fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<h2 id="built-in-mathematical-functions"><a class="header" href="#built-in-mathematical-functions">Built-in Mathematical Functions</a></h2>
<p>Kleis includes standard mathematical functions:</p>
<h3 id="trigonometric"><a class="header" href="#trigonometric">Trigonometric</a></h3>
<pre><code class="language-kleis">sin(x)      cos(x)      tan(x)
asin(x)     acos(x)     atan(x)
sinh(x)     cosh(x)     tanh(x)
</code></pre>
<h3 id="exponential-and-logarithmic"><a class="header" href="#exponential-and-logarithmic">Exponential and Logarithmic</a></h3>
<pre><code class="language-kleis">exp(x)      // e^x
ln(x)       // natural log
log(x)      // base-10 log
log(b, x)   // log base b of x
</code></pre>
<h3 id="other"><a class="header" href="#other">Other</a></h3>
<pre><code class="language-kleis">sqrt(x)     // square root
abs(x)      // absolute value
floor(x)    // round down
ceil(x)     // round up
min(x, y)   // minimum
max(x, y)   // maximum
</code></pre>
<h2 id="lambda-expressions-anonymous-functions"><a class="header" href="#lambda-expressions-anonymous-functions">Lambda Expressions (Anonymous Functions)</a></h2>
<p>Lambda expressions allow you to create anonymous functions inline:</p>
<pre><code class="language-kleis">define square_lambda = Œª x . x * x
define increment = lambda x . x + 1
define add_lambda = Œª x . Œª y . x + y
define square_typed = Œª (x : ‚Ñù) . x^2
define curried_add = Œª x . Œª y . x + y
</code></pre>
<p>Lambda expressions are first-class values - you can pass them to functions:</p>
<pre><code class="language-kleis">// Pass lambda to higher-order function
define doubled_list = map(Œª x . x * 2, [1, 2, 3])

// Or define inline
define result = apply(Œª x . x + 1, 5)
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Functions can take functions as arguments:</p>
<pre><code class="language-kleis">// Apply a function twice
define apply_twice(f, x) = f(f(x))

// Example usage:
define inc(x) = x + 1
define result = apply_twice(inc, 5)   // Result: 7
</code></pre>
<h2 id="partial-application-and-currying"><a class="header" href="#partial-application-and-currying">Partial Application and Currying</a></h2>
<p>With lambda expressions, you can create curried functions:</p>
<pre><code class="language-kleis">// Curried addition
define add = Œª x . Œª y . x + y

// Partial application creates specialized functions
define add5 = add(5)           // Œª y . 5 + y
define eight = add5(3)         // Result: 8
</code></pre>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What‚Äôs Next?</a></h2>
<p>Learn about algebraic data types for structured data!</p>
<p>‚Üí <a href="#algebraic-data-types">Next: Algebraic Types</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<h2 id="what-are-adts"><a class="header" href="#what-are-adts">What Are ADTs?</a></h2>
<p>Algebraic Data Types (ADTs) let you define custom data structures by combining simpler types. There are two main kinds:</p>
<ul>
<li><strong>Product types</strong> ‚Äî ‚Äúthis AND that‚Äù (records, tuples)</li>
<li><strong>Sum types</strong> ‚Äî ‚Äúthis OR that‚Äù (variants, enums)</li>
</ul>
<h2 id="product-types"><a class="header" href="#product-types">Product Types</a></h2>
<p>A product type combines multiple values:</p>
<pre><code class="language-kleis">// A point has an x AND a y
structure Point {
    x : ‚Ñù
    y : ‚Ñù
}

// A person has a name AND an age
structure Person {
    name : String
    age : ‚Ñï
}
</code></pre>
<h2 id="sum-types-variants"><a class="header" href="#sum-types-variants">Sum Types (Variants)</a></h2>
<p>A sum type represents alternatives:</p>
<pre><code class="language-kleis">// A shape is a Circle OR a Rectangle OR a Triangle
data Shape = Circle(radius : ‚Ñù) | Rectangle(width : ‚Ñù, height : ‚Ñù) | Triangle(a : ‚Ñù, b : ‚Ñù, c : ‚Ñù)

// An optional value is Some(value) OR None
data Option(T) = Some(value : T) | None

// A result is Ok(value) OR Err(message)
data Result(T, E) = Ok(value : T) | Err(error : E)
</code></pre>
<h2 id="pattern-matching-with-adts"><a class="header" href="#pattern-matching-with-adts">Pattern Matching with ADTs</a></h2>
<p>ADTs shine with pattern matching:</p>
<pre><code class="language-kleis">define area(shape) =
    match shape {
        Circle(r) =&gt; œÄ * r^2
        Rectangle(w, h) =&gt; w * h
        Triangle(a, b, c) =&gt; 
            let s = (a + b + c) / 2 in
            sqrt(s * (s-a) * (s-b) * (s-c))
    }
</code></pre>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<p>Types can refer to themselves:</p>
<pre><code class="language-kleis">// A list is either empty (Nil) or a value followed by another list (Cons)
data List(T) {
    Nil
    Cons(head : T, tail : List(T))
}

// A binary tree
data Tree(T) {
    Leaf(value : T)
    Node(left : Tree(T), value : T, right : Tree(T))
}
</code></pre>
<h2 id="the-mathematical-perspective"><a class="header" href="#the-mathematical-perspective">The Mathematical Perspective</a></h2>
<p>Why ‚Äúalgebraic‚Äù?</p>
<ul>
<li><strong>Product types</strong> correspond to multiplication: <code>Point = ‚Ñù √ó ‚Ñù</code></li>
<li><strong>Sum types</strong> correspond to addition: <code>Option(T) = T + 1</code></li>
</ul>
<p>The number of possible values follows algebra:</p>
<ul>
<li><code>Bool</code> has 2 values</li>
<li><code>Bool √ó Bool</code> has 2 √ó 2 = 4 values</li>
<li><code>Bool + Bool</code> has 2 + 2 = 4 values</li>
</ul>
<h2 id="practical-example-expression-trees"><a class="header" href="#practical-example-expression-trees">Practical Example: Expression Trees</a></h2>
<p>ADTs are perfect for representing mathematical expressions:</p>
<pre><code class="language-kleis">data Expr = Const(value : ‚Ñù) 
          | Var(name : String) 
          | Add(left : Expr, right : Expr) 
          | Mul(left : Expr, right : Expr) 
          | Neg(inner : Expr)

define eval(expr, env) =
    match expr {
        Const(v) =&gt; v
        Var(name) =&gt; lookup(env, name)
        Add(l, r) =&gt; eval(l, env) + eval(r, env)
        Mul(l, r) =&gt; eval(l, env) * eval(r, env)
        Neg(e) =&gt; -eval(e, env)
    }
</code></pre>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What‚Äôs Next?</a></h2>
<p>Let‚Äôs dive deeper into pattern matching!</p>
<p>‚Üí <a href="#pattern-matching">Next: Pattern Matching</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="the-power-of-match"><a class="header" href="#the-power-of-match">The Power of Match</a></h2>
<p>Pattern matching is one of Kleis‚Äôs most powerful features. It lets you destructure data and handle different cases elegantly:</p>
<pre><code class="language-kleis">define describe(n) =
    match n {
        0 =&gt; 0
        1 =&gt; 1
        _ =&gt; 2
    }
</code></pre>
<h2 id="basic-patterns"><a class="header" href="#basic-patterns">Basic Patterns</a></h2>
<h3 id="literal-patterns"><a class="header" href="#literal-patterns">Literal Patterns</a></h3>
<p>Match exact values:</p>
<pre><code class="language-kleis">define describe_literal(x) =
    match x {
        0 =&gt; "zero"
        1 =&gt; "one"
        42 =&gt; "the answer"
        _ =&gt; "something else"
    }
</code></pre>
<h3 id="variable-patterns"><a class="header" href="#variable-patterns">Variable Patterns</a></h3>
<p>Bind matched values to names:</p>
<pre><code class="language-kleis">define sum_point(point) =
    match point {
        Point(x, y) =&gt; x + y
    }
</code></pre>
<h3 id="wildcard-pattern"><a class="header" href="#wildcard-pattern">Wildcard Pattern</a></h3>
<p>The underscore <code>_</code> matches anything:</p>
<pre><code class="language-kleis">define describe_pair(pair) =
    match pair {
        (_, 0) =&gt; "second is zero"
        (0, _) =&gt; "first is zero"
        _ =&gt; "neither is zero"
    }
</code></pre>
<h2 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h2>
<p>Patterns can be nested arbitrarily:</p>
<pre><code class="language-kleis">define sum_tree(tree) =
    match tree {
        Leaf(v) =&gt; v
        Node(Leaf(l), v, Leaf(r)) =&gt; l + v + r
        Node(left, v, right) =&gt; v + sum_tree(left) + sum_tree(right)
    }
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>Add conditions to patterns with <code>if</code>:</p>
<pre><code class="language-kleis">define sign(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        x if x &gt; 0 =&gt; "positive"
        _ =&gt; "zero"
    }
</code></pre>
<h2 id="as-patterns"><a class="header" href="#as-patterns">As-Patterns</a></h2>
<p>Bind the whole match while also destructuring:</p>
<pre><code class="language-kleis">define filter_head(list) =
    match list {
        Cons(h, t) as whole =&gt; 
            if h &gt; 10 then whole
            else t
        Nil =&gt; Nil
    }
</code></pre>
<h2 id="pattern-matching-in-let"><a class="header" href="#pattern-matching-in-let">Pattern Matching in Let</a></h2>
<p>Destructure directly in let bindings:</p>
<pre><code class="language-kleis">define distance_squared(origin) =
    let Point(x, y) = origin in x^2 + y^2

define sum_first_two(triple) =
    let (first, second, _) = triple in first + second
</code></pre>
<h2 id="pattern-matching-in-function-parameters"><a class="header" href="#pattern-matching-in-function-parameters">Pattern Matching in Function Parameters</a></h2>
<p>With lambda expressions now available, you can combine them with match:</p>
<pre><code class="language-kleis">// Pattern matching with lambdas
define fst = Œª pair . match pair { (a, _) =&gt; a }
define snd = Œª pair . match pair { (_, b) =&gt; b }
</code></pre>
<p><strong>Alternative workaround:</strong></p>
<pre><code class="language-kleis">define fst(pair) = 
    match pair {
        (a, _) =&gt; a
    }
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>Kleis checks that your patterns cover all cases:</p>
<pre><code class="language-kleis">// ‚ö†Ô∏è Warning: non-exhaustive patterns
define incomplete(opt) =
    match opt {
        Some(x) =&gt; x
    }

// ‚úì Complete
define complete(opt) =
    match opt {
        Some(x) =&gt; x
        None =&gt; 0
    }
</code></pre>
<h2 id="real-world-example-symbolic-differentiation"><a class="header" href="#real-world-example-symbolic-differentiation">Real-World Example: Symbolic Differentiation</a></h2>
<p>Pattern matching makes symbolic math elegant:</p>
<pre><code class="language-kleis">define diff(expr, var) =
    match expr {
        Const(_) =&gt; Const(0)
        
        Var(name) =&gt; 
            if name = var then Const(1)
            else Const(0)
        
        Add(f, g) =&gt; 
            Add(diff(f, var), diff(g, var))
        
        Mul(f, g) =&gt;
            Add(Mul(diff(f, var), g), 
                Mul(f, diff(g, var)))
        
        Neg(f) =&gt; 
            Neg(diff(f, var))
    }
</code></pre>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What‚Äôs Next?</a></h2>
<p>Learn about let bindings for local definitions!</p>
<p>‚Üí <a href="#let-bindings">Next: Let Bindings</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="let-bindings"><a class="header" href="#let-bindings">Let Bindings</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Let bindings introduce local variables with limited scope. They‚Äôre essential for breaking complex expressions into readable parts.</p>
<pre><code class="language-kleis">define square_five = let x = 5 in x * x
// Result: 25
</code></pre>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-kleis">let &lt;name&gt; = &lt;value&gt; in &lt;body&gt;
</code></pre>
<p>The variable <code>name</code> is only visible within <code>body</code>:</p>
<pre><code class="language-kleis">define circle_area = let radius = 10 in œÄ * radius^2
// Result: 314.159...
// 'radius' is not visible outside the let binding
</code></pre>
<h2 id="with-type-annotations"><a class="header" href="#with-type-annotations">With Type Annotations</a></h2>
<p>Add explicit types for clarity:</p>
<pre><code class="language-kleis">define typed_example1 = let x : ‚Ñù = 3.14 in x * 2
define typed_example2 = let n : ‚Ñï = 42 in factorial(n)
define typed_example3 = let v : Vector(3) = [1, 2, 3] in magnitude(v)
</code></pre>
<h2 id="nested-let-bindings"><a class="header" href="#nested-let-bindings">Nested Let Bindings</a></h2>
<p>Chain multiple bindings:</p>
<pre><code class="language-kleis">define nested_example =
    let x = 5 in
    let y = 3 in
    let z = x + y in
        x * y * z
// Result: 5 * 3 * 8 = 120
</code></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Inner bindings can shadow outer ones:</p>
<pre><code class="language-kleis">define shadowing_example =
    let x = 1 in
    let x = x + 1 in
    let x = x * 2 in
        x
// Result: 4  (not 1!)
</code></pre>
<p>Each <code>let</code> creates a new scope where <code>x</code> is rebound.</p>
<h2 id="pure-substitution-semantics"><a class="header" href="#pure-substitution-semantics">Pure Substitution Semantics</a></h2>
<p>In Kleis, <code>let x = e in body</code> is equivalent to substituting <code>e</code> for <code>x</code> in <code>body</code>:</p>
<pre><code class="language-kleis">define substitution_demo = let x = 5 in x + x
// is the same as:
define substitution_result = 5 + 5
</code></pre>
<p>This is <strong>pure functional semantics</strong> ‚Äî no mutation, no side effects.</p>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="quadratic-formula"><a class="header" href="#quadratic-formula">Quadratic Formula</a></h3>
<pre><code class="language-kleis">define quadratic_roots(a, b, c) =
    let discriminant = b^2 - 4*a*c in
    let sqrt_d = sqrt(discriminant) in
    let denom = 2 * a in
        ((-b + sqrt_d) / denom, (-b - sqrt_d) / denom)
</code></pre>
<h3 id="herons-formula"><a class="header" href="#herons-formula">Heron‚Äôs Formula</a></h3>
<pre><code class="language-kleis">define triangle_area(a, b, c) =
    let s = (a + b + c) / 2 in
        sqrt(s * (s - a) * (s - b) * (s - c))
</code></pre>
<h3 id="complex-calculations"><a class="header" href="#complex-calculations">Complex Calculations</a></h3>
<pre><code class="language-kleis">define schwarzschild_metric(r, M) =
    let rs = 2 * G * M / c^2 in
    let factor = 1 - rs / r in
        -c^2 * factor
</code></pre>
<h2 id="let-vs-define"><a class="header" href="#let-vs-define">Let vs Define</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>define</code></th><th><code>let ... in</code></th></tr>
</thead>
<tbody>
<tr><td>Top-level, global</td><td>Local scope only</td></tr>
<tr><td>Named function/constant</td><td>Temporary binding</td></tr>
<tr><td>Visible everywhere</td><td>Visible only in body</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Global constant
define pi = 3.14159

// Local temporary in a function
define circumference(radius) = let two_pi = 2 * pi in two_pi * radius
</code></pre>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What‚Äôs Next?</a></h2>
<p>Learn about quantifiers and logic!</p>
<p>‚Üí <a href="#quantifiers-and-logic">Next: Quantifiers and Logic</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quantifiers-and-logic"><a class="header" href="#quantifiers-and-logic">Quantifiers and Logic</a></h1>
<h2 id="universal-quantifier-"><a class="header" href="#universal-quantifier-">Universal Quantifier (‚àÄ)</a></h2>
<p>The universal quantifier expresses ‚Äúfor all‚Äù:</p>
<pre><code class="language-kleis example">// Quantified propositions (used inside axioms)
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x
axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
axiom commutative : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
</code></pre>
<p>ASCII alternative: <code>forall x . ...</code></p>
<h2 id="existential-quantifier-"><a class="header" href="#existential-quantifier-">Existential Quantifier (‚àÉ)</a></h2>
<p>The existential quantifier expresses ‚Äúthere exists‚Äù:</p>
<pre><code class="language-kleis example">// Existential quantifiers
axiom positive_exists : ‚àÉ(x : ‚Ñù). x &gt; 0
axiom sqrt2_exists : ‚àÉ(y : ‚Ñù). y * y = 2
axiom distinct_exists : ‚àÉ(x : ‚Ñù)(y : ‚Ñù). x ‚â† y
</code></pre>
<p>ASCII alternative: <code>exists x . ...</code></p>
<h2 id="combining-quantifiers"><a class="header" href="#combining-quantifiers">Combining Quantifiers</a></h2>
<p>Build complex statements:</p>
<pre><code class="language-kleis example">// Every number has a successor
axiom successor : ‚àÄ(n : ‚Ñï). ‚àÉ(m : ‚Ñï). m = n + 1

// Density of rationals: between any two reals is a rational
axiom density : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x &lt; y ‚Üí ‚àÉ(q : ‚Ñö). x &lt; q ‚àß q &lt; y
</code></pre>
<h2 id="logical-connectives"><a class="header" href="#logical-connectives">Logical Connectives</a></h2>
<h3 id="conjunction---and"><a class="header" href="#conjunction---and">Conjunction (‚àß / and)</a></h3>
<pre><code class="language-kleis">define in_range(x) = x &gt; 0 ‚àß x &lt; 10     // x is between 0 and 10
define false_example = True ‚àß False     // False
</code></pre>
<h3 id="disjunction---or"><a class="header" href="#disjunction---or">Disjunction (‚à® / or)</a></h3>
<pre><code class="language-kleis">define is_binary(x) = x = 0 ‚à® x = 1    // x is 0 or 1
define true_example = True ‚à® False     // True
</code></pre>
<h3 id="implication---implies"><a class="header" href="#implication---implies">Implication (‚Üí / implies)</a></h3>
<pre><code class="language-kleis">define positive_square(x) = x &gt; 0 ‚Üí x * x &gt; 0   // If positive, square is positive
define implication(P, Q) = P ‚Üí Q                // If P then Q
</code></pre>
<h3 id="negation---not"><a class="header" href="#negation---not">Negation (¬¨ / not)</a></h3>
<pre><code class="language-kleis">define nonzero(x) = ¬¨(x = 0)     // x is not zero
define not_true = ¬¨True          // False
</code></pre>
<h3 id="biconditional---iff"><a class="header" href="#biconditional---iff">Biconditional (‚Üî / iff)</a></h3>
<pre><code class="language-kleis">define zero_iff_square_zero(x) = x = 0 ‚Üî x * x = 0  // x is zero iff x¬≤ is zero
</code></pre>
<h2 id="type-constraints-in-quantifiers"><a class="header" href="#type-constraints-in-quantifiers">Type Constraints in Quantifiers</a></h2>
<p>Restrict the domain:</p>
<pre><code class="language-kleis example">axiom naturals_nonneg : ‚àÄ(x : ‚Ñï). x ‚â• 0
axiom det_inverse : ‚àÄ(M : Matrix(n, n)). det(M * M‚Åª¬π) = 1
</code></pre>
<h2 id="using-quantifiers-in-axioms"><a class="header" href="#using-quantifiers-in-axioms">Using Quantifiers in Axioms</a></h2>
<p>Quantifiers are essential in structure axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G                      // Identity element
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x ‚àß mul(x, e) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h2 id="nested-quantifiers-grammar-v09"><a class="header" href="#nested-quantifiers-grammar-v09">Nested Quantifiers (Grammar v0.9)</a></h2>
<p>Quantifiers can appear inside logical expressions:</p>
<pre><code class="language-kleis">structure Analysis {
    // Quantifier inside conjunction
    axiom bounded_positive: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). abs(y) &lt;= x)
    
    // Quantifier inside implication
    axiom dense_rationals: ‚àÄ(a b : ‚Ñù). a &lt; b ‚Üí (‚àÉ(q : ‚Ñö). a &lt; q ‚àß q &lt; b)
    
    // Deeply nested quantifiers
    axiom limit_def: ‚àÄ(L : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
}
</code></pre>
<h3 id="epsilon-delta-limit-definition"><a class="header" href="#epsilon-delta-limit-definition">Epsilon-Delta Limit Definition</a></h3>
<p>The classic analysis definition now parses correctly:</p>
<pre><code class="language-kleis">structure Limits {
    axiom epsilon_delta: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, L a : ‚Ñù). 
        has_limit(f, a, L) ‚Üî 
        (‚àÄ(Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß 
            (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ)))
}
</code></pre>
<h2 id="function-types-in-quantifiers-grammar-v09"><a class="header" href="#function-types-in-quantifiers-grammar-v09">Function Types in Quantifiers (Grammar v0.9)</a></h2>
<p>Quantify over functions using the arrow type:</p>
<pre><code class="language-kleis">structure FunctionProperties {
    // Quantify over a function ‚Ñù ‚Üí ‚Ñù
    axiom continuous: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, x : ‚Ñù). 
        is_continuous(f, x)
    
    // Quantify over multiple functions
    axiom composition: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, g : ‚Ñù ‚Üí ‚Ñù). 
        compose(f, g) = Œª x . f(g(x))
    
    // Higher-order function types
    axiom curried: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù, a b : ‚Ñù). 
        f = f
}
</code></pre>
<h3 id="topology-with-function-types"><a class="header" href="#topology-with-function-types">Topology with Function Types</a></h3>
<pre><code class="language-kleis">structure Topology {
    axiom continuity: ‚àÄ(f : X ‚Üí Y, V : Set(Y)). 
        is_open(V) ‚Üí is_open(preimage(f, V))
    
    axiom homeomorphism: ‚àÄ(f : X ‚Üí Y, g : Y ‚Üí X). 
        (‚àÄ(x : X). g(f(x)) = x) ‚àß (‚àÄ(y : Y). f(g(y)) = y) ‚Üí 
        bijective(f)
}
</code></pre>
<h2 id="verification-with-z3"><a class="header" href="#verification-with-z3">Verification with Z3</a></h2>
<p>Kleis uses Z3 to check quantified statements:</p>
<pre><code class="language-kleis example">// Z3 can verify this is always true:
axiom add_zero : ‚àÄ(x : ‚Ñù). x + 0 = x

// Z3 can find a counterexample for this:
axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="truth-tables"><a class="header" href="#truth-tables">Truth Tables</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>P</th><th>Q</th><th>P ‚àß Q</th><th>P ‚à® Q</th><th>P ‚Üí Q</th><th>¬¨P</th></tr>
</thead>
<tbody>
<tr><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr>
<tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What‚Äôs Next?</a></h2>
<p>Learn about conditional expressions!</p>
<p>‚Üí <a href="#conditionals">Next: Conditionals</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<h2 id="if-then-else"><a class="header" href="#if-then-else">If-Then-Else</a></h2>
<p>The basic conditional expression:</p>
<pre><code class="language-kleis">if condition then value1 else value2
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">define positive_check(x) = if x &gt; 0 then "positive" else "non-positive"

define factorial(n) = if n = 0 then 1 else n * factorial(n - 1)

define abs(x) = if x ‚â• 0 then x else -x
</code></pre>
<h2 id="conditionals-are-expressions"><a class="header" href="#conditionals-are-expressions">Conditionals Are Expressions</a></h2>
<p>In Kleis, <code>if-then-else</code> is an expression that returns a value:</p>
<pre><code class="language-kleis">define doubled_abs(x) =
    let result = if x &gt; 0 then x else -x in
    result * 2

// Both branches must have compatible types!
// if True then 42 else "hello"  // ‚ùå Type error!
</code></pre>
<h2 id="nested-conditionals"><a class="header" href="#nested-conditionals">Nested Conditionals</a></h2>
<pre><code class="language-kleis">define sign(x) =
    if x &gt; 0 then 1
    else if x &lt; 0 then -1
    else 0

define grade(score) =
    if score ‚â• 90 then "A"
    else if score ‚â• 80 then "B"
    else if score ‚â• 70 then "C"
    else if score ‚â• 60 then "D"
    else "F"
</code></pre>
<h2 id="guards-vs-if-then-else"><a class="header" href="#guards-vs-if-then-else">Guards vs If-Then-Else</a></h2>
<p>Pattern matching with guards is often cleaner:</p>
<pre><code class="language-kleis">// With if-then-else
define classify_if(n) =
    if n &lt; 0 then "negative"
    else if n = 0 then "zero"
    else "positive"

// With pattern matching and guards
define classify_match(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        0 =&gt; "zero"
        _ =&gt; "positive"
    }
</code></pre>
<h2 id="piecewise-functions"><a class="header" href="#piecewise-functions">Piecewise Functions</a></h2>
<p>Mathematicians love piecewise definitions:</p>
<pre><code class="language-kleis">// Absolute value
define abs_fn(x) =
    if x ‚â• 0 then x else -x

// Heaviside step function
define heaviside(x) =
    if x &lt; 0 then 0
    else if x = 0 then 0.5
    else 1

// Piecewise polynomial
define piecewise_f(x) =
    if x &lt; 0 then x^2
    else if x &lt; 1 then x
    else 2 - x
</code></pre>
<h2 id="boolean-expressions"><a class="header" href="#boolean-expressions">Boolean Expressions</a></h2>
<p>Conditions can be complex:</p>
<pre><code class="language-kleis">define quadrant(x, y) =
    if x &gt; 0 ‚àß y &gt; 0 then "first quadrant"
    else if x &lt; 0 ‚àß y &gt; 0 then "second quadrant"
    else if x &lt; 0 ‚àß y &lt; 0 then "third quadrant"
    else if x &gt; 0 ‚àß y &lt; 0 then "fourth quadrant"
    else "on an axis"
</code></pre>
<h2 id="short-circuit-evaluation"><a class="header" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></h2>
<p>Kleis uses short-circuit evaluation for <code>‚àß</code> and <code>‚à®</code>:</p>
<pre><code class="language-kleis">// If x = 0, division is never evaluated
define check_ratio(x, y) =
    if x ‚â† 0 ‚àß y/x &gt; 1 then "big ratio" else "safe"
</code></pre>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What‚Äôs Next?</a></h2>
<p>Learn about structures for defining mathematical objects!</p>
<p>‚Üí <a href="#structures">Next: Structures</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<h2 id="what-are-structures"><a class="header" href="#what-are-structures">What Are Structures?</a></h2>
<p>Structures define mathematical objects with their properties and operations. Think of them as ‚Äúblueprints‚Äù for mathematical concepts.</p>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï) {
    // Operations this structure supports
    operation add : Vector(n) ‚Üí Vector(n)
    operation scale : ‚Ñù ‚Üí Vector(n)
    operation dot : Vector(n) ‚Üí ‚Ñù
    
    // Properties that must hold
    axiom commutative : ‚àÄ(u : Vector(n))(v : Vector(n)).
        add(u, v) = add(v, u)
}
</code></pre>
<h2 id="structure-syntax"><a class="header" href="#structure-syntax">Structure Syntax</a></h2>
<pre><code class="language-kleis">structure Name(parameters) {
    // Fields (data) - no "field" keyword needed
    field1 : Type1
    field2 : Type2
    
    // Operations (functions)
    operation op1 : InputType ‚Üí OutputType
    
    // Axioms (properties)
    axiom property : logical_statement
}
</code></pre>
<h2 id="example-complex-numbers"><a class="header" href="#example-complex-numbers">Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">structure Complex {
    re : ‚Ñù  // real part
    im : ‚Ñù  // imaginary part
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex           // conjugate
    operation mag : ‚Ñù                  // magnitude
    
    axiom add_commutative : ‚àÄ(z : Complex)(w : Complex).
        add(z, w) = add(w, z)
        
    axiom magnitude_positive : ‚àÄ(z : Complex).
        mag(z) ‚â• 0
        
    axiom conj_involution : ‚àÄ(z : Complex).
        conj(conj(z)) = z
}
</code></pre>
<h2 id="parametric-structures"><a class="header" href="#parametric-structures">Parametric Structures</a></h2>
<p>Structures can have type parameters:</p>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    
    axiom transpose_involution : ‚àÄ(A : Matrix(m, n, T)).
        transpose(transpose(A)) = A
}

// Square matrices have more operations
structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    
    axiom det_mul : ‚àÄ(A : SquareMatrix(n, T))(B : SquareMatrix(n, T)).
        det(mul(A, B)) = det(A) * det(B)
}
</code></pre>
<h2 id="nested-structures"><a class="header" href="#nested-structures">Nested Structures</a></h2>
<p>Structures can contain other structures. This enables compositional algebra ‚Äî defining complex structures from simpler parts:</p>
<pre><code class="language-kleis">structure Ring(R) {
    // A ring has an additive group
    structure additive : AbelianGroup(R) {
        operation add : R √ó R ‚Üí R
        operation negate : R ‚Üí R
        zero : R
    }
    
    // And a multiplicative monoid
    structure multiplicative : Monoid(R) {
        operation mul : R √ó R ‚Üí R
        one : R
    }
    
    // With distributivity connecting them
    axiom distributive : ‚àÄ(x : R)(y : R)(z : R).
        mul(x, add(y, z)) = add(mul(x, y), mul(x, z))
}
</code></pre>
<p>Nested structures can go arbitrarily deep:</p>
<pre><code class="language-kleis">structure VectorSpace(V, F) {
    structure vectors : AbelianGroup(V) {
        operation add : V √ó V ‚Üí V
        zero : V
    }
    
    structure scalars : Field(F) {
        operation add : F √ó F ‚Üí F
        operation mul : F √ó F ‚Üí F
    }
    
    operation scale : F √ó V ‚Üí V
}
</code></pre>
<p>When using Z3 verification, axioms from nested structures are automatically available.</p>
<h2 id="the-extends-keyword"><a class="header" href="#the-extends-keyword">The <code>extends</code> Keyword</a></h2>
<p>Structures can extend other structures:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
    
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e ‚àß mul(inv(x), x) = e
}

structure AbelianGroup(G) extends Group(G) {
    axiom commutative : ‚àÄ(x : G)(y : G). mul(x, y) = mul(y, x)
}
</code></pre>
<h2 id="the-over-keyword"><a class="header" href="#the-over-keyword">The <code>over</code> Keyword</a></h2>
<p>Many mathematical structures are defined ‚Äúover‚Äù a base structure. A vector space is defined over a field, a module over a ring:</p>
<pre><code class="language-kleis">// Vector space over a field
structure VectorSpace(V) over Field(F) {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    
    axiom scalar_identity : ‚àÄ(v : V). scale(1, v) = v
    axiom distributive : ‚àÄ(a : F)(u : V)(v : V).
        scale(a, add(u, v)) = add(scale(a, u), scale(a, v))
}

// Module over a ring (generalization of vector space)
structure Module(M) over Ring(R) {
    operation add : M √ó M ‚Üí M
    operation scale : R √ó M ‚Üí M
}

// Algebra over a ring
structure Algebra(A) over Ring(R) {
    operation add : A √ó A ‚Üí A
    operation scale : R √ó A ‚Üí A
    operation mul : A √ó A ‚Üí A
    
    axiom bilinear : ‚àÄ(r : R)(a : A)(b : A).
        scale(r, mul(a, b)) = mul(scale(r, a), b)
}
</code></pre>
<p>When you use <code>over</code>, Kleis automatically makes the base structure‚Äôs axioms available for verification. For example, when verifying <code>VectorSpace</code> axioms, Z3 knows that <code>F</code> satisfies all <code>Field</code> axioms.</p>
<h2 id="differential-geometry-structures"><a class="header" href="#differential-geometry-structures">Differential Geometry Structures</a></h2>
<p>Kleis shines for differential geometry:</p>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(M)
    operation metric : M ‚Üí Tensor(0, 2)
    
    axiom metric_symmetric : ‚àÄ(p : M).
        metric(p) = transpose(metric(p))
}

structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Tensor(0, 2)
    operation scalar_curvature : M ‚Üí ‚Ñù
    
    // R^a_{bcd} + R^a_{cdb} + R^a_{dbc} = 0
    axiom first_bianchi : ‚àÄ(p : M).
        cyclic_sum(riemann(p)) = 0
}
</code></pre>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What‚Äôs Next?</a></h2>
<p>Learn how to implement structures!</p>
<p>‚Üí <a href="#implements">Next: Implements</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implements"><a class="header" href="#implements">Implements</a></h1>
<h2 id="from-structure-to-implementation"><a class="header" href="#from-structure-to-implementation">From Structure to Implementation</a></h2>
<p>A <code>structure</code> declares what operations exist. An <code>implements</code> block provides the actual definitions:</p>
<pre><code class="language-kleis">structure Addable(T) {
    operation add : T √ó T ‚Üí T
}

implements Addable(‚Ñù) {
    operation add(x, y) = x + y
}

implements Addable(‚Ñ§) {
    operation add(x, y) = x + y
}
</code></pre>
<h2 id="full-example-complex-numbers"><a class="header" href="#full-example-complex-numbers">Full Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">// Declare the structure
structure Complex {
    re : ‚Ñù
    im : ‚Ñù
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex
    operation mag : ‚Ñù
}

// Implement the operations
implements Complex {
    operation add(z, w) = builtin_complex_add
    operation mul(z, w) = builtin_complex_mul
    operation conj(z) = builtin_complex_conj
    operation mag(z) = sqrt(z.re^2 + z.im^2)
}
</code></pre>
<h2 id="parametric-implementations"><a class="header" href="#parametric-implementations">Parametric Implementations</a></h2>
<p>Implement structures with type parameters:</p>
<pre><code class="language-kleis">structure Stack(T) {
    operation push : T ‚Üí Stack(T)
    operation pop : Stack(T)
    operation top : T
    operation empty : Bool
}

implements Stack(‚Ñ§) {
    operation push = builtin_stack_push
    operation pop = builtin_stack_pop
    operation top = builtin_stack_top
    operation empty = builtin_stack_empty
}
</code></pre>
<h2 id="multiple-implementations"><a class="header" href="#multiple-implementations">Multiple Implementations</a></h2>
<p>The same structure can have multiple implementations:</p>
<pre><code class="language-kleis">structure Orderable(T) {
    operation compare : T √ó T ‚Üí Ordering
}

// Natural ordering
implements Orderable(‚Ñ§) {
    operation compare = builtin_int_compare
}
</code></pre>
<h2 id="implementing-extended-structures"><a class="header" href="#implementing-extended-structures">Implementing Extended Structures</a></h2>
<p>When a structure extends another, implement all operations:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    operation e : M
    operation mul : M √ó M ‚Üí M
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
}

// Must implement both Monoid and Group operations
implements Group(‚Ñ§) {
    operation e = 0
    operation mul(x, y) = x + y
    operation inv(x) = -x
}
</code></pre>
<h2 id="builtin-operations"><a class="header" href="#builtin-operations">Builtin Operations</a></h2>
<p>Some operations can‚Äôt be defined in pure Kleis ‚Äî they need native code. The <code>builtin_</code> prefix connects Kleis to underlying implementations:</p>
<pre><code class="language-kleis">implements Matrix(m, n, ‚Ñù) {
    operation transpose = builtin_transpose
    operation add = builtin_matrix_add
    operation mul = builtin_matrix_mul
}
</code></pre>
<h3 id="how-builtins-work"><a class="header" href="#how-builtins-work">How Builtins Work</a></h3>
<p>When Kleis sees <code>builtin_foo</code>, it:</p>
<ol>
<li>Looks up <code>foo</code> in the native runtime</li>
<li>Calls the Rust/C/hardware implementation</li>
<li>Returns the result to Kleis</li>
</ol>
<p>This enables:</p>
<ul>
<li><strong>Performance</strong>: Native BLAS for matrix operations</li>
<li><strong>Hardware access</strong>: GPUs, network cards, sensors</li>
<li><strong>System calls</strong>: File I/O, networking, threading</li>
<li><strong>FFI</strong>: Calling existing libraries</li>
</ul>
<h3 id="the-vision-hardware-as-structures"><a class="header" href="#the-vision-hardware-as-structures">The Vision: Hardware as Structures</a></h3>
<p>Imagine:</p>
<pre><code class="language-kleis">structure NetworkInterface(N) {
    operation send : Packet ‚Üí Result(Unit, Error)
    operation receive : Unit ‚Üí Result(Packet, Error)
    
    axiom delivery : ‚àÄ(p : Packet).
        connected ‚Üí eventually(delivered(p))
}

implements NetworkInterface(EthernetCard) {
    operation send = builtin_eth_send
    operation receive = builtin_eth_receive
}
</code></pre>
<p>The <strong>axioms</strong> define the contract. The <strong>builtins</strong> provide the implementation. Z3 can verify that higher-level protocols satisfy their specifications <em>given</em> the hardware axioms.</p>
<p>This is how Kleis becomes a <strong>universal verification platform</strong> ‚Äî not just for math, but for any system with verifiable properties.</p>
<h2 id="verification-of-implementations"><a class="header" href="#verification-of-implementations">Verification of Implementations</a></h2>
<p>Kleis + Z3 can verify that implementations satisfy axioms:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

implements Monoid(String) {
    element e = ""
    operation mul = builtin_concat
}

// Kleis can verify:
// 1. concat("", s) = s for all s ‚úì
// 2. concat(s, "") = s for all s ‚úì
// 3. concat(concat(a, b), c) = concat(a, concat(b, c)) ‚úì
</code></pre>
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What‚Äôs Next?</a></h2>
<p>Learn about Z3 verification in depth!</p>
<p>‚Üí <a href="#z3-verification">Next: Z3 Verification</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="z3-verification"><a class="header" href="#z3-verification">Z3 Verification</a></h1>
<h2 id="what-is-z3"><a class="header" href="#what-is-z3">What is Z3?</a></h2>
<p><a href="https://github.com/Z3Prover/z3">Z3</a> is a theorem prover from Microsoft Research. Kleis uses Z3 to:</p>
<ul>
<li><strong>Verify</strong> mathematical statements</li>
<li><strong>Find counterexamples</strong> when statements are false</li>
<li><strong>Check</strong> that implementations satisfy axioms</li>
</ul>
<h2 id="basic-verification"><a class="header" href="#basic-verification">Basic Verification</a></h2>
<p>Use <code>verify</code> to check a statement:</p>
<pre><code class="language-kleis example">axiom commutativity : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
// Z3 verifies: ‚úì Valid

axiom zero_annihilates : ‚àÄ(x : ‚Ñù). x * 0 = 0
// Z3 verifies: ‚úì Valid

axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="verifying-quantified-statements"><a class="header" href="#verifying-quantified-statements">Verifying Quantified Statements</a></h2>
<p>Z3 handles universal and existential quantifiers:</p>
<pre><code class="language-kleis example">axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
// Z3 verifies: ‚úì Valid

axiom squares_nonnegative : ‚àÄ(x : ‚Ñù). x * x ‚â• 0
// Z3 verifies: ‚úì Valid (squares are non-negative)

axiom no_real_sqrt_neg1 : ‚àÉ(x : ‚Ñù). x * x = -1
// Z3: ‚úó Invalid (no real square root of -1)

axiom complex_sqrt_neg1 : ‚àÉ(x : ‚ÑÇ). x * x = -1
// Z3 verifies: ‚úì Valid (x = i works)
</code></pre>
<h2 id="checking-axioms"><a class="header" href="#checking-axioms">Checking Axioms</a></h2>
<p>Verify that definitions satisfy axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

// Define integers with addition
implements Group(‚Ñ§) {
    element e = 0
    operation mul = builtin_add
    operation inv = builtin_negate
}

// Kleis verifies each axiom automatically!
</code></pre>
<h2 id="implication-verification"><a class="header" href="#implication-verification">Implication Verification</a></h2>
<p>Prove that premises imply conclusions:</p>
<pre><code class="language-kleis example">// If x &gt; 0 and y &gt; 0, then x + y &gt; 0
axiom sum_positive : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). (x &gt; 0 ‚àß y &gt; 0) ‚Üí x + y &gt; 0
// Z3 verifies: ‚úì Valid

// Triangle inequality
axiom triangle_ineq : ‚àÄ(x : ‚Ñù)(y : ‚Ñù)(a : ‚Ñù)(b : ‚Ñù).
    (abs(x) ‚â§ a ‚àß abs(y) ‚â§ b) ‚Üí abs(x + y) ‚â§ a + b
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="counterexamples"><a class="header" href="#counterexamples">Counterexamples</a></h2>
<p>When verification fails, Z3 provides counterexamples:</p>
<pre><code class="language-kleis example">axiom square_equals_self : ‚àÄ(x : ‚Ñù). x^2 = x
// Z3: ‚úó Invalid, Counterexample: x = 2 (since 4 ‚â† 2)

axiom positive_greater_than_one : ‚àÄ(n : ‚Ñï). n &gt; 0 ‚Üí n &gt; 1
// Z3: ‚úó Invalid, Counterexample: n = 1
</code></pre>
<h2 id="timeout-and-limits"><a class="header" href="#timeout-and-limits">Timeout and Limits</a></h2>
<p>Complex statements may time out:</p>
<pre><code class="language-kleis">// Very complex statement
verify ‚àÄ M : Matrix(100, 100) . det(M * M') ‚â• 0
// Result: ‚è± Timeout (statement too complex)
</code></pre>
<h2 id="verifying-nested-quantifiers-grammar-v09"><a class="header" href="#verifying-nested-quantifiers-grammar-v09">Verifying Nested Quantifiers (Grammar v0.9)</a></h2>
<p>Grammar v0.9 enables nested quantifiers in logical expressions:</p>
<pre><code class="language-kleis">structure Analysis {
    // Quantifier inside conjunction - Z3 handles this
    axiom bounded: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). y = y)
    
    // Epsilon-delta limit definition
    axiom limit_def: ‚àÄ(L a : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
}
</code></pre>
<h3 id="function-types-in-verification"><a class="header" href="#function-types-in-verification">Function Types in Verification</a></h3>
<p>Quantify over functions and verify their properties:</p>
<pre><code class="language-kleis">structure Continuity {
    // Z3 treats f as an uninterpreted function ‚Ñù ‚Üí ‚Ñù
    axiom continuous_at: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, a : ‚Ñù, Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí
        (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - f(a)) &lt; Œµ))
}
</code></pre>
<p><strong>Note:</strong> Z3 treats function-typed variables as uninterpreted functions, allowing reasoning about their properties without knowing their implementation.</p>
<h2 id="what-z3-can-and-cannot-do"><a class="header" href="#what-z3-can-and-cannot-do">What Z3 Can and Cannot Do</a></h2>
<h3 id="z3-excels-at"><a class="header" href="#z3-excels-at">Z3 Excels At:</a></h3>
<ul>
<li>Linear arithmetic</li>
<li>Boolean logic</li>
<li>Array reasoning</li>
<li>Simple quantifiers</li>
<li>Algebraic identities</li>
<li>Nested quantifiers (Grammar v0.9)</li>
<li>Function-typed variables</li>
</ul>
<h3 id="z3-struggles-with"><a class="header" href="#z3-struggles-with">Z3 Struggles With:</a></h3>
<ul>
<li>Non-linear real arithmetic (undecidable in general)</li>
<li>Very deep quantifier nesting (may timeout)</li>
<li>Transcendental functions (sin, cos, exp)</li>
<li>Infinite structures</li>
<li>Inductive proofs over recursive data types</li>
</ul>
<h2 id="practical-workflow"><a class="header" href="#practical-workflow">Practical Workflow</a></h2>
<ol>
<li><strong>Write structure with axioms</strong></li>
<li><strong>Implement operations</strong></li>
<li><strong>Kleis auto-verifies</strong> axioms are satisfied</li>
<li><strong>Use <code>verify</code></strong> for additional properties</li>
<li><strong>Examine counterexamples</strong> when verification fails</li>
</ol>
<pre><code class="language-kleis">// Step 1: Define structure
structure Ring(R) {
    zero : R
    one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    axiom add_assoc : ‚àÄ(a : R)(b : R)(c : R).
        add(add(a, b), c) = add(a, add(b, c))
}

// Step 2: Implement for integers
implements Ring(‚Ñ§) {
    element zero = 0
    element one = 1
    operation add = builtin_add
    operation mul = builtin_mul
    operation neg = builtin_negate
}

// Step 3: Auto-verification happens!

// Step 4: Check additional properties
axiom mul_zero : ‚àÄ(x : ‚Ñ§). mul(x, zero) = zero
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What‚Äôs Next?</a></h2>
<p>Try the interactive REPL!</p>
<p>‚Üí <a href="#the-repl-1">Next: The REPL</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-repl-1"><a class="header" href="#the-repl-1">The REPL</a></h1>
<h2 id="what-is-the-repl"><a class="header" href="#what-is-the-repl">What is the REPL?</a></h2>
<p>The REPL (Read-Eval-Print Loop) is an interactive environment for experimenting with Kleis:</p>
<pre><code class="language-bash">$ cargo run --bin repl

üßÆ Kleis REPL v0.1.0
   Type :help for commands, :quit to exit

Œª&gt;
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Enter expressions to evaluate them symbolically:</p>
<pre><code>Œª&gt; 2 + 2
2 + 2

Œª&gt; let x = 5 in x * x
times(5, 5)

Œª&gt; sin(œÄ / 2)
sin(divide(œÄ, 2))
</code></pre>
<blockquote>
<p><strong>Note:</strong> The REPL performs <strong>symbolic evaluation</strong>, not numeric computation. Expressions are simplified symbolically, not calculated to numbers.</p>
</blockquote>
<h2 id="loading-files"><a class="header" href="#loading-files">Loading Files</a></h2>
<p>The REPL prompt evaluates expressions. For definitions (<code>define</code>, <code>structure</code>, etc.), use <code>:load</code>:</p>
<pre><code>Œª&gt; :load examples/protocols/stop_and_wait.kleis
‚úÖ Loaded: 1 files, 5 functions, 0 structures, 0 data types, 0 type aliases

Œª&gt; :env
üìã Defined functions:
  next_seq (seq) = ...
  valid_ack (sent, ack) = ...
  sender_next_state (current_seq, ack_received) = ...
  receiver_accepts (expected, received) = ...
  receiver_next_state (expected, received) = ...
</code></pre>
<p>More examples to load:</p>
<pre><code>Œª&gt; :load examples/business/order_to_cash.kleis
‚úÖ Loaded: 1 files, 21 functions, 0 structures, 4 data types, 0 type aliases

Œª&gt; :load examples/authorization/zanzibar.kleis
‚úÖ Loaded: 1 files, 13 functions, 0 structures, 0 data types, 0 type aliases
</code></pre>
<h2 id="verification-with-z3-1"><a class="header" href="#verification-with-z3-1">Verification with Z3</a></h2>
<p>Run verifications interactively with <code>:verify</code>:</p>
<pre><code>Œª&gt; :verify x + y = y + x
‚úÖ Valid

Œª&gt; :verify x &gt; 0
‚ùå Invalid - Counterexample: x!2 -&gt; 0
</code></pre>
<h2 id="satisfiability-with-z3"><a class="header" href="#satisfiability-with-z3">Satisfiability with Z3</a></h2>
<p>Use <code>:sat</code> to find solutions (equation solving):</p>
<pre><code>Œª&gt; :sat ‚àÉ(z : ‚ÑÇ). z * z = complex(-1, 0)
‚úÖ Satisfiable
   Witness: z_re = 0, z_im = -1

Œª&gt; :sat ‚àÉ(x : ‚Ñù). x * x = 4
‚úÖ Satisfiable
   Witness: x = -2

Œª&gt; :sat ‚àÉ(x : ‚Ñù). x * x = -1
‚ùå Unsatisfiable (no solution exists)

Œª&gt; :sat ‚àÉ(x : ‚Ñù)(y : ‚Ñù). x + y = 10 ‚àß x - y = 4
‚úÖ Satisfiable
   Witness: x = 7, y = 3
</code></pre>
<p><strong><code>:verify</code> vs <code>:sat</code>:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Question</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>:verify</code></td><td>Is it always true? (‚àÄ)</td><td>Prove theorems</td></tr>
<tr><td><code>:sat</code></td><td>Does a solution exist? (‚àÉ)</td><td>Solve equations</td></tr>
</tbody>
</table>
</div>
<h2 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h2>
<p>Lambda expressions work at the prompt:</p>
<pre><code>Œª&gt; Œª x . x * 2
Œª x . times(x, 2)

Œª&gt; Œª x y . x + y
Œª x y . x + y
</code></pre>
<h2 id="type-inference-1"><a class="header" href="#type-inference-1">Type Inference</a></h2>
<p>Check types with <code>:type</code>:</p>
<pre><code>Œª&gt; :type 42
üìê Type: Scalar

Œª&gt; :type sin
üìê Type: Œ±0
</code></pre>
<h2 id="repl-commands"><a class="header" href="#repl-commands">REPL Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>:help</code></td><td>Show all commands</td></tr>
<tr><td><code>:load &lt;file&gt;</code></td><td>Load a .kleis file</td></tr>
<tr><td><code>:env</code></td><td>Show defined functions</td></tr>
<tr><td><code>:verify &lt;expr&gt;</code></td><td>Verify with Z3 (is it always true?)</td></tr>
<tr><td><code>:sat &lt;expr&gt;</code></td><td>Check satisfiability (does a solution exist?)</td></tr>
<tr><td><code>:type &lt;expr&gt;</code></td><td>Show inferred type</td></tr>
<tr><td><code>:ast &lt;expr&gt;</code></td><td>Show parsed AST</td></tr>
<tr><td><code>:symbols</code></td><td>Unicode math symbols palette</td></tr>
<tr><td><code>:syntax</code></td><td>Complete syntax reference</td></tr>
<tr><td><code>:examples</code></td><td>Show example expressions</td></tr>
<tr><td><code>:quit</code></td><td>Exit REPL</td></tr>
</tbody>
</table>
</div>
<h2 id="multi-line-input"><a class="header" href="#multi-line-input">Multi-line Input</a></h2>
<p>For complex expressions, end lines with <code>\</code> or use block mode:</p>
<pre><code>Œª&gt; :verify ‚àÄ(a : R, b : R). \
   (a + b) * (a - b) = a * a - b * b
‚úÖ Valid
</code></pre>
<p>Or use <code>:{ ... :}</code> for blocks:</p>
<pre><code>Œª&gt; :{
   :verify ‚àÄ(x : R, y : R, z : R).
     (x + y) + z = x + (y + z)
   :}
‚úÖ Valid
</code></pre>
<h2 id="example-session"><a class="header" href="#example-session">Example Session</a></h2>
<pre><code>Œª&gt; :load examples/authorization/zanzibar.kleis
‚úÖ Loaded: 1 files, 13 functions, 0 structures, 0 data types, 0 type aliases

Œª&gt; :env
üìã Defined functions:
  can_share (perm) = ...
  can_edit (perm) = ...
  can_delete (perm) = ...
  effective_permission (direct, group) = ...
  inherited_permission (child_perm, parent_perm) = ...
  can_comment (perm) = ...
  is_allowed (perm, action) = ...
  doc_access (doc_perm, folder_perm, action) = ...
  has_at_least (user_perm, required_perm) = ...
  can_read (perm) = ...
  multi_group_permission (perm1, perm2, perm3) = ...
  can_grant (granter_perm, grantee_perm) = ...
  can_transfer_ownership (perm) = ...

Œª&gt; :verify ‚àÄ(x : ‚Ñù). x * x ‚â• 0
‚úÖ Valid

Œª&gt; :quit
Goodbye! üëã
</code></pre>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<ol>
<li>Press <strong>Ctrl+C</strong> to cancel input</li>
<li>Press <strong>Ctrl+D</strong> or type <code>:quit</code> to exit</li>
<li>Use <code>:symbols</code> to copy-paste Unicode math symbols</li>
<li>Use <code>:help &lt;topic&gt;</code> for detailed help (e.g., <code>:help quantifiers</code>)</li>
</ol>
<h2 id="whats-next-11"><a class="header" href="#whats-next-11">What‚Äôs Next?</a></h2>
<p>See practical applications!</p>
<p>‚Üí <a href="#applications">Next: Applications</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>Kleis is designed for mathematical verification, but its power extends far beyond pure mathematics. This chapter showcases applications across multiple domains.</p>
<h2 id="business-process-modeling"><a class="header" href="#business-process-modeling">Business Process Modeling</a></h2>
<p>Model and verify business workflows with formal guarantees:</p>
<pre><code class="language-kleis">// Order-to-Cash (O2C) Business Process
// Models the complete lifecycle from order to payment

// Order lifecycle states
data OrderStatus = 
    Draft | Pending | CreditApproved | CreditDenied 
  | Allocated | Fulfilled | Shipped | Invoiced 
  | Paid | Complete | Cancelled

// Credit check decision based on utilization
define credit_check_decision(utilization) =
    if utilization &lt;= 100 then 1      // Approved
    else if utilization &lt; 125 then 2  // PendingReview
    else 0                            // Denied

// Can order be cancelled from current state?
define can_cancel(status) = match status {
    Draft =&gt; 1
  | Pending =&gt; 1
  | CreditApproved =&gt; 1
  | Allocated =&gt; 1
  | _ =&gt; 0  // Can't cancel after fulfillment
}

// INVARIANT: No shipment without credit approval
define shipment_requires_credit(order_status, credit_approved) =
    if order_status = 6 then credit_approved = 1 else true

// INVARIANT: Order completion requires full payment
define completion_requires_payment(order_status, payment_status) =
    if order_status = 9 then payment_status &gt;= 2 else true
</code></pre>
<h2 id="network-protocol-verification"><a class="header" href="#network-protocol-verification">Network Protocol Verification</a></h2>
<p>Verify protocol correctness with formal methods:</p>
<pre><code class="language-kleis">// Stop-and-Wait Protocol - Reliable Data Transfer

// Sequence numbers alternate between 0 and 1
define next_seq(seq) = if seq = 0 then 1 else 0

// ACK is valid if it matches sent sequence
define valid_ack(sent, ack) = if ack = sent then 1 else 0

// Sender advances state only on valid ACK
define sender_next_state(current_seq, ack_received) = 
    if valid_ack(current_seq, ack_received) = 1 
    then next_seq(current_seq) 
    else current_seq

// VERIFIED: Double alternation returns to original
// next_seq(next_seq(0)) = 0  ‚úì
// next_seq(next_seq(1)) = 1  ‚úì

// SAFETY: No duplicate delivery when synchronized
// LIVENESS: Progress guaranteed when channel delivers
</code></pre>
<h3 id="ipv4-packet-validation"><a class="header" href="#ipv4-packet-validation">IPv4 Packet Validation</a></h3>
<pre><code class="language-kleis">// IPv4 Header Validation (RFC 791)

// Version must be 4 for IPv4
define valid_version(v) = if v = 4 then 1 else 0

// IHL (Internet Header Length): 5-15 words
define valid_ihl(ihl) = ihl &gt;= 5 and ihl &lt;= 15

// Header length in bytes
define header_length(ihl) = ihl * 4

// Common protocols: 1=ICMP, 6=TCP, 17=UDP
define is_tcp(proto) = proto = 6
define is_udp(proto) = proto = 17

// Private address ranges
define is_private_class_a(o1) = o1 = 10
define is_private_class_c(o1, o2) = o1 = 192 and o2 = 168

// Full packet validation
define valid_packet(version, ihl, total, ttl, proto) = 
    valid_version(version) = 1 and
    valid_ihl(ihl) = 1 and
    ttl &gt; 0 and
    total &gt;= header_length(ihl)
</code></pre>
<h2 id="authorization--access-control"><a class="header" href="#authorization--access-control">Authorization &amp; Access Control</a></h2>
<p>Model Zanzibar-style relationship-based access control (like Google Drive):</p>
<pre><code class="language-kleis">// Permission Levels: 0=None, 1=Viewer, 2=Commenter, 3=Editor, 4=Owner

define has_at_least(user_perm, required_perm) = user_perm &gt;= required_perm

define can_read(perm) = has_at_least(perm, 1)
define can_edit(perm) = has_at_least(perm, 3)
define can_delete(perm) = has_at_least(perm, 4)

// Folder inheritance (like Google Drive)
define inherited_permission(child_perm, parent_perm) = 
    if child_perm &gt; 0 
    then child_perm      // Explicit permission overrides
    else parent_perm     // Inherit from parent

// Multi-group permission: take highest
define effective_permission(direct, group) = 
    if direct &gt;= group then direct else group

// Security invariant: can_edit implies can_read
// ‚àÄ p . can_edit(p) = 1 ‚Üí can_read(p) = 1
</code></pre>
<h2 id="security-analysis"><a class="header" href="#security-analysis">Security Analysis</a></h2>
<p>Use Z3 string theory for static security analysis:</p>
<pre><code class="language-kleis">// SQL Injection Detection using String Operations

// Vulnerable pattern: string concatenation + SQL execution
// :verify and(
//   contains("SELECT * FROM users WHERE id=" + userId, "+ userId"),
//   contains(code, "executeQuery")
// )
// If Valid ‚Üí VULNERABLE!

// Safe pattern: parameterized queries
// :verify and(
//   contains(code, "PreparedStatement"),
//   not(contains(code, "+ userId +"))
// )
// If Valid ‚Üí SAFE

// XSS Detection: innerHTML with user input
// :verify and(
//   contains(code, "innerHTML"),
//   contains(code, "userData")
// )
</code></pre>
<h2 id="control-systems-engineering"><a class="header" href="#control-systems-engineering">Control Systems Engineering</a></h2>
<p>Design optimal controllers with verified stability:</p>
<pre><code class="language-kleis">// LQG Controller: Linear Quadratic Gaussian

structure LinearSystem(n: Nat, m: Nat, p: Nat) {
    element A : Matrix(n, n, ‚Ñù)   // State dynamics
    element B : Matrix(n, m, ‚Ñù)   // Input matrix
    element C : Matrix(p, n, ‚Ñù)   // Output matrix
    element W : Matrix(n, n, ‚Ñù)   // Process noise covariance
    element V : Matrix(p, p, ‚Ñù)   // Measurement noise covariance
}

// LQR: Optimal state feedback
operation lqr_gain : LQRProblem(n, m) ‚Üí Matrix(m, n, ‚Ñù)

axiom lqr_stability:
    ‚àÄ prob : LQRProblem(n, m) .
    let K = lqr_gain(prob) in
    let A_cl = prob.A - prob.B ¬∑ K in
    is_stable(A_cl)

// Kalman Filter: Optimal state estimation
operation kalman_gain : KalmanProblem(n, p) ‚Üí Matrix(n, p, ‚Ñù)

// LQG combines LQR + Kalman via Separation Principle
structure LQGController(n: Nat, m: Nat, p: Nat) {
    element K : Matrix(m, n, ‚Ñù)   // LQR gain
    element L : Matrix(n, p, ‚Ñù)   // Kalman gain
}
</code></pre>
<h2 id="dimensional-analysis-physical-units"><a class="header" href="#dimensional-analysis-physical-units">Dimensional Analysis (Physical Units)</a></h2>
<p>Prevent unit mismatch bugs at compile time - like the Mars Climate Orbiter disaster ($327M lost due to imperial/metric confusion):</p>
<pre><code class="language-kleis">// Physical dimensions as exponent tuples [Length, Mass, Time]
structure Dimension(L : ‚Ñ§, M : ‚Ñ§, T : ‚Ñ§) {
    axiom equal : ‚àÄ(d1 d2 : Dimension). 
        d1 = d2 ‚Üî (L(d1) = L(d2) ‚àß M(d1) = M(d2) ‚àß T(d1) = T(d2))
}

// Named dimensions
define Length = Dimension(1, 0, 0)
define Mass = Dimension(0, 1, 0)
define Time = Dimension(0, 0, 1)
define Velocity = Dimension(1, 0, -1)      // L¬∑T‚Åª¬π
define Force = Dimension(1, 1, -2)         // M¬∑L¬∑T‚Åª¬≤
define Energy = Dimension(2, 1, -2)        // M¬∑L¬≤¬∑T‚Åª¬≤

// Physical quantity = value + dimension
structure Quantity(value : ‚Ñù, dim : Dimension) {
    // Addition: dimensions must match
    axiom add_same_dim : ‚àÄ(q1 q2 : Quantity)(d : Dimension).
        dim(q1) = d ‚àß dim(q2) = d ‚Üí dim(q1 + q2) = d
    
    // Multiplication: dimensions compose
    axiom mul_composes : ‚àÄ(q1 q2 : Quantity).
        dim(q1 * q2) = Dimension(
            L(dim(q1)) + L(dim(q2)), 
            M(dim(q1)) + M(dim(q2)), 
            T(dim(q1)) + T(dim(q2)))
}

// Unit constructors
define meter(x : ‚Ñù) = Quantity(x, Length)
define kilogram(x : ‚Ñù) = Quantity(x, Mass)
define second(x : ‚Ñù) = Quantity(x, Time)
define newton(x : ‚Ñù) = Quantity(x, Force)

// Physics axioms verify dimensional consistency
structure Mechanics {
    // F = ma: [M¬∑L¬∑T‚Åª¬≤] = [M] √ó [L¬∑T‚Åª¬≤] ‚úì
    axiom newton_second_law : ‚àÄ(m : Quantity)(a : Quantity).
        dim(m) = Mass ‚àß dim(a) = Dimension(1, 0, -2) ‚Üí
        dim(m * a) = Force
    
    // E = ¬Ωmv¬≤: [M¬∑L¬≤¬∑T‚Åª¬≤] = [M] √ó [L¬∑T‚Åª¬π]¬≤ ‚úì
    axiom kinetic_energy : ‚àÄ(m : Quantity)(v : Quantity).
        dim(m) = Mass ‚àß dim(v) = Velocity ‚Üí
        dim(m * v * v) = Energy
}
</code></pre>
<p><strong>Type-safe physics:</strong></p>
<ul>
<li><code>meter(100) + meter(50)</code> ‚Üí <code>Quantity(150, Length)</code> ‚úì</li>
<li><code>meter(100) / second(10)</code> ‚Üí <code>Quantity(10, Velocity)</code> ‚úì</li>
<li><code>meter(100) + second(10)</code> ‚Üí ‚ùå Type error: <code>Length ‚â† Time</code></li>
</ul>
<p>See <code>examples/physics/dimensional_analysis.kleis</code> for the full example.</p>
<h2 id="differential-geometry"><a class="header" href="#differential-geometry">Differential Geometry</a></h2>
<p>Kleis excels at differential geometry calculations:</p>
<pre><code class="language-kleis">// Christoffel symbols for spherical coordinates
structure SphericalMetric {
    operation metric : (‚Ñù, ‚Ñù) ‚Üí Matrix(2, 2, ‚Ñù)
    operation christoffel : (‚Ñù, ‚Ñù) ‚Üí Tensor(1, 2)
}

implements SphericalMetric {
    // Metric tensor: ds¬≤ = r¬≤(dŒ∏¬≤ + sin¬≤Œ∏ dœÜ¬≤)
    operation metric(r, Œ∏) = Matrix [
        [r^2, 0],
        [0, r^2 * sin(Œ∏)^2]
    ]
    
    // Christoffel symbols Œì‚Å±‚±º‚Çñ
    operation christoffel(r, Œ∏) = 
        let g = metric(r, Œ∏) in
        let g_inv = inverse(g) in
        // ... compute from metric derivatives
}
</code></pre>
<h2 id="tensor-calculus"><a class="header" href="#tensor-calculus">Tensor Calculus</a></h2>
<pre><code class="language-kleis">// Einstein field equations
structure EinsteinEquations {
    // Ricci tensor
    operation ricci : Manifold ‚Üí Tensor(0, 2)
    // Scalar curvature
    operation scalar : Manifold ‚Üí ‚Ñù
    // Einstein tensor
    operation einstein : Manifold ‚Üí Tensor(0, 2)
    
    axiom einstein_tensor : ‚àÄ(M : Manifold).
        einstein(M) = ricci(M) - (scalar(M) / 2) * metric(M)
}
</code></pre>
<h2 id="symbolic-differentiation"><a class="header" href="#symbolic-differentiation">Symbolic Differentiation</a></h2>
<pre><code class="language-kleis">data Expr = Const(value : ‚Ñù) 
          | Var(name : String) 
          | Add(left : Expr, right : Expr) 
          | Mul(left : Expr, right : Expr) 
          | Pow(base : Expr, exp : Expr)
          | Sin(arg : Expr)
          | Cos(arg : Expr)
          | Exp(arg : Expr)
          | Ln(arg : Expr)

define diff(e, x) =
    match e {
        Const(_) =&gt; Const(0)
        Var(y) =&gt; if y = x then Const(1) else Const(0)
        
        Add(f, g) =&gt; Add(diff(f, x), diff(g, x))
        
        Mul(f, g) =&gt;
            Add(Mul(diff(f, x), g), Mul(f, diff(g, x)))
            
        Pow(f, Const(n)) =&gt;
            Mul(Mul(Const(n), Pow(f, Const(n - 1))), diff(f, x))
            
        Sin(f) =&gt; Mul(Cos(f), diff(f, x))
        Cos(f) =&gt; Mul(Mul(Const(-1), Sin(f)), diff(f, x))
        Exp(f) =&gt; Mul(Exp(f), diff(f, x))
        Ln(f) =&gt; Mul(Pow(f, Const(-1)), diff(f, x))
        
        _ =&gt; Const(0)
    }
</code></pre>
<h2 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h2>
<pre><code class="language-kleis">structure LinearSystem(n : ‚Ñï) {
    operation solve : Matrix(n, n, ‚Ñù) √ó Vector(n, ‚Ñù) ‚Üí Vector(n, ‚Ñù)
    
    // Solution satisfies Ax = b
    axiom solution_correct : ‚àÄ(A : Matrix(n, n, ‚Ñù))(b : Vector(n, ‚Ñù)).
        det(A) ‚â† 0 ‚Üí mul(A, solve(A, b)) = b
}

// Eigenvalue problem
structure Eigen(n : ‚Ñï) {
    operation eigenvalues : Matrix(n, n, ‚ÑÇ) ‚Üí List(‚ÑÇ)
    operation eigenvectors : Matrix(n, n, ‚ÑÇ) ‚Üí List(Vector(n, ‚ÑÇ))
    
    axiom eigenpair : ‚àÄ(A : Matrix(n, n, ‚ÑÇ))(i : ‚Ñï).
        let lam = nth(eigenvalues(A), i) in
        let v = nth(eigenvectors(A), i) in
            mul(A, v) = scale(lam, v)
}
</code></pre>
<h2 id="quantum-mechanics"><a class="header" href="#quantum-mechanics">Quantum Mechanics</a></h2>
<pre><code class="language-kleis">structure QuantumState(n : ‚Ñï) {
    operation amplitudes : Vector(n, ‚ÑÇ)
    
    // States must be normalized
    axiom normalized : ‚àÄ(psi : QuantumState(n)).
        sum(map(Œª a . abs(a)^2, amplitudes(psi))) = 1
}

structure Observable(n : ‚Ñï) {
    operation matrix : Matrix(n, n, ‚ÑÇ)
    
    // Observables are Hermitian
    axiom hermitian : ‚àÄ(O : Observable(n)).
        matrix(O) = conjugate_transpose(matrix(O))
}

// Expectation value
define expectation(psi, O) =
    real(inner_product(amplitudes(psi), mul(matrix(O), amplitudes(psi))))
</code></pre>
<h2 id="category-theory"><a class="header" href="#category-theory">Category Theory</a></h2>
<pre><code class="language-kleis">structure Category(Obj, Mor) {
    operation id : Obj ‚Üí Mor
    operation compose : Mor √ó Mor ‚Üí Mor
    operation dom : Mor ‚Üí Obj
    operation cod : Mor ‚Üí Obj
    
    axiom identity_left : ‚àÄ(f : Mor).
        compose(id(cod(f)), f) = f
        
    axiom identity_right : ‚àÄ(f : Mor).
        compose(f, id(dom(f))) = f
        
    axiom associativity : ‚àÄ(f : Mor)(g : Mor)(h : Mor).
        compose(compose(h, g), f) = compose(h, compose(g, f))
}

structure Functor(C, D) {
    operation map_obj : C ‚Üí D
    operation map_mor : C ‚Üí D
    
    axiom preserves_id : ‚àÄ(x : C).
        map_mor(id(x)) = id(map_obj(x))
        
    axiom preserves_compose : ‚àÄ(f : C)(g : C).
        map_mor(compose(g, f)) = compose(map_mor(g), map_mor(f))
}
</code></pre>
<h2 id="physics-classical-mechanics"><a class="header" href="#physics-classical-mechanics">Physics: Classical Mechanics</a></h2>
<pre><code class="language-kleis">structure LagrangianMechanics(n : ‚Ñï) {
    // Generalized coordinates and velocities
    operation q : ‚Ñï ‚Üí ‚Ñù     // Position
    operation q_dot : ‚Ñï ‚Üí ‚Ñù  // Velocity
    operation t : ‚Ñù          // Time
    
    // Lagrangian L = T - V
    operation lagrangian : ‚Ñù
    
    // Euler-Lagrange equations
    // Using Mathematica-style: Dt for total derivative, D for partial
    axiom euler_lagrange : ‚àÄ i : ‚Ñï . i &lt; n ‚Üí
        Dt(D(lagrangian, q_dot(i)), t) = D(lagrangian, q(i))
}
</code></pre>
<h2 id="language-implementation"><a class="header" href="#language-implementation">Language Implementation</a></h2>
<p>Kleis can serve as a <strong>meta-language</strong> ‚Äî a language for implementing other languages. See the complete LISP interpreter in Kleis:</p>
<pre><code>Œª&gt; :load docs/grammar/lisp_parser.kleis

Œª&gt; :eval run("(letrec ((fib (lambda (n) (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 10))")
‚úÖ VNum(55)

Œª&gt; :eval run("(letrec ((fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))) (fact 5))")
‚úÖ VNum(120)
</code></pre>
<p>The complete implementation (parser + evaluator) is ~560 lines of pure Kleis code.</p>
<p>‚Üí <a href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter</a> ‚Äî Full source code with explanation</p>
<h2 id="whats-next-12"><a class="header" href="#whats-next-12">What‚Äôs Next?</a></h2>
<p>Check out the reference appendices!</p>
<p>‚Üí <a href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a>
‚Üí <a href="#appendix-b-operators">Appendix B: Operators</a>
‚Üí <a href="#appendix-c-standard-library">Appendix C: Standard Library</a>
‚Üí <a href="#appendix-lisp-interpreter-in-kleis">Appendix D: LISP Interpreter</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="complex-numbers"><a class="header" href="#complex-numbers">Complex Numbers</a></h1>
<p>Kleis has first-class support for complex numbers (‚ÑÇ), enabling symbolic reasoning about complex arithmetic, verification of identities, and theorem proving in complex analysis.</p>
<h2 id="natural-arithmetic-syntax--new"><a class="header" href="#natural-arithmetic-syntax--new">Natural Arithmetic Syntax ‚ú® NEW</a></h2>
<p><strong>Kleis now supports natural arithmetic operators for complex numbers!</strong></p>
<p>You can write expressions using <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> with complex numbers, just like you would with real numbers:</p>
<pre><code class="language-kleis">// Natural syntax (NEW!)
:verify complex(1, 2) + complex(3, 4) = complex(4, 6)
// ‚úÖ Valid

:verify complex(1, 2) * complex(3, 4) = complex(-5, 10)
// ‚úÖ Valid

// The classic: 3 + 4i
:verify 3 + 4*i = complex(3, 4)
// ‚úÖ Valid

// Mixed real and complex
:verify 5 + complex(1, 2) = complex(6, 2)
// ‚úÖ Valid
</code></pre>
<p>Kleis automatically converts these to the appropriate complex operations via <strong>semantic lowering</strong>:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>You Write</th><th>Kleis Translates To</th></tr>
</thead>
<tbody>
<tr><td><code>z1 + z2</code></td><td><code>complex_add(z1, z2)</code></td></tr>
<tr><td><code>z1 - z2</code></td><td><code>complex_sub(z1, z2)</code></td></tr>
<tr><td><code>z1 * z2</code></td><td><code>complex_mul(z1, z2)</code></td></tr>
<tr><td><code>z1 / z2</code></td><td><code>complex_div(z1, z2)</code></td></tr>
<tr><td><code>r + z</code> (‚Ñù + ‚ÑÇ)</td><td><code>complex_add(complex(r, 0), z)</code></td></tr>
<tr><td><code>-z</code></td><td><code>neg_complex(z)</code></td></tr>
</tbody>
</table>
</div>
<p>This works transparently in the REPL and for verification.</p>
<h2 id="the-imaginary-unit"><a class="header" href="#the-imaginary-unit">The Imaginary Unit</a></h2>
<p>The imaginary unit <code>i</code> is predefined in Kleis:</p>
<pre><code class="language-kleis">// i is the square root of -1
define i_squared = i * i
// Result: complex(-1, 0)  ‚Äî that's -1!
</code></pre>
<p>In the REPL, you can verify this fundamental property:</p>
<pre><code class="language-kleis">:verify i * i = complex(-1, 0)
// ‚úÖ Valid

// Or using the explicit function:
:verify complex_mul(i, i) = complex(-1, 0)
// ‚úÖ Valid
</code></pre>
<h3 id="scoping-rules-for-i"><a class="header" href="#scoping-rules-for-i">Scoping Rules for <code>i</code></a></h3>
<p>The imaginary unit <code>i</code> is a global constant. However, it can be shadowed by:</p>
<ol>
<li><strong>Quantified variables</strong> with explicit type annotations</li>
<li><strong>Lambda parameters</strong></li>
</ol>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Expression</th><th>Type</th><th>Explanation</th></tr>
</thead>
<tbody>
<tr><td><code>i</code></td><td>Complex</td><td>Global imaginary unit</td></tr>
<tr><td><code>i + 1</code></td><td>Complex</td><td>Uses global <code>i</code></td></tr>
<tr><td><code>i * i</code></td><td>Complex</td><td><code>i¬≤ = -1</code></td></tr>
<tr><td><code>Œª x . x + i</code></td><td>Complex</td><td>Uses global <code>i</code> in body</td></tr>
<tr><td><code>‚àÄ(i : ‚Ñù). i + 1</code></td><td>Scalar</td><td>Quantifier <code>i : ‚Ñù</code> shadows global</td></tr>
<tr><td><code>‚àÄ(i : ‚Ñï). i + 0</code></td><td>Nat</td><td>Quantifier <code>i : ‚Ñï</code> shadows global</td></tr>
<tr><td><code>Œª i . i + 1</code></td><td>Scalar</td><td>Lambda param shadows global</td></tr>
</tbody>
</table>
</div>
<p><strong>Scoping examples:</strong></p>
<pre><code class="language-kleis">// Quantified variable i : ‚Ñù shadows the global imaginary unit
// Here i is a real number, so i + 1 uses regular addition
verify ‚àÄ(i : ‚Ñù). i + 1 = 1 + i

// Quantified variable i : ‚Ñï is a natural number
verify ‚àÄ(i : ‚Ñï). i + 0 = i

// Quantified variable i : ‚ÑÇ is explicitly complex
verify ‚àÄ(i : ‚ÑÇ). complex_add(i, complex(0, 0)) = i
</code></pre>
<p><strong>In the REPL, you can also check types:</strong></p>
<pre><code>Œª&gt; :type i
üìê Type: Complex

Œª&gt; :type i + 1  
üìê Type: Complex

Œª&gt; :type Œª x . x + i
üìê Type: Complex

Œª&gt; :type Œª i . i + 1
üìê Type: Scalar
</code></pre>
<p>Note: <code>Œª x . x + i</code> uses global <code>i</code>, while <code>Œª i . i + 1</code> has parameter <code>i</code> shadowing global.</p>
<p><strong>Best practice:</strong> Avoid using <code>i</code> as a variable name to prevent confusion with the imaginary unit. Use descriptive names like <code>idx</code>, <code>index</code>, or <code>iter</code> for loop-like variables.</p>
<pre><code class="language-kleis">// Clear: using i as imaginary unit
verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, i) = complex(neg(im(z)), re(z))

// Clear: using idx as index variable  
verify ‚àÄ(idx : ‚Ñï). idx + 0 = idx
</code></pre>
<h2 id="creating-complex-numbers"><a class="header" href="#creating-complex-numbers">Creating Complex Numbers</a></h2>
<p><strong>Method 1: Using arithmetic (recommended)</strong></p>
<pre><code class="language-kleis">define z1 = 3 + 4*i           // 3 + 4i
define z2 = 1 - 2*i           // 1 - 2i
define pure_real = 5 + 0*i    // 5 (a real number)
define pure_imag = 0 + 3*i    // 3i (pure imaginary)
</code></pre>
<p><strong>Method 2: Using the <code>complex(re, im)</code> constructor</strong></p>
<pre><code class="language-kleis">// complex(real_part, imaginary_part)
define z1 = complex(3, 4)       // 3 + 4i
define z2 = complex(1, -2)      // 1 - 2i
define pure_real = complex(5, 0)     // 5 (a real number)
define pure_imag = complex(0, 3)     // 3i (pure imaginary)
</code></pre>
<h2 id="extracting-parts"><a class="header" href="#extracting-parts">Extracting Parts</a></h2>
<p>Use <code>re</code> and <code>im</code> to extract the real and imaginary parts:</p>
<pre><code class="language-kleis">define z = complex(3, 4)

// Extract real part
define real_part = re(z)        // 3

// Extract imaginary part  
define imag_part = im(z)        // 4
</code></pre>
<p>Verification examples:</p>
<pre><code class="language-kleis">:verify re(complex(7, 8)) = 7
// ‚úÖ Valid

:verify im(complex(7, 8)) = 8
// ‚úÖ Valid

:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù). re(complex(a, b)) = a
// ‚úÖ Valid
</code></pre>
<h2 id="type-ascriptions-with-‚ÑÇ"><a class="header" href="#type-ascriptions-with-‚ÑÇ">Type Ascriptions with ‚ÑÇ</a></h2>
<p>Type ascriptions tell Kleis (and Z3) that a variable is a complex number. The syntax is <code>: ‚ÑÇ</code> (or <code>: Complex</code>).</p>
<h3 id="quantifier-variables"><a class="header" href="#quantifier-variables">Quantifier Variables</a></h3>
<p>The most common use is in universal quantifiers:</p>
<pre><code class="language-kleis">// z is a complex variable
:verify ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
// ‚úÖ Valid

// Multiple complex variables
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). z1 + z2 = z2 + z1
// ‚úÖ Valid

// Mixed types: real and complex
:verify ‚àÄ(r : ‚Ñù)(z : ‚ÑÇ). r + z = complex(r + re(z), im(z))
// ‚úÖ Valid
</code></pre>
<p>When you write <code>‚àÄ(z : ‚ÑÇ)</code>, the Z3 backend creates a symbolic complex variable with unknown real and imaginary parts. This lets Z3 reason about <strong>all possible</strong> complex numbers.</p>
<h3 id="definition-annotations"><a class="header" href="#definition-annotations">Definition Annotations</a></h3>
<p>You can annotate definitions for clarity:</p>
<pre><code class="language-kleis">define z1 : ‚ÑÇ = complex(1, 2)
define z2 : ‚ÑÇ = 3 + 4*i
define origin : ‚ÑÇ = complex(0, 0)
</code></pre>
<h3 id="why-type-ascriptions-matter"><a class="header" href="#why-type-ascriptions-matter">Why Type Ascriptions Matter</a></h3>
<p>Without type information, Z3 wouldn‚Äôt know how to handle operations:</p>
<pre><code class="language-kleis">// With `: ‚ÑÇ`, Z3 knows z is complex and creates appropriate constraints
:verify ‚àÄ(z : ‚ÑÇ). z * complex(1, 0) = z
// ‚úÖ Valid

// Z3 can reason symbolically about the real and imaginary parts
:verify ‚àÄ(z : ‚ÑÇ). re(z) * re(z) + im(z) * im(z) = abs_squared(z)
// ‚úÖ Valid
</code></pre>
<h3 id="equivalent-type-names"><a class="header" href="#equivalent-type-names">Equivalent Type Names</a></h3>
<p>For complex numbers, these are all equivalent:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>: ‚ÑÇ</code></td><td>Unicode symbol (recommended)</td></tr>
<tr><td><code>: Complex</code></td><td>Full name</td></tr>
<tr><td><code>: C</code></td><td>Short ASCII alternative</td></tr>
</tbody>
</table>
</div>
<p>For comparison, here are the equivalent forms for other numeric types:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Unicode</th><th>Full Name</th><th>ASCII</th></tr>
</thead>
<tbody>
<tr><td>Complex</td><td><code>: ‚ÑÇ</code></td><td><code>: Complex</code></td><td><code>: C</code></td></tr>
<tr><td>Real/Scalar</td><td><code>: ‚Ñù</code></td><td><code>: Real</code> or <code>: Scalar</code></td><td><code>: R</code></td></tr>
<tr><td>Natural</td><td><code>: ‚Ñï</code></td><td><code>: Nat</code></td><td><code>: N</code></td></tr>
<tr><td>Integer</td><td><code>: ‚Ñ§</code></td><td><code>: Int</code> or <code>: Integer</code></td><td><code>: Z</code></td></tr>
<tr><td>Boolean</td><td><code>: ùîπ</code></td><td><code>: Bool</code></td><td>‚Äî</td></tr>
</tbody>
</table>
</div>
<h2 id="arithmetic-operations"><a class="header" href="#arithmetic-operations">Arithmetic Operations</a></h2>
<h3 id="addition-and-subtraction"><a class="header" href="#addition-and-subtraction">Addition and Subtraction</a></h3>
<pre><code class="language-kleis">define z1 = 1 + 2*i    // 1 + 2i
define z2 = 3 + 4*i    // 3 + 4i

// Addition: (1 + 2i) + (3 + 4i) = 4 + 6i
define sum = z1 + z2

// Subtraction: (1 + 2i) - (3 + 4i) = -2 - 2i
define diff = z1 - z2
</code></pre>
<p>Verify concrete arithmetic:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 2*i) + (3 + 4*i) = 4 + 6*i
// ‚úÖ Valid

:verify (5 + 3*i) - (2 + 1*i) = 3 + 2*i
// ‚úÖ Valid

// Explicit function syntax (also works)
:verify complex_add(complex(1, 2), complex(3, 4)) = complex(4, 6)
// ‚úÖ Valid
</code></pre>
<h3 id="multiplication"><a class="header" href="#multiplication">Multiplication</a></h3>
<p>Complex multiplication follows the rule: <code>(a + bi)(c + di) = (ac - bd) + (ad + bc)i</code></p>
<pre><code class="language-kleis">define z1 = 1 + 2*i    // 1 + 2i
define z2 = 3 + 4*i    // 3 + 4i

// (1 + 2i)(3 + 4i) = 3 + 4i + 6i + 8i¬≤ = 3 + 10i - 8 = -5 + 10i
define product = z1 * z2
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 2*i) * (3 + 4*i) = complex(-5, 10)
// ‚úÖ Valid

// The fundamental property: i¬≤ = -1
:verify i * i = complex(-1, 0)
// ‚úÖ Valid

// Multiplication by i rotates 90¬∞
:verify ‚àÄ(z : ‚ÑÇ). z * i = complex(neg(im(z)), re(z))
// ‚úÖ Valid (where neg is negation)
</code></pre>
<h3 id="division"><a class="header" href="#division">Division</a></h3>
<pre><code class="language-kleis">define z1 = 1 + 0*i    // 1
define z2 = 0 + 1*i    // i

// 1 / i = -i
define quotient = z1 / z2
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">// Natural syntax
:verify (1 + 0*i) / (0 + 1*i) = 0 - 1*i
// ‚úÖ Valid

// Explicit function syntax
:verify complex_div(complex(1, 0), complex(0, 1)) = complex(0, -1)
// ‚úÖ Valid
</code></pre>
<h3 id="negation"><a class="header" href="#negation">Negation</a></h3>
<pre><code class="language-kleis">define z = complex(3, 4)
define neg_z = neg_complex(z)    // -3 - 4i
</code></pre>
<pre><code class="language-kleis">:verify neg_complex(complex(3, 4)) = complex(-3, -4)
// ‚úÖ Valid

:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, neg_complex(z)) = complex(0, 0)
// ‚úÖ Valid
</code></pre>
<h3 id="inverse"><a class="header" href="#inverse">Inverse</a></h3>
<pre><code class="language-kleis">define z = complex(0, 1)         // i
define inv = complex_inverse(z)   // 1/i = -i
</code></pre>
<pre><code class="language-kleis">:verify complex_inverse(complex(0, 1)) = complex(0, -1)
// ‚úÖ Valid

// z * (1/z) = 1 (for non-zero z)
:verify ‚àÄ(z : ‚ÑÇ). z ‚â† complex(0, 0) ‚üπ complex_mul(z, complex_inverse(z)) = complex(1, 0)
// ‚úÖ Valid
</code></pre>
<h2 id="complex-conjugate"><a class="header" href="#complex-conjugate">Complex Conjugate</a></h2>
<p>The conjugate of <code>a + bi</code> is <code>a - bi</code>:</p>
<pre><code class="language-kleis">define z = complex(3, 4)
define z_bar = conj(z)    // 3 - 4i
</code></pre>
<p>Verification:</p>
<pre><code class="language-kleis">:verify conj(complex(2, 3)) = complex(2, -3)
// ‚úÖ Valid

// Double conjugate is identity
:verify ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
// ‚úÖ Valid

// Conjugate of product
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). conj(complex_mul(z1, z2)) = complex_mul(conj(z1), conj(z2))
// ‚úÖ Valid

// Conjugate of sum
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). conj(complex_add(z1, z2)) = complex_add(conj(z1), conj(z2))
// ‚úÖ Valid
</code></pre>
<h2 id="magnitude-squared"><a class="header" href="#magnitude-squared">Magnitude Squared</a></h2>
<p>The squared magnitude <code>|z|¬≤ = re(z)¬≤ + im(z)¬≤</code>:</p>
<pre><code class="language-kleis">define z = complex(3, 4)
define mag_sq = abs_squared(z)    // 3¬≤ + 4¬≤ = 25
</code></pre>
<pre><code class="language-kleis">:verify abs_squared(complex(3, 4)) = 25
// ‚úÖ Valid

:verify ‚àÄ(z : ‚ÑÇ). abs_squared(z) = re(z) * re(z) + im(z) * im(z)
// ‚úÖ Valid
</code></pre>
<p>Note: Full magnitude <code>|z| = ‚àö(re¬≤ + im¬≤)</code> requires square root, which is not yet supported.</p>
<h2 id="field-properties"><a class="header" href="#field-properties">Field Properties</a></h2>
<p>Complex numbers form a field. Kleis can verify all field axioms:</p>
<h3 id="commutativity"><a class="header" href="#commutativity">Commutativity</a></h3>
<pre><code class="language-kleis">// Addition is commutative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). complex_add(z1, z2) = complex_add(z2, z1)
// ‚úÖ Valid

// Multiplication is commutative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ). complex_mul(z1, z2) = complex_mul(z2, z1)
// ‚úÖ Valid
</code></pre>
<h3 id="associativity"><a class="header" href="#associativity">Associativity</a></h3>
<pre><code class="language-kleis">// Addition is associative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_add(complex_add(z1, z2), z3) = complex_add(z1, complex_add(z2, z3))
// ‚úÖ Valid

// Multiplication is associative
:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_mul(complex_mul(z1, z2), z3) = complex_mul(z1, complex_mul(z2, z3))
// ‚úÖ Valid
</code></pre>
<h3 id="identity-elements"><a class="header" href="#identity-elements">Identity Elements</a></h3>
<pre><code class="language-kleis">// Additive identity: z + 0 = z
:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, complex(0, 0)) = z
// ‚úÖ Valid

// Multiplicative identity: z * 1 = z
:verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, complex(1, 0)) = z
// ‚úÖ Valid
</code></pre>
<h3 id="distributive-law"><a class="header" href="#distributive-law">Distributive Law</a></h3>
<pre><code class="language-kleis">:verify ‚àÄ(z1 : ‚ÑÇ)(z2 : ‚ÑÇ)(z3 : ‚ÑÇ). 
    complex_mul(z1, complex_add(z2, z3)) = 
        complex_add(complex_mul(z1, z2), complex_mul(z1, z3))
// ‚úÖ Valid
</code></pre>
<h2 id="embedding-real-numbers"><a class="header" href="#embedding-real-numbers">Embedding Real Numbers</a></h2>
<p>Real numbers embed into complex numbers with imaginary part 0:</p>
<pre><code class="language-kleis">define r = 5
define z = complex(r, 0)    // 5 + 0i = 5

// Extracting real from embedded real
:verify ‚àÄ(a : ‚Ñù). re(complex(a, 0)) = a
// ‚úÖ Valid

:verify ‚àÄ(a : ‚Ñù). im(complex(a, 0)) = 0
// ‚úÖ Valid
</code></pre>
<p>Adding real and imaginary parts:</p>
<pre><code class="language-kleis">:verify ‚àÄ(x : ‚Ñù)(y : ‚Ñù). complex_add(complex(x, 0), complex(0, y)) = complex(x, y)
// ‚úÖ Valid
</code></pre>
<h2 id="the-multiplication-formula"><a class="header" href="#the-multiplication-formula">The Multiplication Formula</a></h2>
<p>The explicit formula for complex multiplication:</p>
<pre><code class="language-kleis">// (a + bi)(c + di) = (ac - bd) + (ad + bc)i
:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù)(c : ‚Ñù)(d : ‚Ñù). 
    complex_mul(complex(a, b), complex(c, d)) = complex(a*c - b*d, a*d + b*c)
// ‚úÖ Valid
</code></pre>
<h2 id="mixing-symbolic-and-concrete"><a class="header" href="#mixing-symbolic-and-concrete">Mixing Symbolic and Concrete</a></h2>
<p>Kleis can reason about mixed expressions:</p>
<pre><code class="language-kleis">// Symbolic z plus concrete value
:verify ‚àÄ(z : ‚ÑÇ). complex_add(z, complex(0, 0)) = z
// ‚úÖ Valid

// Symbolic z times concrete i
:verify ‚àÄ(z : ‚ÑÇ). complex_mul(z, i) = complex_add(z, complex(0, 1))
// This checks if multiplying by i equals adding i (it doesn't!)
// ‚ùå Invalid ‚Äî as expected!

// Correct: multiplying by i rotates
:verify ‚àÄ(a : ‚Ñù)(b : ‚Ñù). complex_mul(complex(a, b), i) = complex(-b, a)
// ‚úÖ Valid (rotation by 90¬∞)
</code></pre>
<h2 id="the-fundamental-theorem"><a class="header" href="#the-fundamental-theorem">The Fundamental Theorem</a></h2>
<p>The defining property of complex numbers:</p>
<pre><code class="language-kleis">// i¬≤ = -1
:verify complex_mul(i, i) = complex(-1, 0)
// ‚úÖ Valid

// More explicitly
:verify complex_mul(complex(0, 1), complex(0, 1)) = complex(-1, 0)
// ‚úÖ Valid
</code></pre>
<h2 id="convention-loop-indices"><a class="header" href="#convention-loop-indices">Convention: Loop Indices</a></h2>
<p>When using <code>Sum</code> or <code>Product</code> with complex numbers, <strong>avoid using <code>i</code> as a loop index</strong>:</p>
<pre><code class="language-kleis">// GOOD: use k, j, n, m as loop indices
Sum(k, complex_mul(complex(1, 0), pow(z, k)), 0, n)

// BAD: i as loop index clashes with imaginary i
Sum(i, complex_mul(i, pow(z, i)), 0, n)   // Which 'i' is which?
</code></pre>
<p>The convention is:</p>
<ul>
<li><code>k</code>, <code>j</code>, <code>n</code>, <code>m</code> ‚Äî loop indices</li>
<li><code>i</code> ‚Äî imaginary unit</li>
</ul>
<h2 id="complete-example-verifying-complex-identities"><a class="header" href="#complete-example-verifying-complex-identities">Complete Example: Verifying Complex Identities</a></h2>
<p>Here‚Äôs a complete session verifying multiple complex number properties:</p>
<pre><code class="language-kleis">// Define some complex numbers
define z1 : ‚ÑÇ = complex(1, 2)
define z2 : ‚ÑÇ = complex(3, 4)

// Compute operations
define sum = complex_add(z1, z2)
define product = complex_mul(z1, z2)
define i_squared = complex_mul(i, i)

// Structure with axioms
structure ComplexTest {
    axiom i_squared_minus_one : complex_mul(i, i) = complex(-1, 0)
    axiom conj_involution : ‚àÄ(z : ‚ÑÇ). conj(conj(z)) = z
    axiom add_commutes : ‚àÄ(a : ‚ÑÇ)(b : ‚ÑÇ). complex_add(a, b) = complex_add(b, a)
}
</code></pre>
<h2 id="operation-reference"><a class="header" href="#operation-reference">Operation Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Natural Syntax</th><th>Explicit Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Create</td><td><code>a + b*i</code></td><td><code>complex(a, b)</code></td><td>Create a + bi</td></tr>
<tr><td>Real part</td><td>‚Äî</td><td><code>re(z)</code></td><td>Extract real part</td></tr>
<tr><td>Imaginary part</td><td>‚Äî</td><td><code>im(z)</code></td><td>Extract imaginary part</td></tr>
<tr><td>Add</td><td><code>z1 + z2</code></td><td><code>complex_add(z1, z2)</code></td><td>z1 + z2</td></tr>
<tr><td>Subtract</td><td><code>z1 - z2</code></td><td><code>complex_sub(z1, z2)</code></td><td>z1 - z2</td></tr>
<tr><td>Multiply</td><td><code>z1 * z2</code></td><td><code>complex_mul(z1, z2)</code></td><td>z1 √ó z2</td></tr>
<tr><td>Divide</td><td><code>z1 / z2</code></td><td><code>complex_div(z1, z2)</code></td><td>z1 / z2</td></tr>
<tr><td>Negate</td><td><code>-z</code></td><td><code>neg_complex(z)</code></td><td>-z</td></tr>
<tr><td>Inverse</td><td>‚Äî</td><td><code>complex_inverse(z)</code></td><td>1/z</td></tr>
<tr><td>Conjugate</td><td>‚Äî</td><td><code>conj(z)</code></td><td>Complex conjugate</td></tr>
<tr><td>Magnitude¬≤</td><td>‚Äî</td><td><code>abs_squared(z)</code></td><td>|z|¬≤</td></tr>
</tbody>
</table>
</div>
<h2 id="current-limitations"><a class="header" href="#current-limitations">Current Limitations</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Operator overloading</td><td>‚úÖ</td><td><code>z1 + z2</code>, <code>3 + 4*i</code> work!</td></tr>
<tr><td>Magnitude <code>abs(z)</code></td><td>‚ùå</td><td>Requires sqrt</td></tr>
<tr><td>Transcendentals</td><td>‚ùå</td><td><code>exp</code>, <code>log</code>, <code>sin</code>, <code>cos</code></td></tr>
<tr><td>Polar form</td><td>‚ùå</td><td><code>(r, Œ∏)</code></td></tr>
<tr><td>Euler‚Äôs formula</td><td>‚ùå</td><td><code>e^{iŒ∏} = cos(Œ∏) + i¬∑sin(Œ∏)</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-13"><a class="header" href="#whats-next-13">What‚Äôs Next?</a></h2>
<p>Complex numbers enable reasoning about:</p>
<ul>
<li>Signal processing (Fourier transforms)</li>
<li>Quantum mechanics (wave functions)</li>
<li>Control theory (transfer functions)</li>
<li>Complex analysis (contour integrals)</li>
</ul>
<p>‚Üí <a href="#appendix-a-grammar-reference">Next: Grammar Reference</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rational-numbers"><a class="header" href="#rational-numbers">Rational Numbers</a></h1>
<p>Kleis provides complete support for <strong>rational numbers</strong> (‚Ñö), the field of fractions p/q where p and q are integers and q ‚â† 0. Rational arithmetic in Kleis is <strong>exact</strong>‚Äîno floating-point approximation errors.</p>
<h2 id="the-rational-type"><a class="header" href="#the-rational-type">The Rational Type</a></h2>
<p>Kleis recognizes three equivalent notations for the rational type:</p>
<pre><code class="language-kleis">define half : ‚Ñö = rational(1, 2)
define third : Rational = rational(1, 3)
define quarter : Q = rational(1, 4)
</code></pre>
<h2 id="constructing-rationals"><a class="header" href="#constructing-rationals">Constructing Rationals</a></h2>
<p>Use the <code>rational(p, q)</code> constructor to create rational numbers:</p>
<pre><code class="language-kleis">define one_half : ‚Ñö = rational(1, 2)
define two_thirds : ‚Ñö = rational(2, 3)
define negative : ‚Ñö = rational(-3, 4)
</code></pre>
<h3 id="accessors"><a class="header" href="#accessors">Accessors</a></h3>
<p>Extract the numerator and denominator:</p>
<pre><code class="language-kleis">structure RationalAccessors {
    axiom numer_ex : numer(rational(3, 4)) = 3
    axiom denom_ex : denom(rational(3, 4)) = 4
}
</code></pre>
<h2 id="arithmetic-operations-1"><a class="header" href="#arithmetic-operations-1">Arithmetic Operations</a></h2>
<h3 id="basic-arithmetic-1"><a class="header" href="#basic-arithmetic-1">Basic Arithmetic</a></h3>
<p>Kleis supports operator overloading for rationals:</p>
<pre><code class="language-kleis">define sum : ‚Ñö = rational(1, 2) + rational(1, 3)
define diff : ‚Ñö = rational(3, 4) - rational(1, 4)
define prod : ‚Ñö = rational(2, 3) * rational(3, 2)
define quot : ‚Ñö = rational(1, 2) / rational(1, 4)
</code></pre>
<p>These lower to explicit rational operations:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Lowers to</th></tr>
</thead>
<tbody>
<tr><td><code>r1 + r2</code></td><td><code>rational_add(r1, r2)</code></td></tr>
<tr><td><code>r1 - r2</code></td><td><code>rational_sub(r1, r2)</code></td></tr>
<tr><td><code>r1 * r2</code></td><td><code>rational_mul(r1, r2)</code></td></tr>
<tr><td><code>r1 / r2</code></td><td><code>rational_div(r1, r2)</code></td></tr>
<tr><td><code>-r</code></td><td><code>neg_rational(r)</code></td></tr>
</tbody>
</table>
</div>
<h3 id="reciprocal-and-inverse"><a class="header" href="#reciprocal-and-inverse">Reciprocal and Inverse</a></h3>
<pre><code class="language-kleis">structure RationalInverse {
    axiom inv_half : rational_inv(rational(1, 2)) = rational(2, 1)
    axiom inv_def : ‚àÄ(p q : ‚Ñ§). p ‚â† 0 ‚àß q ‚â† 0 ‚Üí 
        rational_inv(rational(p, q)) = rational(q, p)
}
</code></pre>
<h2 id="derived-operations"><a class="header" href="#derived-operations">Derived Operations</a></h2>
<p>Kleis defines several derived operations using conditionals:</p>
<h3 id="sign-absolute-value-min-max"><a class="header" href="#sign-absolute-value-min-max">Sign, Absolute Value, Min, Max</a></h3>
<pre><code class="language-kleis">structure DerivedOps {
    define sign_rational(r : ‚Ñö) : ‚Ñ§ = 
        if rational_lt(r, rational(0, 1)) then 0 - 1
        else if r = rational(0, 1) then 0
        else 1
    
    define abs_rational(r : ‚Ñö) : ‚Ñö = 
        if rational_lt(r, rational(0, 1)) then neg_rational(r) 
        else r
    
    define min_rational(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        if rational_le(r1, r2) then r1 else r2
    
    define max_rational(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        if rational_le(r1, r2) then r2 else r1
    
    define midpoint(r1 : ‚Ñö, r2 : ‚Ñö) : ‚Ñö = 
        rational_div(rational_add(r1, r2), rational(2, 1))
}
</code></pre>
<h2 id="comparison-operations"><a class="header" href="#comparison-operations">Comparison Operations</a></h2>
<p>Rationals are totally ordered:</p>
<pre><code class="language-kleis">structure RationalOrder {
    axiom trichotomy : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚à® r1 = r2 ‚à® rational_gt(r1, r2)
    
    axiom transitive : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_lt(r1, r2) ‚àß rational_lt(r2, r3) ‚Üí rational_lt(r1, r3)
}
</code></pre>
<h3 id="mixed-type-comparisons"><a class="header" href="#mixed-type-comparisons">Mixed-Type Comparisons</a></h3>
<p>Kleis supports comparing rationals with other numeric types:</p>
<pre><code class="language-kleis">structure MixedComparisons {
    // Compare ‚Ñö with ‚Ñï
    axiom half_less_one : rational(1, 2) &lt; 1
    
    // Compare ‚Ñö with ‚Ñ§
    axiom neg_half_less_zero : rational(-1, 2) &lt; 0
}
</code></pre>
<h2 id="type-promotion"><a class="header" href="#type-promotion">Type Promotion</a></h2>
<p>When mixing rationals with other numeric types, Kleis promotes according to:</p>
<pre><code>‚Ñï ‚Üí ‚Ñ§ ‚Üí ‚Ñö ‚Üí ‚Ñù ‚Üí ‚ÑÇ
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">structure TypePromotion {
    // ‚Ñö + ‚Ñ§ ‚Üí ‚Ñö (integer lifted to rational)
    axiom int_plus_rat : rational(1, 2) + 1 = rational(3, 2)
    
    // ‚Ñö + ‚Ñù ‚Üí ‚Ñù (rational becomes real)
    axiom rat_plus_real : rational(1, 2) + 0.5 = 1.0
}
</code></pre>
<h2 id="field-axioms"><a class="header" href="#field-axioms">Field Axioms</a></h2>
<p>Rationals form a <strong>field</strong>‚Äîall the familiar algebraic laws hold:</p>
<pre><code class="language-kleis">structure RationalField {
    // Addition is commutative and associative
    axiom add_comm : ‚àÄ(r1 r2 : ‚Ñö). rational_add(r1, r2) = rational_add(r2, r1)
    axiom add_assoc : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_add(rational_add(r1, r2), r3) = rational_add(r1, rational_add(r2, r3))
    
    // Additive identity and inverse
    axiom add_identity : ‚àÄ(r : ‚Ñö). rational_add(r, rational(0, 1)) = r
    axiom add_inverse : ‚àÄ(r : ‚Ñö). rational_add(r, neg_rational(r)) = rational(0, 1)
    
    // Multiplication is commutative and associative
    axiom mul_comm : ‚àÄ(r1 r2 : ‚Ñö). rational_mul(r1, r2) = rational_mul(r2, r1)
    axiom mul_assoc : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_mul(rational_mul(r1, r2), r3) = rational_mul(r1, rational_mul(r2, r3))
    
    // Multiplicative identity and inverse
    axiom mul_identity : ‚àÄ(r : ‚Ñö). rational_mul(r, rational(1, 1)) = r
    axiom mul_inverse : ‚àÄ(r : ‚Ñö). r ‚â† rational(0, 1) ‚Üí 
        rational_mul(r, rational_inv(r)) = rational(1, 1)
    
    // Distributive law
    axiom distributive : ‚àÄ(r1 r2 r3 : ‚Ñö). 
        rational_mul(r1, rational_add(r2, r3)) = 
        rational_add(rational_mul(r1, r2), rational_mul(r1, r3))
}
</code></pre>
<h2 id="integer-operations"><a class="header" href="#integer-operations">Integer Operations</a></h2>
<h3 id="floor-and-ceiling"><a class="header" href="#floor-and-ceiling">Floor and Ceiling</a></h3>
<p>Convert rationals to integers:</p>
<pre><code class="language-kleis">structure FloorCeil {
    // floor: largest integer ‚â§ r
    axiom floor_def : ‚àÄ(r : ‚Ñö). int_to_rational(floor(r)) ‚â§ r
    
    // ceil: smallest integer ‚â• r
    axiom ceil_def : ‚àÄ(r : ‚Ñö). r ‚â§ int_to_rational(ceil(r))
    
    // Examples
    axiom floor_ex : floor(rational(7, 3)) = 2
    axiom ceil_ex : ceil(rational(7, 3)) = 3
}
</code></pre>
<h3 id="integer-division-and-modulo"><a class="header" href="#integer-division-and-modulo">Integer Division and Modulo</a></h3>
<pre><code class="language-kleis">structure IntDivMod {
    // Division identity: a = (a div b) * b + (a mod b)
    axiom div_mod_id : ‚àÄ(a b : ‚Ñ§). b ‚â† 0 ‚Üí 
        a = int_div(a, b) * b + int_mod(a, b)
    
    // Modulo is non-negative for positive divisor
    axiom mod_nonneg : ‚àÄ(a b : ‚Ñ§). b &gt; 0 ‚Üí 
        int_mod(a, b) ‚â• 0 ‚àß int_mod(a, b) &lt; b
}
</code></pre>
<h3 id="greatest-common-divisor"><a class="header" href="#greatest-common-divisor">Greatest Common Divisor</a></h3>
<p>GCD is defined axiomatically:</p>
<pre><code class="language-kleis">structure GCDAxioms {
    // GCD divides both arguments
    axiom gcd_divides_a : ‚àÄ(a b : ‚Ñ§). int_mod(a, gcd(a, b)) = 0
    axiom gcd_divides_b : ‚àÄ(a b : ‚Ñ§). int_mod(b, gcd(a, b)) = 0
    
    // GCD is the greatest such divisor
    axiom gcd_greatest : ‚àÄ(a b d : ‚Ñ§). 
        (int_mod(a, d) = 0 ‚àß int_mod(b, d) = 0) ‚Üí d ‚â§ gcd(a, b)
    
    // Euclidean algorithm
    axiom gcd_euclidean : ‚àÄ(a b : ‚Ñ§). b ‚â† 0 ‚Üí 
        gcd(a, b) = gcd(b, int_mod(a, b))
}
</code></pre>
<h2 id="density-property"><a class="header" href="#density-property">Density Property</a></h2>
<p>Between any two distinct rationals, there‚Äôs another:</p>
<pre><code class="language-kleis">structure Density {
    axiom density : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚Üí 
        (‚àÉ(r : ‚Ñö). rational_lt(r1, r) ‚àß rational_lt(r, r2))
    
    // The midpoint is always between
    axiom midpoint_between : ‚àÄ(r1 r2 : ‚Ñö). 
        rational_lt(r1, r2) ‚Üí 
        rational_lt(r1, midpoint(r1, r2)) ‚àß rational_lt(midpoint(r1, r2), r2)
}
</code></pre>
<h2 id="z3-verification-1"><a class="header" href="#z3-verification-1">Z3 Verification</a></h2>
<p>Z3 maps rationals to its <code>Real</code> sort, which provides exact rational arithmetic:</p>
<pre><code class="language-kleis">structure Z3Example {
    // This theorem is verified by Z3
    axiom half_plus_half : rational_add(rational(1, 2), rational(1, 2)) = rational(1, 1)
    
    // Field properties are automatically verified
    axiom comm_verified : ‚àÄ(a b : ‚Ñö). rational_add(a, b) = rational_add(b, a)
}
</code></pre>
<h2 id="common-fractions"><a class="header" href="#common-fractions">Common Fractions</a></h2>
<p>The standard library defines convenient names:</p>
<pre><code class="language-kleis">structure CommonFractions {
    axiom half_def : half = rational(1, 2)
    axiom third_def : third = rational(1, 3)
    axiom quarter_def : quarter = rational(1, 4)
    axiom fifth_def : fifth = rational(1, 5)
    axiom tenth_def : tenth = rational(1, 10)
}
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Kleis Support</th></tr>
</thead>
<tbody>
<tr><td>Type notation</td><td><code>‚Ñö</code>, <code>Rational</code>, <code>Q</code></td></tr>
<tr><td>Construction</td><td><code>rational(p, q)</code></td></tr>
<tr><td>Arithmetic</td><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>-</code> (negation)</td></tr>
<tr><td>Comparison</td><td><code>&lt;</code>, <code>‚â§</code>, <code>&gt;</code>, <code>‚â•</code>, <code>=</code>, <code>‚â†</code></td></tr>
<tr><td>Derived ops</td><td><code>sign</code>, <code>abs</code>, <code>min</code>, <code>max</code>, <code>midpoint</code></td></tr>
<tr><td>Integer ops</td><td><code>floor</code>, <code>ceil</code>, <code>int_div</code>, <code>int_mod</code>, <code>gcd</code></td></tr>
<tr><td>Z3 backend</td><td>Native Real sort (exact arithmetic)</td></tr>
</tbody>
</table>
</div>
<p>See <code>stdlib/rational.kleis</code> for the complete axiom set.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="bit-vectors"><a class="header" href="#bit-vectors">Bit-Vectors</a></h1>
<p>Kleis provides support for <strong>bit-vectors</strong>‚Äîfixed-width sequences of bits. Bit-vectors are essential for hardware verification, cryptography, and low-level systems programming.</p>
<h2 id="bourbaki-definition"><a class="header" href="#bourbaki-definition">Bourbaki Definition</a></h2>
<p>Following Bourbaki‚Äôs rigorous style, a bit-vector of width n is defined as:</p>
<blockquote>
<p>A <strong>bit-vector</strong> of width n is a mapping x : [0, n-1] ‚Üí {0, 1}</p>
</blockquote>
<p>Equivalently, it‚Äôs a family (x·µ¢)_{i‚àà[0,n-1]} where each x·µ¢ ‚àà {0, 1}.</p>
<h2 id="the-bitvec-type"><a class="header" href="#the-bitvec-type">The BitVec Type</a></h2>
<pre><code class="language-kleis">define byte : BitVec(8) = bvzero(8)
define word : BitVec(32) = bvzero(32)
define qword : BitVec(64) = bvzero(64)
</code></pre>
<h2 id="mother-structures"><a class="header" href="#mother-structures">Mother Structures</a></h2>
<p>Bit-vectors inherit three fundamental algebraic structures:</p>
<h3 id="1-vector-space-over-ùîΩ‚ÇÇ"><a class="header" href="#1-vector-space-over-ùîΩ‚ÇÇ">1. Vector Space over ùîΩ‚ÇÇ</a></h3>
<p>The set BitVec(n) forms a vector space over the two-element field ùîΩ‚ÇÇ = {0, 1}:</p>
<pre><code class="language-kleis">structure VectorSpaceF2 {
    // XOR is the addition operation
    axiom add_commutative : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvxor(x, y) = bvxor(y, x)
    
    axiom add_associative : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvxor(bvxor(x, y), z) = bvxor(x, bvxor(y, z))
    
    axiom add_identity : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvxor(x, bvzero(n)) = x
    
    // Every element is its own additive inverse!
    axiom add_inverse : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvxor(x, x) = bvzero(n)
}
</code></pre>
<h3 id="2-boolean-algebra"><a class="header" href="#2-boolean-algebra">2. Boolean Algebra</a></h3>
<p>With AND, OR, and NOT, bit-vectors form a Boolean algebra:</p>
<pre><code class="language-kleis">structure BooleanAlgebra {
    // De Morgan's laws
    axiom demorgan_and : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvand(x, y)) = bvor(bvnot(x), bvnot(y))
    
    axiom demorgan_or : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvor(x, y)) = bvand(bvnot(x), bvnot(y))
    
    // Complement laws
    axiom and_complement : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvand(x, bvnot(x)) = bvzero(n)
    
    axiom or_complement : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvor(x, bvnot(x)) = bvones(n)
    
    // Distributive law
    axiom distribute : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvand(x, bvor(y, z)) = bvor(bvand(x, y), bvand(x, z))
}
</code></pre>
<h3 id="3-ordered-set"><a class="header" href="#3-ordered-set">3. Ordered Set</a></h3>
<p>Bit-vectors are totally ordered (both unsigned and signed):</p>
<pre><code class="language-kleis">structure TotalOrder {
    // Trichotomy: exactly one of &lt;, =, &gt; holds
    axiom trichotomy : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvult(x, y) ‚à® x = y ‚à® bvult(y, x)
    
    // Transitivity
    axiom transitive : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvult(x, y) ‚àß bvult(y, z) ‚Üí bvult(x, z)
}
</code></pre>
<h2 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h2>
<h3 id="logical-operations"><a class="header" href="#logical-operations">Logical Operations</a></h3>
<pre><code class="language-kleis">structure BitwiseLogic {
    // AND: set intersection on bit positions
    axiom and_idempotent : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvand(x, x) = x
    
    // OR: set union on bit positions  
    axiom or_idempotent : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvor(x, x) = x
    
    // XOR: symmetric difference
    axiom xor_self : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvxor(x, x) = bvzero(n)
    
    // NOT: complement
    axiom not_involution : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvnot(bvnot(x)) = x
}
</code></pre>
<h3 id="available-operations"><a class="header" href="#available-operations">Available Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>AND</td><td><code>bvand(x, y)</code></td><td>Bitwise AND</td></tr>
<tr><td>OR</td><td><code>bvor(x, y)</code></td><td>Bitwise OR</td></tr>
<tr><td>XOR</td><td><code>bvxor(x, y)</code></td><td>Bitwise XOR</td></tr>
<tr><td>NOT</td><td><code>bvnot(x)</code></td><td>Bitwise complement</td></tr>
</tbody>
</table>
</div>
<h2 id="arithmetic-operations-2"><a class="header" href="#arithmetic-operations-2">Arithmetic Operations</a></h2>
<p>Bit-vector arithmetic is <strong>modular</strong> (mod 2‚Åø):</p>
<pre><code class="language-kleis">structure ModularArithmetic {
    // Addition wraps around
    axiom add_commutative : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvadd(x, y) = bvadd(y, x)
    
    axiom add_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvadd(x, bvzero(n)) = x
    
    // Two's complement negation
    axiom neg_inverse : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvadd(x, bvneg(x)) = bvzero(n)
    
    // Multiplication distributes
    axiom mul_distribute : ‚àÄ(n : ‚Ñï)(x y z : BitVec(n)).
        bvmul(x, bvadd(y, z)) = bvadd(bvmul(x, y), bvmul(x, z))
}
</code></pre>
<h3 id="available-operations-1"><a class="header" href="#available-operations-1">Available Operations</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Add</td><td><code>bvadd(x, y)</code></td><td>Addition mod 2‚Åø</td></tr>
<tr><td>Subtract</td><td><code>bvsub(x, y)</code></td><td>Subtraction mod 2‚Åø</td></tr>
<tr><td>Multiply</td><td><code>bvmul(x, y)</code></td><td>Multiplication mod 2‚Åø</td></tr>
<tr><td>Negate</td><td><code>bvneg(x)</code></td><td>Two‚Äôs complement negation</td></tr>
<tr><td>Unsigned div</td><td><code>bvudiv(x, y)</code></td><td>Unsigned division</td></tr>
<tr><td>Signed div</td><td><code>bvsdiv(x, y)</code></td><td>Signed division</td></tr>
<tr><td>Unsigned rem</td><td><code>bvurem(x, y)</code></td><td>Unsigned remainder</td></tr>
</tbody>
</table>
</div>
<h2 id="shift-operations"><a class="header" href="#shift-operations">Shift Operations</a></h2>
<pre><code class="language-kleis">structure ShiftOps {
    // Left shift: multiply by 2·µè
    axiom shl_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvshl(x, bvzero(n)) = x
    
    // Logical right shift: divide by 2·µè (zero fill)
    axiom lshr_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvlshr(x, bvzero(n)) = x
    
    // Arithmetic right shift: divide by 2·µè (sign extend)
    axiom ashr_zero : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvashr(x, bvzero(n)) = x
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Left shift</td><td><code>bvshl(x, k)</code></td><td>Shift left by k bits</td></tr>
<tr><td>Logical right</td><td><code>bvlshr(x, k)</code></td><td>Shift right, zero fill</td></tr>
<tr><td>Arithmetic right</td><td><code>bvashr(x, k)</code></td><td>Shift right, sign extend</td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-operations-1"><a class="header" href="#comparison-operations-1">Comparison Operations</a></h2>
<h3 id="unsigned-comparisons"><a class="header" href="#unsigned-comparisons">Unsigned Comparisons</a></h3>
<pre><code class="language-kleis">structure UnsignedCompare {
    axiom zero_minimum : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvule(bvzero(n), x)
    
    axiom ones_maximum : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bvule(x, bvones(n))
}
</code></pre>
<h3 id="signed-comparisons"><a class="header" href="#signed-comparisons">Signed Comparisons</a></h3>
<pre><code class="language-kleis">structure SignedCompare {
    // In two's complement, high bit indicates negative
    axiom signed_negative : ‚àÄ(n : ‚Ñï)(x : BitVec(n)).
        bit(x, n - 1) = 1 ‚Üí bvslt(x, bvzero(n))
}
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unsigned</th><th>Signed</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>bvult(x, y)</code></td><td><code>bvslt(x, y)</code></td><td>Less than</td></tr>
<tr><td><code>bvule(x, y)</code></td><td><code>bvsle(x, y)</code></td><td>Less or equal</td></tr>
<tr><td><code>bvugt(x, y)</code></td><td><code>bvsgt(x, y)</code></td><td>Greater than</td></tr>
<tr><td><code>bvuge(x, y)</code></td><td><code>bvsge(x, y)</code></td><td>Greater or equal</td></tr>
</tbody>
</table>
</div>
<h2 id="construction-and-extraction"><a class="header" href="#construction-and-extraction">Construction and Extraction</a></h2>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<pre><code class="language-kleis">structure Constants {
    // Zero vector (all bits 0)
    axiom zero_all : ‚àÄ(n : ‚Ñï)(i : ‚Ñï). i &lt; n ‚Üí bit(bvzero(n), i) = 0
    
    // Ones vector (all bits 1)
    axiom ones_all : ‚àÄ(n : ‚Ñï)(i : ‚Ñï). i &lt; n ‚Üí bit(bvones(n), i) = 1
    
    // Single 1 in lowest position
    axiom one_bit : bit(bvone(8), 0) = 1
}
</code></pre>
<h3 id="bit-extraction"><a class="header" href="#bit-extraction">Bit Extraction</a></h3>
<pre><code class="language-kleis">structure BitExtraction {
    // Get individual bit
    axiom bit_range : ‚àÄ(n : ‚Ñï)(x : BitVec(n))(i : ‚Ñï). 
        i &lt; n ‚Üí (bit(x, i) = 0 ‚à® bit(x, i) = 1)
    
    // Extract slice [high:low]
    axiom extract_width : ‚àÄ(n high low : ‚Ñï)(x : BitVec(n)).
        high ‚â• low ‚àß high &lt; n ‚Üí width(extract(high, low, x)) = high - low + 1
}
</code></pre>
<h3 id="extension"><a class="header" href="#extension">Extension</a></h3>
<pre><code class="language-kleis">structure Extension {
    // Zero extension (for unsigned)
    axiom zext_preserves : ‚àÄ(n m : ‚Ñï)(x : BitVec(n)).
        m ‚â• n ‚Üí bvult(x, bvzero(n)) = bvult(zext(m, x), bvzero(m))
    
    // Sign extension (for signed)
    axiom sext_preserves : ‚àÄ(n m : ‚Ñï)(x : BitVec(n)).
        m ‚â• n ‚Üí bvslt(x, bvzero(n)) = bvslt(sext(m, x), bvzero(m))
}
</code></pre>
<h2 id="z3-verification-2"><a class="header" href="#z3-verification-2">Z3 Verification</a></h2>
<p>Kleis maps bit-vector operations directly to Z3‚Äôs native BitVec theory:</p>
<pre><code class="language-kleis">structure Z3BitVecExample {
    // XOR properties verified by Z3
    axiom xor_cancel : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvxor(x, x) = bvzero(n)
    
    // De Morgan verified
    axiom demorgan : ‚àÄ(n : ‚Ñï)(x y : BitVec(n)).
        bvnot(bvand(x, y)) = bvor(bvnot(x), bvnot(y))
    
    // Arithmetic properties
    axiom add_neg : ‚àÄ(n : ‚Ñï)(x : BitVec(n)). bvadd(x, bvneg(x)) = bvzero(n)
}
</code></pre>
<h2 id="example-cryptographic-rotation"><a class="header" href="#example-cryptographic-rotation">Example: Cryptographic Rotation</a></h2>
<pre><code class="language-kleis">structure RotateExample {
    // Left rotation by k bits
    define rotl(n : ‚Ñï, x : BitVec(n), k : BitVec(n)) : BitVec(n) =
        bvor(bvshl(x, k), bvlshr(x, bvsub(bvone(n) * n, k)))
    
    // Right rotation by k bits
    define rotr(n : ‚Ñï, x : BitVec(n), k : BitVec(n)) : BitVec(n) =
        bvor(bvlshr(x, k), bvshl(x, bvsub(bvone(n) * n, k)))
    
    // Rotation is its own inverse
    axiom rotate_inverse : ‚àÄ(n k : ‚Ñï)(x : BitVec(n)).
        rotr(n, rotl(n, x, k), k) = x
}
</code></pre>
<h2 id="example-bit-manipulation"><a class="header" href="#example-bit-manipulation">Example: Bit Manipulation</a></h2>
<pre><code class="language-kleis">structure BitManipulation {
    // Set bit i to 1
    define set_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvor(x, bvshl(bvone(n), i))
    
    // Clear bit i to 0
    define clear_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvand(x, bvnot(bvshl(bvone(n), i)))
    
    // Toggle bit i
    define toggle_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : BitVec(n) =
        bvxor(x, bvshl(bvone(n), i))
    
    // Test if bit i is set
    define test_bit(n : ‚Ñï, x : BitVec(n), i : BitVec(n)) : Bool =
        bvand(x, bvshl(bvone(n), i)) ‚â† bvzero(n)
}
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Operations</th></tr>
</thead>
<tbody>
<tr><td><strong>Bitwise</strong></td><td><code>bvand</code>, <code>bvor</code>, <code>bvxor</code>, <code>bvnot</code></td></tr>
<tr><td><strong>Arithmetic</strong></td><td><code>bvadd</code>, <code>bvsub</code>, <code>bvmul</code>, <code>bvneg</code>, <code>bvudiv</code>, <code>bvsdiv</code>, <code>bvurem</code></td></tr>
<tr><td><strong>Shift</strong></td><td><code>bvshl</code>, <code>bvlshr</code>, <code>bvashr</code></td></tr>
<tr><td><strong>Unsigned compare</strong></td><td><code>bvult</code>, <code>bvule</code>, <code>bvugt</code>, <code>bvuge</code></td></tr>
<tr><td><strong>Signed compare</strong></td><td><code>bvslt</code>, <code>bvsle</code>, <code>bvsgt</code>, <code>bvsge</code></td></tr>
<tr><td><strong>Construction</strong></td><td><code>bvzero</code>, <code>bvones</code>, <code>bvone</code>, <code>extract</code>, <code>zext</code>, <code>sext</code></td></tr>
</tbody>
</table>
</div>
<p>See <code>stdlib/bitvector.kleis</code> for the complete axiom set.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Kleis provides comprehensive support for <strong>string operations</strong> via Z3‚Äôs QF_SLIA (Quantifier-Free Strings and Linear Integer Arithmetic) theory. This enables formal verification of string-manipulating programs.</p>
<h2 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h2>
<pre><code class="language-kleis">define greeting : String = "Hello, World!"
define empty : String = ""
</code></pre>
<h2 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h2>
<h3 id="concatenation"><a class="header" href="#concatenation">Concatenation</a></h3>
<pre><code class="language-kleis">structure StringConcat {
    // Concatenation
    axiom concat_ex : concat("Hello", " World") = "Hello World"
    
    // Empty string is identity
    axiom concat_empty_left : ‚àÄ(s : String). concat("", s) = s
    axiom concat_empty_right : ‚àÄ(s : String). concat(s, "") = s
    
    // Associativity
    axiom concat_assoc : ‚àÄ(a b c : String). 
        concat(concat(a, b), c) = concat(a, concat(b, c))
}
</code></pre>
<h3 id="length"><a class="header" href="#length">Length</a></h3>
<pre><code class="language-kleis">structure StringLength {
    axiom len_hello : strlen("Hello") = 5
    axiom len_empty : strlen("") = 0
    
    // Length of concatenation
    axiom len_concat : ‚àÄ(a b : String). 
        strlen(concat(a, b)) = strlen(a) + strlen(b)
    
    // Length is non-negative
    axiom len_nonneg : ‚àÄ(s : String). strlen(s) ‚â• 0
}
</code></pre>
<h2 id="substring-operations"><a class="header" href="#substring-operations">Substring Operations</a></h2>
<h3 id="contains"><a class="header" href="#contains">Contains</a></h3>
<p>Check if one string contains another:</p>
<pre><code class="language-kleis">structure StringContains {
    axiom contains_ex : contains("Hello World", "World") = true
    axiom contains_empty : ‚àÄ(s : String). contains(s, "") = true
    axiom contains_self : ‚àÄ(s : String). contains(s, s) = true
}
</code></pre>
<h3 id="prefix-and-suffix"><a class="header" href="#prefix-and-suffix">Prefix and Suffix</a></h3>
<pre><code class="language-kleis">structure PrefixSuffix {
    // Prefix check
    axiom prefix_ex : hasPrefix("Hello World", "Hello") = true
    axiom prefix_empty : ‚àÄ(s : String). hasPrefix(s, "") = true
    
    // Suffix check
    axiom suffix_ex : hasSuffix("Hello World", "World") = true
    axiom suffix_empty : ‚àÄ(s : String). hasSuffix(s, "") = true
}
</code></pre>
<h3 id="substring-extraction"><a class="header" href="#substring-extraction">Substring Extraction</a></h3>
<pre><code class="language-kleis">structure Substring {
    // substr(s, start, length) extracts substring
    axiom substr_ex : substr("Hello World", 0, 5) = "Hello"
    axiom substr_middle : substr("Hello World", 6, 5) = "World"
    
    // Empty substring
    axiom substr_zero : ‚àÄ(s : String)(i : ‚Ñï). substr(s, i, 0) = ""
}
</code></pre>
<h3 id="character-access"><a class="header" href="#character-access">Character Access</a></h3>
<pre><code class="language-kleis">structure CharAt {
    // charAt(s, i) returns single character at index i
    axiom charAt_ex : charAt("Hello", 0) = "H"
    axiom charAt_last : charAt("Hello", 4) = "o"
}
</code></pre>
<h3 id="index-of"><a class="header" href="#index-of">Index Of</a></h3>
<pre><code class="language-kleis">structure IndexOf {
    // indexOf(s, pattern, start) returns first index of pattern
    axiom indexOf_ex : indexOf("Hello World", "o", 0) = 4
    axiom indexOf_second : indexOf("Hello World", "o", 5) = 7
    
    // Not found returns -1
    axiom indexOf_notfound : indexOf("Hello", "z", 0) = 0 - 1
}
</code></pre>
<h3 id="replace"><a class="header" href="#replace">Replace</a></h3>
<pre><code class="language-kleis">structure StringReplace {
    // replace(s, old, new) replaces first occurrence
    axiom replace_ex : replace("Hello World", "World", "Kleis") = "Hello Kleis"
    
    // No match means no change
    axiom replace_nomatch : ‚àÄ(s : String). 
        ¬¨contains(s, "xyz") ‚Üí replace(s, "xyz", "abc") = s
}
</code></pre>
<h2 id="string-integer-conversion"><a class="header" href="#string-integer-conversion">String-Integer Conversion</a></h2>
<h3 id="string-to-integer"><a class="header" href="#string-to-integer">String to Integer</a></h3>
<pre><code class="language-kleis">structure StrToInt {
    axiom str_to_int_ex : strToInt("42") = 42
    axiom str_to_int_neg : strToInt("-17") = 0 - 17
    axiom str_to_int_zero : strToInt("0") = 0
}
</code></pre>
<h3 id="integer-to-string"><a class="header" href="#integer-to-string">Integer to String</a></h3>
<pre><code class="language-kleis">structure IntToStr {
    axiom int_to_str_ex : intToStr(42) = "42"
    axiom int_to_str_neg : intToStr(0 - 17) = "-17"
    axiom int_to_str_zero : intToStr(0) = "0"
}
</code></pre>
<h3 id="round-trip-property"><a class="header" href="#round-trip-property">Round-trip Property</a></h3>
<pre><code class="language-kleis">structure Roundtrip {
    // Converting back and forth preserves value
    axiom roundtrip_int : ‚àÄ(n : ‚Ñ§). strToInt(intToStr(n)) = n
    
    // For valid numeric strings
    axiom roundtrip_str : ‚àÄ(s : String). 
        isDigits(s) ‚Üí intToStr(strToInt(s)) = s
}
</code></pre>
<h2 id="regular-expressions"><a class="header" href="#regular-expressions">Regular Expressions</a></h2>
<p>Kleis supports regular expression matching via Z3‚Äôs regex theory:</p>
<pre><code class="language-kleis">structure RegexMatch {
    // Check if string matches pattern
    axiom digits_match : matchesRegex("12345", "[0-9]+") = true
    axiom alpha_match : matchesRegex("Hello", "[A-Za-z]+") = true
    
    // Built-in character class predicates
    axiom is_digits : isDigits("12345") = true
    axiom is_alpha : isAlpha("Hello") = true
    axiom is_alphanum : isAlphaNum("Test123") = true
}
</code></pre>
<h2 id="z3-verification-3"><a class="header" href="#z3-verification-3">Z3 Verification</a></h2>
<p>String properties are verified using Z3‚Äôs native string theory:</p>
<pre><code class="language-kleis">structure Z3StringProofs {
    // Concatenation properties
    axiom concat_length : ‚àÄ(a b : String). 
        strlen(concat(a, b)) = strlen(a) + strlen(b)
    
    // Contains implies length relationship
    axiom contains_length : ‚àÄ(s t : String). 
        contains(s, t) ‚Üí strlen(s) ‚â• strlen(t)
    
    // Prefix implies contains
    axiom prefix_contains : ‚àÄ(s t : String). 
        hasPrefix(s, t) ‚Üí contains(s, t)
}
</code></pre>
<h2 id="monoid-structure"><a class="header" href="#monoid-structure">Monoid Structure</a></h2>
<p>Strings form a <strong>monoid</strong> under concatenation:</p>
<pre><code class="language-kleis">implements Monoid(String) {
    operation identity = ""
    operation mul = concat
}

// Monoid laws hold:
// 1. concat("", s) = s           (left identity)
// 2. concat(s, "") = s           (right identity)
// 3. concat(a, concat(b, c)) 
//    = concat(concat(a, b), c)   (associativity)
</code></pre>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="email-validation"><a class="header" href="#email-validation">Email Validation</a></h3>
<pre><code class="language-kleis">structure EmailValidation {
    define isValidEmail(email : String) : Bool =
        contains(email, "@") ‚àß 
        contains(email, ".") ‚àß
        indexOf(email, "@", 0) &lt; indexOf(email, ".", 0)
    
    axiom valid_ex : isValidEmail("user@example.com") = true
    axiom invalid_ex : isValidEmail("invalid") = false
}
</code></pre>
<h3 id="url-parsing"><a class="header" href="#url-parsing">URL Parsing</a></h3>
<pre><code class="language-kleis">structure URLParsing {
    define getProtocol(url : String) : String =
        substr(url, 0, indexOf(url, "://", 0))
    
    axiom http_ex : getProtocol("https://kleis.io") = "https"
}
</code></pre>
<h3 id="string-builder-pattern"><a class="header" href="#string-builder-pattern">String Builder Pattern</a></h3>
<pre><code class="language-kleis">structure StringBuilder {
    define join(sep : String, a : String, b : String) : String =
        concat(concat(a, sep), b)
    
    axiom join_ex : join(", ", "Hello", "World") = "Hello, World"
}
</code></pre>
<h2 id="operation-reference-1"><a class="header" href="#operation-reference-1">Operation Reference</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Concatenate</td><td><code>concat(a, b)</code></td><td>Join two strings</td></tr>
<tr><td>Length</td><td><code>strlen(s)</code></td><td>Character count</td></tr>
<tr><td>Contains</td><td><code>contains(s, t)</code></td><td>Check substring</td></tr>
<tr><td>Prefix</td><td><code>hasPrefix(s, t)</code></td><td>Check prefix</td></tr>
<tr><td>Suffix</td><td><code>hasSuffix(s, t)</code></td><td>Check suffix</td></tr>
<tr><td>Substring</td><td><code>substr(s, i, n)</code></td><td>Extract n chars from i</td></tr>
<tr><td>Character</td><td><code>charAt(s, i)</code></td><td>Get char at index</td></tr>
<tr><td>Index</td><td><code>indexOf(s, t, i)</code></td><td>Find substring from i</td></tr>
<tr><td>Replace</td><td><code>replace(s, old, new)</code></td><td>Replace first match</td></tr>
<tr><td>To Int</td><td><code>strToInt(s)</code></td><td>Parse integer</td></tr>
<tr><td>From Int</td><td><code>intToStr(n)</code></td><td>Format integer</td></tr>
<tr><td>Regex</td><td><code>matchesRegex(s, r)</code></td><td>Match pattern</td></tr>
</tbody>
</table>
</div>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td>Basic operations</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Substring ops</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Regex matching</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Int conversion</td><td>‚úÖ Native Z3</td></tr>
<tr><td>Monoid structure</td><td>‚úÖ Algebraic</td></tr>
</tbody>
</table>
</div>
<p>See <code>src/solvers/z3/capabilities.toml</code> for the complete list of supported string operations.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-a-grammar-reference"><a class="header" href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a></h1>
<p>This appendix provides a reference to Kleis syntax based on the formal grammar specification (v0.9).</p>
<blockquote>
<p><strong>Complete Grammar:</strong> See <code>docs/grammar/kleis_grammar_v09.md</code> for the full specification.</p>
</blockquote>
<h2 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h2>
<pre><code class="language-ebnf">program ::= { declaration }

declaration ::= importDecl              // v0.8: Module imports
              | libraryAnnotation
              | versionAnnotation
              | structureDef
              | implementsDef
              | dataDef
              | functionDef
              | operationDecl
              | typeAlias
</code></pre>
<h2 id="import-statements-v08"><a class="header" href="#import-statements-v08">Import Statements (v0.8)</a></h2>
<pre><code class="language-ebnf">importDecl ::= "import" string
</code></pre>
<p>Example:</p>
<pre><code class="language-text">import "stdlib/prelude.kleis"
import "stdlib/complex.kleis"
</code></pre>
<h2 id="annotations"><a class="header" href="#annotations">Annotations</a></h2>
<pre><code class="language-ebnf">libraryAnnotation ::= "@library" "(" string ")"
versionAnnotation ::= "@version" "(" string ")"
</code></pre>
<p>Example:</p>
<pre><code class="language-text">@library("stdlib/algebra")
@version("0.7")
</code></pre>
<h2 id="data-type-definitions"><a class="header" href="#data-type-definitions">Data Type Definitions</a></h2>
<pre><code class="language-ebnf">dataDef ::= "data" identifier [ "(" typeParams ")" ] "="
            dataVariant { "|" dataVariant }

dataVariant ::= identifier [ "(" dataFields ")" ]

dataField ::= identifier ":" type    // Named field
            | type                   // Positional field
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">data Bool {
    True
    False
}
data Option(T) {
    None
    Some(value : T)
}
</code></pre>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<pre><code class="language-ebnf">matchExpr ::= "match" expression "{" matchCases "}"

matchCase ::= pattern [ "if" guardExpression ] "=&gt;" expression   // v0.8: guards

pattern ::= basePattern [ "as" identifier ]  // v0.8: as-patterns

basePattern ::= "_"                              // Wildcard
              | identifier                       // Variable
              | identifier [ "(" patternArgs ")" ]  // Constructor
              | number | string | boolean        // Constant
              | tuplePattern                     // v0.8: Tuple sugar

tuplePattern ::= "()"                            // Unit
               | "(" pattern "," pattern { "," pattern } ")"  // Pair, Tuple3, etc.
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">match x { True =&gt; 1 | False =&gt; 0 }
match opt { None =&gt; 0 | Some(x) =&gt; x }
match result { Ok(Some(x)) =&gt; x | Ok(None) =&gt; 0 | Err(_) =&gt; -1 }

// v0.8: Pattern guards
match n { x if x &lt; 0 =&gt; "negative" | x if x &gt; 0 =&gt; "positive" | _ =&gt; "zero" }

// v0.8: As-patterns
match list { Cons(h, t) as whole =&gt; process(whole) | Nil =&gt; empty }
</code></pre>
<h2 id="structure-definitions"><a class="header" href="#structure-definitions">Structure Definitions</a></h2>
<pre><code class="language-ebnf">structureDef ::= "structure" identifier "(" typeParams ")"
                 [ extendsClause ] [ overClause ]
                 "{" { structureMember } "}"

extendsClause ::= "extends" identifier [ "(" typeArgs ")" ]
overClause ::= "over" "Field" "(" type ")"

structureMember ::= operationDecl
                  | elementDecl
                  | axiomDecl
                  | nestedStructure
                  | functionDef
</code></pre>
<p>Example:</p>
<pre><code class="language-text">structure VectorSpace(V) over Field(F) extends AbelianGroup(V) {
    operation (¬∑) : F √ó V ‚Üí V
    
    axiom scalar_distributive : ‚àÄ(a : F)(b : F)(v : V).
        (a + b) ¬∑ v = a ¬∑ v + b ¬∑ v
}
</code></pre>
<h2 id="implements-1"><a class="header" href="#implements-1">Implements</a></h2>
<pre><code class="language-ebnf">implementsDef ::= "implements" identifier "(" typeArgs ")"
                  [ overClause ]
                  [ "{" { implMember } "}" ]

implMember ::= elementImpl | operationImpl | verifyStmt

operationImpl ::= "operation" operatorSymbol "=" implementation
                | "operation" operatorSymbol "(" params ")" "=" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-text">implements Ring(‚Ñù) {
    operation add = builtin_add
    operation mul = builtin_mul
    element zero = 0
    element one = 1
}
</code></pre>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<pre><code class="language-ebnf">functionDef ::= "define" identifier [ typeAnnotation ] "=" expression
              | "define" identifier "(" params ")" [ ":" type ] "=" expression

param ::= identifier [ ":" type ]
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">define pi = 3.14159
define square(x) = x * x
define add(x: ‚Ñù, y: ‚Ñù) : ‚Ñù = x + y
</code></pre>
<h2 id="type-system"><a class="header" href="#type-system">Type System</a></h2>
<pre><code class="language-ebnf">type ::= primitiveType
       | parametricType
       | functionType
       | typeVariable
       | "(" type ")"

primitiveType ::= "‚Ñù" | "‚ÑÇ" | "‚Ñ§" | "‚Ñï" | "‚Ñö"
                | "Real" | "Complex" | "Integer" | "Nat" | "Rational"
                | "Bool" | "String" | "Unit"

parametricType ::= identifier "(" typeArgs ")"
                 | "BitVec" "(" number ")"      // Fixed-size bit vectors

functionType ::= type "‚Üí" type | type "-&gt;" type

typeAlias ::= "type" identifier "=" type
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">‚Ñù                    // Real numbers
Vector(3)            // Parameterized type
‚Ñù ‚Üí ‚Ñù               // Function type
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù         // Higher-order function
type RealFunc = ‚Ñù ‚Üí ‚Ñù  // Type alias
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<pre><code class="language-ebnf">expression ::= primary
             | matchExpr
             | prefixOp expression
             | expression postfixOp
             | expression infixOp expression
             | expression "(" [ arguments ] ")"
             | "[" [ expressions ] "]"           // List literal
             | lambda
             | letBinding
             | conditional

primary ::= identifier | number | string | symbolicConstant
          | "(" expression ")" | placeholder

symbolicConstant ::= "œÄ" | "e" | "i" | "‚Ñè" | "c" | "œÜ" | "‚àû" | "‚àÖ"

placeholder ::= "‚ñ°"
</code></pre>
<h2 id="lambda-expressions-1"><a class="header" href="#lambda-expressions-1">Lambda Expressions</a></h2>
<pre><code class="language-ebnf">lambda ::= "Œª" params "." expression
         | "lambda" params "." expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">Œª x . x + 1              // Simple lambda
Œª x y . x * y            // Multiple parameters
Œª (x : ‚Ñù) . x^2          // With type annotation
lambda x . x             // Using keyword
</code></pre>
<h2 id="let-bindings-1"><a class="header" href="#let-bindings-1">Let Bindings</a></h2>
<pre><code class="language-ebnf">letBinding ::= "let" pattern [ typeAnnotation ] "=" expression "in" expression
// Note: typeAnnotation only valid when pattern is a simple Variable
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">let x = 5 in x + x
let x : ‚Ñù = 3.14 in x * 2
let s = (a + b + c) / 2 in sqrt(s * (s-a) * (s-b) * (s-c))

// v0.8: Let destructuring
let Point(x, y) = origin in x^2 + y^2
let Some(Pair(a, b)) = opt in a + b
let Cons(h, _) = list in h
</code></pre>
<h2 id="conditionals-1"><a class="header" href="#conditionals-1">Conditionals</a></h2>
<pre><code class="language-ebnf">conditional ::= "if" expression "then" expression "else" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-text">if x &gt; 0 then x else -x
</code></pre>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<pre><code class="language-ebnf">forAllProp ::= ("‚àÄ" | "forall") variables [ whereClause ] "." proposition
existsProp ::= ("‚àÉ" | "exists") variables [ whereClause ] "." proposition

varDecl ::= identifier [ ":" type ]
          | identifier "‚àà" type
          | "(" identifier { identifier } ":" type ")"

whereClause ::= "where" expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">‚àÄ(x : ‚Ñù). x + 0 = x
‚àÉ(x : ‚Ñ§). x * x = 4
‚àÄ(a : ‚Ñù)(b : ‚Ñù) where a ‚â† 0 . a * (1/a) = 1
</code></pre>
<h2 id="v09-enhancements"><a class="header" href="#v09-enhancements">v0.9 Enhancements</a></h2>
<h3 id="nested-quantifiers-in-expressions"><a class="header" href="#nested-quantifiers-in-expressions">Nested Quantifiers in Expressions</a></h3>
<p>Quantifiers can now appear as operands in logical expressions:</p>
<pre><code class="language-text">// v0.9: Quantifier inside conjunction
axiom nested: (x &gt; 0) ‚àß (‚àÄ(y : ‚Ñù). y &gt; 0)

// Epsilon-delta limit definition
axiom epsilon_delta: ‚àÄ(Œµ : ‚Ñù). Œµ &gt; 0 ‚Üí 
    (‚àÉ(Œ¥ : ‚Ñù). Œ¥ &gt; 0 ‚àß (‚àÄ(x : ‚Ñù). abs(x - a) &lt; Œ¥ ‚Üí abs(f(x) - L) &lt; Œµ))
</code></pre>
<h3 id="function-types-in-type-annotations"><a class="header" href="#function-types-in-type-annotations">Function Types in Type Annotations</a></h3>
<p>Function types are now allowed in quantifier variable declarations:</p>
<pre><code class="language-text">// Function from reals to reals
axiom func: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù). f(0) = f(0)

// Higher-order function
axiom compose: ‚àÄ(f : ‚Ñù ‚Üí ‚Ñù, g : ‚Ñù ‚Üí ‚Ñù). compose(f, g) = Œª x . f(g(x))

// Topology: continuity via preimages
axiom continuity: ‚àÄ(f : X ‚Üí Y, V : Set(Y)). 
    is_open(V) ‚Üí is_open(preimage(f, V))
</code></pre>
<h2 id="calculus-notation-v07"><a class="header" href="#calculus-notation-v07">Calculus Notation (v0.7)</a></h2>
<p>Kleis uses Mathematica-style notation for calculus operations:</p>
<pre><code class="language-ebnf">// Derivatives (function calls)
D(f, x)              // Partial derivative ‚àÇf/‚àÇx
D(f, x, y)           // Mixed partial ‚àÇ¬≤f/‚àÇx‚àÇy
D(f, {x, n})         // nth derivative ‚àÇ‚Åøf/‚àÇx‚Åø
Dt(f, x)             // Total derivative df/dx

// Integrals
Integrate(f, x)           // Indefinite ‚à´f dx
Integrate(f, x, a, b)     // Definite ‚à´[a,b] f dx

// Sums and Products
Sum(expr, i, 1, n)        // Œ£·µ¢‚Çå‚ÇÅ‚Åø expr
Product(expr, i, 1, n)    // Œ†·µ¢‚Çå‚ÇÅ‚Åø expr

// Limits
Limit(f, x, a)            // lim_{x‚Üía} f
</code></pre>
<p>Note: Legacy notation like <code>‚àÇf/‚àÇx</code> and <code>df/dx</code> is deprecated. Use <code>D(f, x)</code> and <code>Dt(f, x)</code> instead.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<h3 id="prefix-operators"><a class="header" href="#prefix-operators">Prefix Operators</a></h3>
<pre><code class="language-ebnf">prefixOp ::= "-" | "¬¨" | "‚àá" | "‚àö" | "‚à´" | "‚à¨" | "‚à≠" | "‚àÆ" | "‚àØ"
</code></pre>
<h3 id="postfix-operators"><a class="header" href="#postfix-operators">Postfix Operators</a></h3>
<pre><code class="language-ebnf">postfixOp ::= "!" | "‚Ä†" | "*" | "·µÄ" | "^T" | "^‚Ä†"
</code></pre>
<h3 id="infix-operators-by-precedence-low-to-high"><a class="header" href="#infix-operators-by-precedence-low-to-high">Infix Operators (by precedence, low to high)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code> (biconditional)</td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code> (implication)</td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code> <code>or</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code> <code>and</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code> <code>not</code> (prefix)</td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>==</code> <code>‚â†</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>‚â•</code></td><td>Non-assoc</td></tr>
<tr><td>7</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>*</code> <code>√ó</code> <code>/</code> <code>¬∑</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>^</code></td><td>Right</td></tr>
<tr><td>10</td><td><code>-</code> (unary)</td><td>Prefix</td></tr>
<tr><td>11</td><td>Postfix (<code>!</code>, <code>·µÄ</code>, <code>‚Ä†</code>)</td><td>Postfix</td></tr>
<tr><td>12</td><td>Function application</td><td>Left</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> Set operators (<code>‚àà</code>, <code>‚àâ</code>, <code>‚äÜ</code>, <code>‚âà</code>, <code>‚â°</code>) are not implemented. Use function-call syntax instead.</p>
</blockquote>
<h2 id="comments-1"><a class="header" href="#comments-1">Comments</a></h2>
<pre><code class="language-ebnf">lineComment ::= "//" { any character except newline } newline
blockComment ::= "/*" { any character } "*/"
</code></pre>
<p><strong>Note:</strong> Kleis uses C-style comments (<code>//</code> and <code>/* */</code>), not Haskell-style (<code>--</code> and <code>{- -}</code>).</p>
<h2 id="unicode-equivalents"><a class="header" href="#unicode-equivalents">Unicode Equivalents</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td><td>Universal quantifier</td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td><td>Existential quantifier</td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td><td>Function type / implies</td></tr>
<tr><td><code>√ó</code></td><td><code>*</code></td><td>Product type / multiplication</td></tr>
<tr><td><code>‚àß</code></td><td><code>and</code>, <code>/\</code></td><td>Logical and</td></tr>
<tr><td><code>‚à®</code></td><td><code>or</code>, <code>\/</code></td><td>Logical or</td></tr>
<tr><td><code>¬¨</code></td><td><code>not</code>, <code>~</code></td><td>Logical not</td></tr>
<tr><td><code>‚â§</code></td><td><code>&lt;=</code></td><td>Less or equal</td></tr>
<tr><td><code>‚â•</code></td><td><code>&gt;=</code></td><td>Greater or equal</td></tr>
<tr><td><code>‚â†</code></td><td><code>!=</code>, <code>/=</code></td><td>Not equal</td></tr>
<tr><td><code>‚Ñï</code></td><td><code>Nat</code></td><td>Natural numbers</td></tr>
<tr><td><code>‚Ñ§</code></td><td><code>Int</code></td><td>Integers</td></tr>
<tr><td><code>‚Ñö</code></td><td><code>Rational</code></td><td>Rational numbers</td></tr>
<tr><td><code>‚Ñù</code></td><td><code>Real</code></td><td>Real numbers</td></tr>
<tr><td><code>‚ÑÇ</code></td><td><code>Complex</code></td><td>Complex numbers</td></tr>
<tr><td><code>Œª</code></td><td><code>lambda</code></td><td>Lambda</td></tr>
<tr><td><code>œÄ</code></td><td><code>pi</code></td><td>Pi constant</td></tr>
<tr><td><code>‚àû</code></td><td><code>infinity</code></td><td>Infinity</td></tr>
</tbody>
</table>
</div>
<h2 id="lexical-elements"><a class="header" href="#lexical-elements">Lexical Elements</a></h2>
<pre><code class="language-ebnf">identifier ::= letter { letter | digit | "_" }

number ::= integer | decimal | scientific
integer ::= digit { digit }
decimal ::= digit { digit } "." { digit }
scientific ::= decimal ("e" | "E") ["+"|"-"] digit { digit }

string ::= '"' { character } '"'

letter ::= "a".."z" | "A".."Z" | greekLetter
digit ::= "0".."9"

greekLower ::= "Œ±" | "Œ≤" | "Œ≥" | "Œ¥" | "Œµ" | "Œ∂" | "Œ∑" | "Œ∏"
             | "Œπ" | "Œ∫" | "Œª" | "Œº" | "ŒΩ" | "Œæ" | "Œø" | "œÄ"
             | "œÅ" | "œÉ" | "œÑ" | "œÖ" | "œÜ" | "œá" | "œà" | "œâ"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-b-operators"><a class="header" href="#appendix-b-operators">Appendix B: Operators</a></h1>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td>Addition</td><td><code>3 + 4</code></td><td><code>7</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>10 - 3</code></td><td><code>7</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>6 * 7</code></td><td><code>42</code></td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>15 / 3</code></td><td><code>5</code></td></tr>
<tr><td><code>^</code></td><td>Exponentiation</td><td><code>2 ^ 10</code></td><td><code>1024</code></td></tr>
<tr><td><code>-</code> (unary)</td><td>Negation</td><td><code>-5</code></td><td><code>-5</code></td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>=</code></td><td></td><td>Equality</td><td><code>x = y</code></td></tr>
<tr><td><code>!=</code></td><td><code>‚â†</code></td><td>Inequality</td><td><code>x ‚â† y</code></td></tr>
<tr><td><code>&lt;</code></td><td></td><td>Less than</td><td><code>x &lt; y</code></td></tr>
<tr><td><code>&gt;</code></td><td></td><td>Greater than</td><td><code>x &gt; y</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>‚â§</code></td><td>Less or equal</td><td><code>x ‚â§ y</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>‚â•</code></td><td>Greater or equal</td><td><code>x ‚â• y</code></td></tr>
</tbody>
</table>
</div>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>and</code></td><td><code>‚àß</code></td><td>Conjunction</td><td><code>P ‚àß Q</code></td></tr>
<tr><td><code>or</code></td><td><code>‚à®</code></td><td>Disjunction</td><td><code>P ‚à® Q</code></td></tr>
<tr><td><code>not</code></td><td><code>¬¨</code></td><td>Negation</td><td><code>¬¨P</code></td></tr>
<tr><td><code>implies</code></td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code></td><td>Implication</td><td><code>P ‚Üí Q</code></td></tr>
<tr><td><code>iff</code></td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code></td><td>Biconditional</td><td><code>P ‚Üî Q</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> All three Unicode variants for implication and biconditional are
equivalent. Use whichever matches your notation conventions.</p>
</blockquote>
<h2 id="set-operators"><a class="header" href="#set-operators">Set Operators</a></h2>
<blockquote>
<p><strong>Note:</strong> Set operators are parsed as custom operators but don‚Äôt have special semantic meaning yet. Use function-call syntax for set operations: <code>member(x, S)</code>, <code>union(A, B)</code>, etc.</p>
</blockquote>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><code>‚à™</code></td><td></td><td>Union</td><td>Custom operator (no special semantics)</td></tr>
<tr><td><code>‚à©</code></td><td></td><td>Intersection</td><td>Custom operator (no special semantics)</td></tr>
<tr><td><code>‚àà</code></td><td></td><td>Membership</td><td>‚ùå Not implemented - use <code>member(x, S)</code></td></tr>
<tr><td><code>‚àâ</code></td><td></td><td>Non-membership</td><td>‚ùå Not implemented</td></tr>
<tr><td><code>‚äÜ</code></td><td></td><td>Subset</td><td>‚ùå Not implemented - use <code>subset(A, B)</code></td></tr>
<tr><td><code>‚äá</code></td><td></td><td>Superset</td><td>‚ùå Not implemented</td></tr>
</tbody>
</table>
</div>
<h2 id="type-operators"><a class="header" href="#type-operators">Type Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>‚Üí</code></td><td>Function type</td><td><code>‚Ñù ‚Üí ‚Ñù</code></td></tr>
<tr><td><code>√ó</code></td><td>Product type</td><td><code>‚Ñù √ó ‚Ñù</code></td></tr>
<tr><td><code>:</code></td><td>Type annotation</td><td><code>x : ‚Ñù</code></td></tr>
</tbody>
</table>
</div>
<h2 id="precedence-table"><a class="header" href="#precedence-table">Precedence Table</a></h2>
<p>From lowest to highest precedence:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code> <code>‚áî</code> <code>‚ü∫</code> (biconditional)</td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> <code>‚áí</code> <code>‚üπ</code> (implication)</td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code> <code>or</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code> <code>and</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code> <code>not</code></td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>‚â†</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>‚â•</code></td><td>Non-associative</td></tr>
<tr><td>7</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>*</code> <code>/</code> <code>√ó</code> <code>¬∑</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>^</code> (power)</td><td>Right</td></tr>
<tr><td>10</td><td><code>-</code> (unary negation)</td><td>Prefix</td></tr>
<tr><td>11</td><td><code>!</code> <code>·µÄ</code> <code>‚Ä†</code> (postfix)</td><td>Postfix</td></tr>
<tr><td>12</td><td>Function application</td><td>Left</td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> Field access (<code>.</code>) is NOT implemented. Use function-call syntax: <code>field(object)</code> instead of <code>object.field</code>.</p>
</blockquote>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<pre><code class="language-kleis">define ex1 = 2 + 3 * 4        // 14 (not 20)
define ex2 = (2 + 3) * 4      // 20
define ex3 = 2 ^ 3 ^ 2        // 512 (= 2^9, right associative)
define neg_sq(x) = -x^2       // -(x^2), not (-x)^2
</code></pre>
<h3 id="logical"><a class="header" href="#logical">Logical</a></h3>
<pre><code class="language-kleis">define logic1(P, Q, R) = P ‚àß Q ‚à® R        // (P ‚àß Q) ‚à® R
define logic2(P, Q, R) = P ‚Üí Q ‚Üí R        // P ‚Üí (Q ‚Üí R) (right associative)
define logic3(P, Q) = ¬¨P ‚àß Q              // (¬¨P) ‚àß Q
</code></pre>
<h3 id="type-expressions"><a class="header" href="#type-expressions">Type Expressions</a></h3>
<pre><code class="language-kleis">‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù        // ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù) (curried binary function)
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù      // Higher-order: takes function, returns value
‚Ñù √ó ‚Ñù ‚Üí ‚Ñù        // Takes pair, returns value
</code></pre>
<h2 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h2>
<h3 id="mathematical-functions"><a class="header" href="#mathematical-functions">Mathematical Functions</a></h3>
<pre><code class="language-kleis">sqrt(x)          // Square root
abs(x)           // Absolute value
floor(x)         // Round down
ceil(x)          // Round up
round(x)         // Round to nearest
min(x, y)        // Minimum
max(x, y)        // Maximum
</code></pre>
<h3 id="trigonometric-functions"><a class="header" href="#trigonometric-functions">Trigonometric Functions</a></h3>
<pre><code class="language-kleis">sin(x)   cos(x)   tan(x)
asin(x)  acos(x)  atan(x)
sinh(x)  cosh(x)  tanh(x)
</code></pre>
<h3 id="exponential-and-logarithmic-1"><a class="header" href="#exponential-and-logarithmic-1">Exponential and Logarithmic</a></h3>
<pre><code class="language-kleis">exp(x)           // e^x
ln(x)            // Natural logarithm
log(x)           // Base-10 logarithm
log(b, x)        // Logarithm base b
</code></pre>
<h3 id="constants-1"><a class="header" href="#constants-1">Constants</a></h3>
<pre><code class="language-kleis">œÄ                // Pi (3.14159...)
e                // Euler's number (2.71828...)
i                // Imaginary unit
</code></pre>
<h2 id="reserved-keywords"><a class="header" href="#reserved-keywords">Reserved Keywords</a></h2>
<p>The following words are reserved and cannot be used as variable or function names:</p>
<h3 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>if</code></td><td>Conditional start</td><td><code>if x &gt; 0 then ...</code></td></tr>
<tr><td><code>then</code></td><td>Conditional consequence</td><td><code>if P then Q else R</code></td></tr>
<tr><td><code>else</code></td><td>Conditional alternative</td><td><code>if P then Q else R</code></td></tr>
<tr><td><code>match</code></td><td>Pattern matching</td><td><code>match x { ... }</code></td></tr>
<tr><td><code>let</code></td><td>Local binding</td><td><code>let x = 5 in ...</code></td></tr>
<tr><td><code>in</code></td><td>Binding body</td><td><code>let x = 5 in x + 1</code></td></tr>
</tbody>
</table>
</div>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>lambda</code></td><td>Anonymous function (ASCII)</td><td><code>lambda x . x + 1</code></td></tr>
<tr><td><code>Œª</code></td><td>Anonymous function (Unicode)</td><td><code>Œª x . x + 1</code></td></tr>
<tr><td><code>define</code></td><td>Function definition</td><td><code>define f(x) = x^2</code></td></tr>
</tbody>
</table>
</div>
<h3 id="quantifiers-1"><a class="header" href="#quantifiers-1">Quantifiers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>forall</code></td><td>Universal quantifier (ASCII)</td><td><code>forall x . P(x)</code></td></tr>
<tr><td><code>‚àÄ</code></td><td>Universal quantifier (Unicode)</td><td><code>‚àÄ(x : ‚Ñù). x = x</code></td></tr>
<tr><td><code>exists</code></td><td>Existential quantifier (ASCII)</td><td><code>exists x . P(x)</code></td></tr>
<tr><td><code>‚àÉ</code></td><td>Existential quantifier (Unicode)</td><td><code>‚àÉ(x : ‚Ñù). x &gt; 0</code></td></tr>
</tbody>
</table>
</div>
<h3 id="logical-operators-keyword-form"><a class="header" href="#logical-operators-keyword-form">Logical Operators (keyword form)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>and</code></td><td>Logical conjunction</td><td><code>P and Q</code></td></tr>
<tr><td><code>or</code></td><td>Logical disjunction</td><td><code>P or Q</code></td></tr>
<tr><td><code>not</code></td><td>Logical negation</td><td><code>not P</code></td></tr>
</tbody>
</table>
</div>
<h3 id="definitions"><a class="header" href="#definitions">Definitions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>structure</code></td><td>Algebraic structure</td><td><code>structure Group(G) { ... }</code></td></tr>
<tr><td><code>implements</code></td><td>Structure implementation</td><td><code>implements Group(‚Ñ§) { ... }</code></td></tr>
<tr><td><code>data</code></td><td>Algebraic data type</td><td><code>data Option(T) = Some(T) | None</code></td></tr>
<tr><td><code>type</code></td><td>Type alias</td><td><code>type Point = (‚Ñù, ‚Ñù)</code></td></tr>
<tr><td><code>operation</code></td><td>Operation declaration</td><td><code>operation add : G √ó G ‚Üí G</code></td></tr>
<tr><td><code>element</code></td><td>Element declaration</td><td><code>element zero : G</code></td></tr>
<tr><td><code>axiom</code></td><td>Axiom declaration</td><td><code>axiom identity : ...</code></td></tr>
</tbody>
</table>
</div>
<h3 id="modifiers-and-clauses"><a class="header" href="#modifiers-and-clauses">Modifiers and Clauses</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>import</code></td><td>File import</td><td><code>import "stdlib/prelude.kleis"</code></td></tr>
<tr><td><code>over</code></td><td>Type constraint</td><td><code>structure V over Field(F) { ... }</code></td></tr>
<tr><td><code>extends</code></td><td>Structure extension</td><td><code>structure Ring extends Group { ... }</code></td></tr>
<tr><td><code>as</code></td><td>Pattern alias</td><td><code>match x { y as Some(_) =&gt; ... }</code></td></tr>
</tbody>
</table>
</div>
<h3 id="commands"><a class="header" href="#commands">Commands</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Keyword</th><th>Purpose</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>verify</code></td><td>Verification directive</td><td><code>:verify P ‚àß Q</code></td></tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>Note:</strong> Using a reserved keyword as a variable name will cause a parse error.
For example, <code>let lambda = 5</code> fails because <code>lambda</code> is reserved for anonymous functions.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-c-standard-library"><a class="header" href="#appendix-c-standard-library">Appendix C: Standard Library</a></h1>
<p>The Kleis standard library provides foundational types, structures, and operations.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="numeric-types-1"><a class="header" href="#numeric-types-1">Numeric Types</a></h3>
<pre><code class="language-kleis">// These are primitive types built into Kleis:
‚Ñï  (or Nat)      // Natural numbers (0, 1, 2, ...)
‚Ñ§  (or Int)      // Integers (..., -1, 0, 1, ...)
‚Ñù  (or Real)     // Real numbers
‚ÑÇ  (or Complex)  // Complex numbers
</code></pre>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h3>
<pre><code class="language-kleis">Bool  // True or False
</code></pre>
<h3 id="string-type"><a class="header" href="#string-type">String Type</a></h3>
<pre><code class="language-kleis">String  // Text literals: "hello", "world"
</code></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h3>
<pre><code class="language-kleis">Unit  // Single value: ()
</code></pre>
<h2 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h2>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<pre><code class="language-kleis">structure List(T) {
    operation head : T
    operation tail : List(T)
    operation length : ‚Ñï
    operation append : List(T) ‚Üí List(T)
    operation map : (T ‚Üí U) ‚Üí List(U)
    operation filter : (T ‚Üí Bool) ‚Üí List(T)
}
</code></pre>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï, T) {
    operation get : ‚Ñï ‚Üí T
    operation length : ‚Ñï
    operation dot : Vector(n, T) ‚Üí T
    operation magnitude : ‚Ñù
    operation normalize : Vector(n, T)
}
</code></pre>
<h3 id="matrix"><a class="header" href="#matrix">Matrix</a></h3>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation get : ‚Ñï √ó ‚Ñï ‚Üí T
    operation rows : ‚Ñï
    operation cols : ‚Ñï
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    operation mul : Matrix(n, p, T) ‚Üí Matrix(m, p, T)
}

structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    operation eigenvalues : List(‚ÑÇ)
}
</code></pre>
<h2 id="complex-numbers-1"><a class="header" href="#complex-numbers-1">Complex Numbers</a></h2>
<p>The complex number type <code>‚ÑÇ</code> has full arithmetic support:</p>
<h3 id="construction-and-extraction-1"><a class="header" href="#construction-and-extraction-1">Construction and Extraction</a></h3>
<pre><code class="language-kleis">// Create complex number: complex(real_part, imaginary_part)
define z = complex(3, 4)        // 3 + 4i

// The imaginary unit
define i_unit = i               // = complex(0, 1)

// Extract parts
define x = re(z)                // 3
define y = im(z)                // 4
</code></pre>
<h3 id="arithmetic-operations-3"><a class="header" href="#arithmetic-operations-3">Arithmetic Operations</a></h3>
<pre><code class="language-kleis">// All operations are explicit (no operator overloading yet)
complex_add(z1, z2)      // z1 + z2
complex_sub(z1, z2)      // z1 - z2
complex_mul(z1, z2)      // z1 √ó z2
complex_div(z1, z2)      // z1 / z2
neg_complex(z)           // -z
complex_inverse(z)       // 1/z
</code></pre>
<h3 id="conjugate-and-magnitude"><a class="header" href="#conjugate-and-magnitude">Conjugate and Magnitude</a></h3>
<pre><code class="language-kleis">conj(z)                  // Complex conjugate (a - bi)
abs_squared(z)           // |z|¬≤ = a¬≤ + b¬≤
</code></pre>
<h3 id="operation-reference-2"><a class="header" href="#operation-reference-2">Operation Reference</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operation</th><th>Syntax</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td>Create</td><td><code>complex(a, b)</code></td><td><code>complex(3, 4)</code></td><td>3 + 4i</td></tr>
<tr><td>Real part</td><td><code>re(z)</code></td><td><code>re(complex(3, 4))</code></td><td>3</td></tr>
<tr><td>Imaginary part</td><td><code>im(z)</code></td><td><code>im(complex(3, 4))</code></td><td>4</td></tr>
<tr><td>Add</td><td><code>complex_add(z1, z2)</code></td><td><code>complex_add(complex(1,2), complex(3,4))</code></td><td>complex(4, 6)</td></tr>
<tr><td>Subtract</td><td><code>complex_sub(z1, z2)</code></td><td><code>complex_sub(complex(5,3), complex(2,1))</code></td><td>complex(3, 2)</td></tr>
<tr><td>Multiply</td><td><code>complex_mul(z1, z2)</code></td><td><code>complex_mul(complex(1,2), complex(3,4))</code></td><td>complex(-5, 10)</td></tr>
<tr><td>Divide</td><td><code>complex_div(z1, z2)</code></td><td><code>complex_div(complex(1,0), complex(0,1))</code></td><td>complex(0, -1)</td></tr>
<tr><td>Negate</td><td><code>neg_complex(z)</code></td><td><code>neg_complex(complex(3, 4))</code></td><td>complex(-3, -4)</td></tr>
<tr><td>Inverse</td><td><code>complex_inverse(z)</code></td><td><code>complex_inverse(i)</code></td><td>complex(0, -1)</td></tr>
<tr><td>Conjugate</td><td><code>conj(z)</code></td><td><code>conj(complex(3, 4))</code></td><td>complex(3, -4)</td></tr>
<tr><td>Magnitude¬≤</td><td><code>abs_squared(z)</code></td><td><code>abs_squared(complex(3, 4))</code></td><td>25</td></tr>
</tbody>
</table>
</div>
<p>See <a href="#complex-numbers">Chapter 14: Complex Numbers</a> for detailed examples.</p>
<h2 id="algebraic-structures"><a class="header" href="#algebraic-structures">Algebraic Structures</a></h2>
<h3 id="monoid"><a class="header" href="#monoid">Monoid</a></h3>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M                         // Identity element
    operation mul : M √ó M ‚Üí M     // Binary operation
    
    axiom identity_left : ‚àÄ(x : M). mul(e, x) = x
    axiom identity_right : ‚àÄ(x : M). mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h3 id="group"><a class="header" href="#group">Group</a></h3>
<pre><code class="language-kleis">structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G         // Inverse
    
    axiom inverse_left : ‚àÄ(x : G). mul(inv(x), x) = e
    axiom inverse_right : ‚àÄ(x : G). mul(x, inv(x)) = e
}
</code></pre>
<h3 id="ring"><a class="header" href="#ring">Ring</a></h3>
<pre><code class="language-kleis">structure Ring(R) {
    operation zero : R
    operation one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    // (R, add, zero) is an abelian group
    // (R, mul, one) is a monoid
    // mul distributes over add
}
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<pre><code class="language-kleis">structure Field(F) extends Ring(F) {
    operation inv : F ‚Üí F  // Multiplicative inverse (for non-zero)
    
    axiom mul_inverse : ‚àÄ(x : F). x ‚â† zero ‚Üí mul(x, inv(x)) = one
    axiom mul_commutative : ‚àÄ(x : F)(y : F). mul(x, y) = mul(y, x)
}
</code></pre>
<h3 id="vector-space"><a class="header" href="#vector-space">Vector Space</a></h3>
<pre><code class="language-kleis">structure VectorSpace(V, F) over Field(F) {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    zero : V
    
    // (V, add, zero) is an abelian group
    // scale distributes over add
    // scale is associative with field multiplication
}
</code></pre>
<h2 id="geometric-structures"><a class="header" href="#geometric-structures">Geometric Structures</a></h2>
<h3 id="metric-space"><a class="header" href="#metric-space">Metric Space</a></h3>
<pre><code class="language-kleis">structure MetricSpace(M) {
    operation distance : M √ó M ‚Üí ‚Ñù
    
    axiom non_negative : ‚àÄ(x : M)(y : M). distance(x, y) ‚â• 0
    axiom identity : ‚àÄ(x : M)(y : M). distance(x, y) = 0 ‚Üî x = y
    axiom symmetric : ‚àÄ(x : M)(y : M). distance(x, y) = distance(y, x)
    axiom triangle : ‚àÄ(x : M)(y : M)(z : M).
        distance(x, z) ‚â§ distance(x, y) + distance(y, z)
}
</code></pre>
<h3 id="manifold"><a class="header" href="#manifold">Manifold</a></h3>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(dim)
    operation chart : M ‚Üí Vector(dim, ‚Ñù)  // Local coordinates
}
</code></pre>
<h3 id="riemannian-manifold"><a class="header" href="#riemannian-manifold">Riemannian Manifold</a></h3>
<pre><code class="language-kleis">structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation metric : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation scalar_curvature : M ‚Üí ‚Ñù
}
</code></pre>
<h2 id="option-and-result-types"><a class="header" href="#option-and-result-types">Option and Result Types</a></h2>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<pre><code class="language-kleis">data Option(T) = Some(value : T) | None

// Operations
define is_some(opt) =
    match opt {
        Some(_) =&gt; True
        None =&gt; False
    }

define unwrap_or(opt, default) =
    match opt {
        Some(v) =&gt; v
        None =&gt; default
    }
</code></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<pre><code class="language-kleis">data Result(T, E) = Ok(value : T) | Err(error : E)

// Operations
define is_ok(res) =
    match res {
        Ok(_) =&gt; True
        Err(_) =&gt; False
    }

define map_result(res, f) =
    match res {
        Ok(v) =&gt; Ok(f(v))
        Err(e) =&gt; Err(e)
    }
</code></pre>
<h2 id="loading-the-standard-library"><a class="header" href="#loading-the-standard-library">Loading the Standard Library</a></h2>
<p>In the REPL:</p>
<pre><code>kleis&gt; :load stdlib/prelude.kleis
Loaded standard library.
</code></pre>
<p>In files:</p>
<pre><code class="language-kleis example">import "stdlib/prelude.kleis"
import "stdlib/linear_algebra.kleis"
import "stdlib/differential_geometry.kleis"
</code></pre>
<h2 id="file-organization"><a class="header" href="#file-organization">File Organization</a></h2>
<pre><code>stdlib/
‚îú‚îÄ‚îÄ prelude.kleis          // Core types and functions (includes complex)
‚îú‚îÄ‚îÄ complex.kleis          // Complex number axioms and properties
‚îú‚îÄ‚îÄ numeric.kleis          // Numeric operations
‚îú‚îÄ‚îÄ text.kleis             // String processing operations
‚îú‚îÄ‚îÄ collections.kleis      // List, Vector, Matrix
‚îú‚îÄ‚îÄ algebraic.kleis        // Group, Ring, Field, etc.
‚îú‚îÄ‚îÄ linear_algebra.kleis   // Matrix operations
‚îú‚îÄ‚îÄ differential_geometry.kleis  // Manifolds, tensors
‚îî‚îÄ‚îÄ category_theory.kleis  // Categories, functors
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-lisp-interpreter-in-kleis"><a class="header" href="#appendix-lisp-interpreter-in-kleis">Appendix: LISP Interpreter in Kleis</a></h1>
<p>This appendix presents a complete LISP interpreter written entirely in Kleis. This demonstrates Kleis‚Äôs power as a <strong>meta-language</strong> ‚Äî you can define and execute other programming languages within Kleis itself.</p>
<p>The interpreter includes:</p>
<ul>
<li><strong>Recursive descent S-expression parser</strong></li>
<li><strong>Full evaluator</strong> with special forms, arithmetic, comparisons, and list operations</li>
<li><strong>Lexical closures</strong> with <code>lambda</code></li>
<li><strong>Recursive functions</strong> with <code>letrec</code></li>
</ul>
<h2 id="running-in-the-repl"><a class="header" href="#running-in-the-repl">Running in the REPL</a></h2>
<pre><code>$ cargo run --bin repl
üßÆ Kleis REPL v0.1.0

Œª&gt; :load docs/grammar/lisp_parser.kleis
‚úÖ Loaded: 2 files, 60 functions, 15 structures, 5 data types

Œª&gt; :eval run("(+ 2 3)")
‚úÖ VNum(5)

Œª&gt; :eval run("(* 4 5)")  
‚úÖ VNum(20)

Œª&gt; :eval run("(if (&lt; 3 5) 100 200)")
‚úÖ VNum(100)

Œª&gt; :eval run("((lambda (x) (* x x)) 7)")
‚úÖ VNum(49)

Œª&gt; :eval run("(let ((x 10)) (+ x 5))")
‚úÖ VNum(15)
</code></pre>
<h3 id="factorial"><a class="header" href="#factorial">Factorial</a></h3>
<pre><code>Œª&gt; :eval run("(letrec ((fact (lambda (n) (if (&lt;= n 1) 1 (* n (fact (- n 1))))))) (fact 5))")
‚úÖ VNum(120)
</code></pre>
<h3 id="fibonacci"><a class="header" href="#fibonacci">Fibonacci</a></h3>
<pre><code>Œª&gt; :eval run("(letrec ((fib (lambda (n) (if (&lt; n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 10))")
‚úÖ VNum(55)
</code></pre>
<hr>
<h2 id="complete-source-code"><a class="header" href="#complete-source-code">Complete Source Code</a></h2>
<p>The complete LISP interpreter is in <code>docs/grammar/lisp_parser.kleis</code>. Below is the full implementation.</p>
<h3 id="part-1-s-expression-data-types"><a class="header" href="#part-1-s-expression-data-types">Part 1: S-Expression Data Types</a></h3>
<pre><code class="language-kleis">import "stdlib/prelude.kleis"

// S-Expression: atoms and lists
data SExpr =
    SAtom(value: String)
  | SList(elements: List(SExpr))

// Parser result: success with remaining input, or error
data ParseResult =
    ParseOK(expr: SExpr, rest: String)
  | ParseErr(message: String)
</code></pre>
<h3 id="part-2-parser-helper-functions"><a class="header" href="#part-2-parser-helper-functions">Part 2: Parser Helper Functions</a></h3>
<pre><code class="language-kleis">// Check if character is whitespace
define is_ws(c: String) : Bool =
    or(eq(c, " "), or(eq(c, "\n"), eq(c, "\t")))

// Check if character is a delimiter
define is_delim(c: String) : Bool =
    or(is_ws(c), or(eq(c, "("), eq(c, ")")))

// Skip leading whitespace
define skip_ws(s: String) : String =
    if le(strlen(s), 0) then s
    else if is_ws(charAt(s, 0)) then skip_ws(substr(s, 1, strlen(s) - 1))
    else s

// Read atom characters until delimiter
define read_atom(s: String, acc: String) : ParseResult =
    if le(strlen(s), 0) then ParseOK(SAtom(acc), "")
    else if is_delim(charAt(s, 0)) then ParseOK(SAtom(acc), s)
    else read_atom(substr(s, 1, strlen(s) - 1), concat(acc, charAt(s, 0)))
</code></pre>
<h3 id="part-3-recursive-descent-parser"><a class="header" href="#part-3-recursive-descent-parser">Part 3: Recursive Descent Parser</a></h3>
<pre><code class="language-kleis">// Parse a single S-expression
define parse_sexpr(s: String) : ParseResult =
    let trimmed = skip_ws(s) in
    if le(strlen(trimmed), 0) then ParseErr("Unexpected end of input")
    else if eq(charAt(trimmed, 0), "(") then 
        parse_list(substr(trimmed, 1, strlen(trimmed) - 1), Nil)
    else read_atom(trimmed, "")

// Parse list elements until ")"
define parse_list(s: String, acc: List(SExpr)) : ParseResult =
    let trimmed = skip_ws(s) in
    if le(strlen(trimmed), 0) then ParseErr("Expected ')'")
    else if eq(charAt(trimmed, 0), ")") then 
        ParseOK(SList(rev(acc)), substr(trimmed, 1, strlen(trimmed) - 1))
    else 
        match parse_sexpr(trimmed) {
            ParseOK(expr, rest) =&gt; parse_list(rest, Cons(expr, acc))
          | ParseErr(msg) =&gt; ParseErr(msg)
        }

// Reverse a list
define rev(xs: List(SExpr)) : List(SExpr) =
    rev_acc(xs, Nil)

define rev_acc(xs: List(SExpr), acc: List(SExpr)) : List(SExpr) =
    match xs {
        Nil =&gt; acc
      | Cons(h, t) =&gt; rev_acc(t, Cons(h, acc))
    }

// User-facing parse function
define parse(s: String) : SExpr =
    match parse_sexpr(s) {
        ParseOK(expr, rest) =&gt; expr
      | ParseErr(msg) =&gt; SAtom(concat("Error: ", msg))
    }
</code></pre>
<h3 id="part-4-lisp-value-types-and-environment"><a class="header" href="#part-4-lisp-value-types-and-environment">Part 4: LISP Value Types and Environment</a></h3>
<pre><code class="language-kleis">// Values in our LISP
data LispVal =
    VNum(n: ‚Ñ§)                              // Integer
  | VSym(s: String)                         // Symbol (for errors/unbound)
  | VList(xs: List(LispVal))                // List value
  | VBool(b: Bool)                          // Boolean
  | VLambda(params: List(String), body: SExpr, env: Env)  // Closure

// Environment: list of (name, value) bindings
data Binding = Bind(name: String, val: LispVal)
data Env = Env(bindings: List(Binding))

// Empty environment
define empty_env : Env = Env(Nil)

// Look up a variable in the environment
define lookup(name: String, env: Env) : LispVal =
    match env {
        Env(bindings) =&gt; lookup_list(name, bindings)
    }

define lookup_list(name: String, bs: List(Binding)) : LispVal =
    match bs {
        Nil =&gt; VSym(concat("Unbound: ", name))
      | Cons(Bind(n, v), rest) =&gt; 
            if eq(n, name) then v else lookup_list(name, rest)
    }

// Extend environment with a new binding
define extend(name: String, val: LispVal, env: Env) : Env =
    match env {
        Env(bindings) =&gt; Env(Cons(Bind(name, val), bindings))
    }

// Extend with multiple bindings (for function application)
define extend_all(names: List(String), vals: List(LispVal), env: Env) : Env =
    match names {
        Nil =&gt; env
      | Cons(n, ns) =&gt; 
            match vals {
                Nil =&gt; env
              | Cons(v, vs) =&gt; extend_all(ns, vs, extend(n, v, env))
            }
    }
</code></pre>
<h3 id="part-5-integer-parsing"><a class="header" href="#part-5-integer-parsing">Part 5: Integer Parsing</a></h3>
<pre><code class="language-kleis">define is_digit_char(c: String) : Bool =
    or(eq(c, "0"), or(eq(c, "1"), or(eq(c, "2"), or(eq(c, "3"), or(eq(c, "4"),
    or(eq(c, "5"), or(eq(c, "6"), or(eq(c, "7"), or(eq(c, "8"), eq(c, "9"))))))))))

define is_number_str(s: String) : Bool =
    if le(strlen(s), 0) then false
    else if eq(charAt(s, 0), "-") then 
        if le(strlen(s), 1) then false 
        else all_digits(substr(s, 1, strlen(s) - 1))
    else all_digits(s)

define all_digits(s: String) : Bool =
    if le(strlen(s), 0) then true
    else if is_digit_char(charAt(s, 0)) then all_digits(substr(s, 1, strlen(s) - 1))
    else false

define parse_int(s: String) : ‚Ñ§ =
    if eq(charAt(s, 0), "-") then 0 - parse_int_pos(substr(s, 1, strlen(s) - 1))
    else parse_int_pos(s)

define parse_int_pos(s: String) : ‚Ñ§ =
    parse_int_acc(s, 0)

define parse_int_acc(s: String, acc: ‚Ñ§) : ‚Ñ§ =
    if le(strlen(s), 0) then acc
    else 
        let d = digit_val(charAt(s, 0)) in
        parse_int_acc(substr(s, 1, strlen(s) - 1), acc * 10 + d)

define digit_val(c: String) : ‚Ñ§ =
    if eq(c, "0") then 0 else if eq(c, "1") then 1 else if eq(c, "2") then 2
    else if eq(c, "3") then 3 else if eq(c, "4") then 4 else if eq(c, "5") then 5
    else if eq(c, "6") then 6 else if eq(c, "7") then 7 else if eq(c, "8") then 8
    else 9
</code></pre>
<h3 id="part-6-main-evaluator"><a class="header" href="#part-6-main-evaluator">Part 6: Main Evaluator</a></h3>
<pre><code class="language-kleis">define eval_lisp(expr: SExpr, env: Env) : LispVal =
    match expr {
        SAtom(s) =&gt; 
            if is_number_str(s) then VNum(parse_int(s))
            else if eq(s, "true") then VBool(true)
            else if eq(s, "false") then VBool(false)
            else lookup(s, env)
      | SList(elements) =&gt; eval_list(elements, env)
    }

define eval_list(elements: List(SExpr), env: Env) : LispVal =
    match elements {
        Nil =&gt; VList(Nil)  // Empty list is a value
      | Cons(head, rest) =&gt; eval_form(head, rest, env)
    }

// Evaluate a special form or function call
define eval_form(head: SExpr, args: List(SExpr), env: Env) : LispVal =
    match head {
        SAtom(op) =&gt; 
            // Special forms
            if eq(op, "if") then eval_if(args, env)
            else if eq(op, "quote") then eval_quote(args)
            else if eq(op, "lambda") then eval_lambda(args, env)
            else if eq(op, "let") then eval_let(args, env)
            else if eq(op, "letrec") then eval_letrec(args, env)
            // Arithmetic
            else if eq(op, "+") then eval_add(args, env)
            else if eq(op, "-") then eval_sub(args, env)
            else if eq(op, "*") then eval_mul(args, env)
            else if eq(op, "/") then eval_div(args, env)
            // Comparison
            else if eq(op, "&lt;") then eval_lt(args, env)
            else if eq(op, "&gt;") then eval_gt(args, env)
            else if eq(op, "=") then eval_eq(args, env)
            else if eq(op, "&lt;=") then eval_le(args, env)
            else if eq(op, "&gt;=") then eval_ge(args, env)
            // List operations
            else if eq(op, "list") then eval_list_op(args, env)
            else if eq(op, "car") then eval_car(args, env)
            else if eq(op, "cdr") then eval_cdr(args, env)
            else if eq(op, "cons") then eval_cons(args, env)
            else if eq(op, "null?") then eval_null(args, env)
            // Function call
            else eval_call(op, args, env)
      | SList(_) =&gt; 
            // First element is an expression (e.g., lambda)
            let fn_val = eval_lisp(head, env) in
            eval_apply(fn_val, args, env)
    }
</code></pre>
<h3 id="part-7-special-forms"><a class="header" href="#part-7-special-forms">Part 7: Special Forms</a></h3>
<pre><code class="language-kleis">define eval_if(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(cond, Cons(then_br, Cons(else_br, Nil))) =&gt;
            let cv = eval_lisp(cond, env) in
            if is_truthy(cv) then eval_lisp(then_br, env) else eval_lisp(else_br, env)
      | _ =&gt; VSym("Error: if requires 3 arguments")
    }

define is_truthy(v: LispVal) : Bool =
    match v {
        VBool(b) =&gt; b
      | VNum(n) =&gt; not(eq(n, 0))
      | VList(Nil) =&gt; false
      | VList(_) =&gt; true
      | VSym(_) =&gt; false
      | VLambda(_, _, _) =&gt; true
    }

define eval_quote(args: List(SExpr)) : LispVal =
    match args {
        Cons(expr, Nil) =&gt; sexpr_to_val(expr)
      | _ =&gt; VSym("Error: quote requires 1 argument")
    }

define sexpr_to_val(expr: SExpr) : LispVal =
    match expr {
        SAtom(s) =&gt; if is_number_str(s) then VNum(parse_int(s)) else VSym(s)
      | SList(elements) =&gt; VList(map_sexpr_to_val(elements))
    }

define map_sexpr_to_val(xs: List(SExpr)) : List(LispVal) =
    match xs {
        Nil =&gt; Nil
      | Cons(h, t) =&gt; Cons(sexpr_to_val(h), map_sexpr_to_val(t))
    }

define eval_lambda(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(params), Cons(body, Nil)) =&gt;
            VLambda(extract_param_names(params), body, env)
      | _ =&gt; VSym("Error: lambda requires (params) body")
    }

define extract_param_names(params: List(SExpr)) : List(String) =
    match params {
        Nil =&gt; Nil
      | Cons(SAtom(name), rest) =&gt; Cons(name, extract_param_names(rest))
      | _ =&gt; Nil
    }

define eval_let(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(bindings), Cons(body, Nil)) =&gt;
            let new_env = eval_let_bindings(bindings, env) in
            eval_lisp(body, new_env)
      | _ =&gt; VSym("Error: let requires ((bindings)) body")
    }

define eval_let_bindings(bindings: List(SExpr), env: Env) : Env =
    match bindings {
        Nil =&gt; env
      | Cons(SList(Cons(SAtom(name), Cons(val_expr, Nil))), rest) =&gt;
            let val = eval_lisp(val_expr, env) in
            eval_let_bindings(rest, extend(name, val, env))
      | _ =&gt; env
    }

// letrec: evaluate lambda in an environment that already contains the binding
// This enables recursion: (letrec ((fact (lambda (n) ...))) (fact 5))
define eval_letrec(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(SList(bindings), Cons(body, Nil)) =&gt;
            let rec_env = eval_letrec_bindings(bindings, env) in
            eval_lisp(body, rec_env)
      | _ =&gt; VSym("Error: letrec requires ((bindings)) body")
    }

define eval_letrec_bindings(bindings: List(SExpr), env: Env) : Env =
    match bindings {
        Nil =&gt; env
      | Cons(SList(Cons(SAtom(name), Cons(SList(Cons(SAtom(lambda_kw), 
            Cons(SList(params), Cons(body, Nil)))), Nil))), rest) =&gt;
            let dummy_env = extend(name, VSym("placeholder"), env) in
            let lambda_val = VLambda(extract_param_names(params), body, dummy_env) in
            let new_env = extend(name, lambda_val, env) in
            let fixed_lambda = VLambda(extract_param_names(params), body, new_env) in
            eval_letrec_bindings(rest, extend(name, fixed_lambda, env))
      | _ =&gt; env
    }
</code></pre>
<h3 id="part-8-arithmetic-operations"><a class="header" href="#part-8-arithmetic-operations">Part 8: Arithmetic Operations</a></h3>
<pre><code class="language-kleis">define eval_add(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x + y)
                  | _ =&gt; VSym("Error: + requires numbers")
                }
              | _ =&gt; VSym("Error: + requires numbers")
            }
      | _ =&gt; VSym("Error: + requires 2 arguments")
    }

define eval_sub(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x - y)
                  | _ =&gt; VSym("Error: - requires numbers")
                }
              | _ =&gt; VSym("Error: - requires numbers")
            }
      | _ =&gt; VSym("Error: - requires 2 arguments")
    }

define eval_mul(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VNum(x * y)
                  | _ =&gt; VSym("Error: * requires numbers")
                }
              | _ =&gt; VSym("Error: * requires numbers")
            }
      | _ =&gt; VSym("Error: * requires 2 arguments")
    }

define eval_div(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; if eq(y, 0) then VSym("Error: division by zero") 
                               else VNum(x / y)
                  | _ =&gt; VSym("Error: / requires numbers")
                }
              | _ =&gt; VSym("Error: / requires numbers")
            }
      | _ =&gt; VSym("Error: / requires 2 arguments")
    }
</code></pre>
<h3 id="part-9-comparison-operations"><a class="header" href="#part-9-comparison-operations">Part 9: Comparison Operations</a></h3>
<pre><code class="language-kleis">define eval_lt(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(lt(x, y))
                  | _ =&gt; VSym("Error: &lt; requires numbers")
                }
              | _ =&gt; VSym("Error: &lt; requires numbers")
            }
      | _ =&gt; VSym("Error: &lt; requires 2 arguments")
    }

define eval_gt(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(gt(x, y))
                  | _ =&gt; VSym("Error: &gt; requires numbers")
                }
              | _ =&gt; VSym("Error: &gt; requires numbers")
            }
      | _ =&gt; VSym("Error: &gt; requires 2 arguments")
    }

define eval_eq(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(eq(x, y))
                  | _ =&gt; VSym("Error: = requires numbers")
                }
              | _ =&gt; VSym("Error: = requires numbers")
            }
      | _ =&gt; VSym("Error: = requires 2 arguments")
    }

define eval_le(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(le(x, y))
                  | _ =&gt; VSym("Error: &lt;= requires numbers")
                }
              | _ =&gt; VSym("Error: &lt;= requires numbers")
            }
      | _ =&gt; VSym("Error: &lt;= requires 2 arguments")
    }

define eval_ge(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(a, Cons(b, Nil)) =&gt;
            match eval_lisp(a, env) {
                VNum(x) =&gt; match eval_lisp(b, env) {
                    VNum(y) =&gt; VBool(ge(x, y))
                  | _ =&gt; VSym("Error: &gt;= requires numbers")
                }
              | _ =&gt; VSym("Error: &gt;= requires numbers")
            }
      | _ =&gt; VSym("Error: &gt;= requires 2 arguments")
    }
</code></pre>
<h3 id="part-10-list-operations"><a class="header" href="#part-10-list-operations">Part 10: List Operations</a></h3>
<pre><code class="language-kleis">define eval_list_op(args: List(SExpr), env: Env) : LispVal =
    VList(eval_all(args, env))

define eval_all(args: List(SExpr), env: Env) : List(LispVal) =
    match args {
        Nil =&gt; Nil
      | Cons(h, t) =&gt; Cons(eval_lisp(h, env), eval_all(t, env))
    }

define eval_car(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Cons(h, _)) =&gt; h
              | _ =&gt; VSym("Error: car requires non-empty list")
            }
      | _ =&gt; VSym("Error: car requires 1 argument")
    }

define eval_cdr(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Cons(_, t)) =&gt; VList(t)
              | _ =&gt; VSym("Error: cdr requires non-empty list")
            }
      | _ =&gt; VSym("Error: cdr requires 1 argument")
    }

define eval_cons(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(h, Cons(t, Nil)) =&gt;
            let hv = eval_lisp(h, env) in
            match eval_lisp(t, env) {
                VList(lst) =&gt; VList(Cons(hv, lst))
              | _ =&gt; VSym("Error: cons requires list as second arg")
            }
      | _ =&gt; VSym("Error: cons requires 2 arguments")
    }

define eval_null(args: List(SExpr), env: Env) : LispVal =
    match args {
        Cons(lst, Nil) =&gt;
            match eval_lisp(lst, env) {
                VList(Nil) =&gt; VBool(true)
              | VList(_) =&gt; VBool(false)
              | _ =&gt; VSym("Error: null? requires list")
            }
      | _ =&gt; VSym("Error: null? requires 1 argument")
    }
</code></pre>
<h3 id="part-11-function-application"><a class="header" href="#part-11-function-application">Part 11: Function Application</a></h3>
<pre><code class="language-kleis">define eval_call(name: String, args: List(SExpr), env: Env) : LispVal =
    let fn_val = lookup(name, env) in
    eval_apply(fn_val, args, env)

define eval_apply(fn_val: LispVal, args: List(SExpr), env: Env) : LispVal =
    match fn_val {
        VLambda(params, body, closure_env) =&gt;
            let arg_vals = eval_all(args, env) in
            // Merge current env into closure env for recursive calls
            let merged_env = merge_envs(env, closure_env) in
            let new_env = extend_all(params, arg_vals, merged_env) in
            eval_lisp(body, new_env)
      | VSym(msg) =&gt; VSym(msg)  // Error propagation
      | _ =&gt; VSym("Error: not a function")
    }

// Merge two environments: first takes precedence
// This allows letrec functions to see their own definitions
define merge_envs(e1: Env, e2: Env) : Env =
    match e1 {
        Env(b1) =&gt; match e2 {
            Env(b2) =&gt; Env(append_bindings(b1, b2))
        }
    }

define append_bindings(b1: List(Binding), b2: List(Binding)) : List(Binding) =
    match b1 {
        Nil =&gt; b2
      | Cons(h, t) =&gt; Cons(h, append_bindings(t, b2))
    }
</code></pre>
<h3 id="part-12-user-facing-run-function"><a class="header" href="#part-12-user-facing-run-function">Part 12: User-Facing Run Function</a></h3>
<pre><code class="language-kleis">// Run a LISP program from string
define run(code: String) : LispVal =
    eval_lisp(parse(code), empty_env)

// Run with an environment (for multiple expressions)
define run_with_env(code: String, env: Env) : LispVal =
    eval_lisp(parse(code), env)
</code></pre>
<hr>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>This LISP interpreter demonstrates that <strong>Kleis is Turing-complete</strong> and can serve as a host language for other programming languages. The implementation uses:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Kleis Construct</th></tr>
</thead>
<tbody>
<tr><td><strong>Data types</strong></td><td><code>data SExpr</code>, <code>data LispVal</code>, <code>data Env</code></td></tr>
<tr><td><strong>Pattern matching</strong></td><td><code>match expr { ... }</code></td></tr>
<tr><td><strong>Recursion</strong></td><td>Recursive function definitions</td></tr>
<tr><td><strong>Higher-order functions</strong></td><td><code>lambda</code>, closures with captured environments</td></tr>
<tr><td><strong>String operations</strong></td><td><code>charAt</code>, <code>substr</code>, <code>concat</code>, <code>strlen</code></td></tr>
<tr><td><strong>List operations</strong></td><td><code>Cons</code>, <code>Nil</code>, pattern matching on lists</td></tr>
</tbody>
</table>
</div>
<h3 id="key-insights"><a class="header" href="#key-insights">Key Insights</a></h3>
<ol>
<li>
<p><strong><code>:eval</code> enables execution</strong> ‚Äî The <code>:eval</code> REPL command executes Kleis functions directly, without going through Z3‚Äôs symbolic unrolling.</p>
</li>
<li>
<p><strong>Environment merging for recursion</strong> ‚Äî <code>letrec</code> works by merging the current environment (which contains the function binding) into the closure‚Äôs environment.</p>
</li>
<li>
<p><strong>60 pure functions</strong> ‚Äî The entire interpreter is implemented in ~560 lines of pure functional Kleis code.</p>
</li>
<li>
<p><strong>Meta-circular potential</strong> ‚Äî With minor extensions, this could interpret a subset of Kleis itself, demonstrating meta-circularity.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
