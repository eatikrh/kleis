<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn You Some Kleis</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A fun, illustrated guide to the Kleis mathematical language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-b777ca45.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f10a7c19.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn You Some Kleis</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/eatikrh/kleis" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="learn-you-some-kleis-for-great-good"><a class="header" href="#learn-you-some-kleis-for-great-good">Learn You Some Kleis for Great Good!</a></h1>
<blockquote>
<p><em>‚ÄúMathematics is the language with which God has written the universe.‚Äù</em> ‚Äî Galileo Galilei</p>
</blockquote>
<p>Welcome to <strong>Learn You Some Kleis</strong>, an illustrated guide to the Kleis mathematical language!</p>
<h2 id="what-is-kleis"><a class="header" href="#what-is-kleis">What is Kleis?</a></h2>
<p>Kleis is a <strong>mathematical expression language</strong> designed for:</p>
<ul>
<li>üìê <strong>Symbolic mathematics</strong> ‚Äî work with expressions, not just numbers</li>
<li>‚úÖ <strong>Formal verification</strong> ‚Äî prove properties with Z3 theorem prover</li>
<li>üèóÔ∏è <strong>Extensible structures</strong> ‚Äî define your own mathematical objects</li>
<li>üî¨ <strong>Scientific computing</strong> ‚Äî differential geometry, tensor calculus, and more</li>
</ul>
<h2 id="who-is-this-for"><a class="header" href="#who-is-this-for">Who is This For?</a></h2>
<p>This guide is for anyone who:</p>
<ul>
<li>Wants to express mathematical ideas precisely</li>
<li>Is curious about formal verification</li>
<li>Enjoys functional programming (Haskell, ML, etc.)</li>
<li>Works with differential geometry or tensor calculus</li>
</ul>
<h2 id="how-to-read-this-guide"><a class="header" href="#how-to-read-this-guide">How to Read This Guide</a></h2>
<p>Each chapter builds on the previous ones. We start with the basics:</p>
<ol>
<li><strong>Types</strong> ‚Äî the foundation of everything</li>
<li><strong>Functions</strong> ‚Äî defining computations</li>
<li><strong>Structures</strong> ‚Äî building mathematical objects</li>
</ol>
<p>Then we explore advanced features:</p>
<ol start="4">
<li><strong>Pattern matching</strong> ‚Äî elegant case analysis</li>
<li><strong>Verification</strong> ‚Äî proving things with Z3</li>
<li><strong>Applications</strong> ‚Äî real-world examples</li>
</ol>
<h2 id="a-taste-of-kleis"><a class="header" href="#a-taste-of-kleis">A Taste of Kleis</a></h2>
<p>Here‚Äôs what Kleis looks like:</p>
<pre><code class="language-kleis">// Define a function
define square(x) = x * x

// With type annotation
define double(x : ‚Ñù) : ‚Ñù = x + x

// Create a structure
structure Vector(n : ‚Ñï) {
    axiom dimension : n ‚â• 1
    operation dot : Vector(n) ‚Üí ‚Ñù
}
</code></pre>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready? Let‚Äôs dive in!</p>
<p>‚Üí <a href="#starting-out">Start with Chapter 1: Starting Out</a></p>
<hr>
<p><em>This guide is inspired by <a href="https://learnyouahaskell.github.io/">Learn You a Haskell</a> and <a href="https://learnyousomeerlang.com/">Learn You Some Erlang</a>.</em></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="starting-out"><a class="header" href="#starting-out">Starting Out</a></h1>
<h2 id="your-first-kleis-expression"><a class="header" href="#your-first-kleis-expression">Your First Kleis Expression</a></h2>
<p>The simplest things in Kleis are <strong>expressions</strong>. An expression is anything that has a value:</p>
<pre><code class="language-kleis">define answer = 42              // A number
define pi_approx = 3.14159      // A decimal
define sum(x, y) = x + y        // An arithmetic expression
define angle_sin(Œ∏) = sin(Œ∏)    // A function call
</code></pre>
<h2 id="the-repl"><a class="header" href="#the-repl">The REPL</a></h2>
<p>The easiest way to experiment with Kleis is the <strong>REPL</strong> (Read-Eval-Print Loop):</p>
<pre><code class="language-bash">$ cargo run --bin repl
Kleis REPL v0.7
Type 'help' for commands, 'quit' to exit.

kleis&gt; 2 + 2
4

kleis&gt; let x = 5 in x * x
25
</code></pre>
<h2 id="basic-arithmetic"><a class="header" href="#basic-arithmetic">Basic Arithmetic</a></h2>
<p>Kleis supports the usual arithmetic operations:</p>
<pre><code class="language-kleis">define add_example = 2 + 3       // Addition: 5
define sub_example = 10 - 4      // Subtraction: 6
define mul_example = 3 * 7       // Multiplication: 21
define div_example = 15 / 3      // Division: 5
define pow_example = 2 ^ 10      // Exponentiation: 1024
</code></pre>
<h2 id="variables-and-definitions"><a class="header" href="#variables-and-definitions">Variables and Definitions</a></h2>
<p>Use <code>define</code> to create named values:</p>
<pre><code class="language-kleis">define pi = 3.14159
define e = 2.71828
define golden_ratio = (1 + sqrt(5)) / 2
</code></pre>
<p>Functions are defined similarly:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define area_circle(r) = pi * r^2
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>Kleis uses C-style comments:</p>
<pre><code class="language-kleis">// This is a single-line comment
define x = 42  // Inline comment

/* 
   Multi-line comments
   use slash-star syntax
*/
</code></pre>
<h2 id="unicode-support"><a class="header" href="#unicode-support">Unicode Support</a></h2>
<p>Kleis embraces mathematical notation with full Unicode support:</p>
<pre><code class="language-kleis">// Greek letters
define Œ± = 0.5
define Œ≤ = 1.0
define Œ∏ = œÄ / 4

// Mathematical symbols in axioms
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x           // Universal quantifier
axiom positive_exists : ‚àÉ(y : ‚Ñù). y &gt; 0       // Existential quantifier
</code></pre>
<p>You can use ASCII alternatives too:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII Alternative</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td></tr>
<tr><td><code>√ó</code></td><td><code>*</code></td></tr>
<tr><td><code>‚Ñù</code></td><td><code>Real</code></td></tr>
<tr><td><code>‚Ñï</code></td><td><code>Nat</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next"><a class="header" href="#whats-next">What‚Äôs Next?</a></h2>
<p>Now that you can write basic expressions, let‚Äôs learn about the type system!</p>
<p>‚Üí <a href="#types-and-values">Next: Types and Values</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="types-and-values"><a class="header" href="#types-and-values">Types and Values</a></h1>
<h2 id="why-types-matter"><a class="header" href="#why-types-matter">Why Types Matter</a></h2>
<p>Types are the foundation of Kleis. Every expression has a type, and the type system catches errors before they become problems.</p>
<pre><code class="language-kleis">define answer = 42                // 42 is an integer
define pi_val = 3.14              // 3.14 is a real number
define flag = True                // True is a boolean
</code></pre>
<h2 id="built-in-types"><a class="header" href="#built-in-types">Built-in Types</a></h2>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Examples</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ñï</code> (or <code>Nat</code>)</td><td>Natural numbers (0, 1, 2, ‚Ä¶)</td><td><code>0</code>, <code>42</code>, <code>100</code></td></tr>
<tr><td><code>‚Ñ§</code> (or <code>Int</code>)</td><td>Integers (‚Ä¶, -1, 0, 1, ‚Ä¶)</td><td><code>-5</code>, <code>0</code>, <code>17</code></td></tr>
<tr><td><code>‚Ñù</code> (or <code>Real</code>)</td><td>Real numbers</td><td><code>3.14</code>, <code>-2.5</code>, <code>‚àö2</code></td></tr>
<tr><td><code>‚ÑÇ</code> (or <code>Complex</code>)</td><td>Complex numbers</td><td><code>3 + 4i</code>, <code>i</code></td></tr>
</tbody>
</table>
</div>
<h3 id="other-basic-types"><a class="header" href="#other-basic-types">Other Basic Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Description</th><th>Values</th></tr>
</thead>
<tbody>
<tr><td><code>Bool</code></td><td>Booleans</td><td><code>True</code>, <code>False</code></td></tr>
<tr><td><code>Unit</code></td><td>Unit type (like void)</td><td><code>()</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>You can explicitly annotate types with <code>:</code>:</p>
<pre><code class="language-kleis">// Variable annotation
define typed_let = let x : ‚Ñù = 3.14 in x * 2

// Function parameter and return types
define f(x : ‚Ñù) : ‚Ñù = x * x

// Expression-level annotation (ascription)
define sum_typed(a, b) = (a + b) : ‚Ñù
</code></pre>
<h2 id="function-types"><a class="header" href="#function-types">Function Types</a></h2>
<p>Functions have types too! The notation <code>A ‚Üí B</code> means ‚Äúa function from A to B‚Äù:</p>
<pre><code class="language-kleis">// square takes a Real and returns a Real
define square(x : ‚Ñù) : ‚Ñù = x * x
// Type: ‚Ñù ‚Üí ‚Ñù

// add takes two Reals and returns a Real
define add(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = x + y
// Type: ‚Ñù √ó ‚Ñù ‚Üí ‚Ñù (or equivalently: ‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù)
</code></pre>
<h3 id="higher-order-function-types"><a class="header" href="#higher-order-function-types">Higher-Order Function Types</a></h3>
<p>Functions can take other functions as arguments or return functions. These are called <strong>higher-order functions</strong>:</p>
<pre><code class="language-kleis">// A function that takes a function as an argument
define apply_twice(f : ‚Ñù ‚Üí ‚Ñù, x : ‚Ñù) : ‚Ñù = f(f(x))
// Type: (‚Ñù ‚Üí ‚Ñù) √ó ‚Ñù ‚Üí ‚Ñù

// A function that returns a function
define make_adder(n : ‚Ñù) : ‚Ñù ‚Üí ‚Ñù = ???
// Type: ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)
</code></pre>
<p>The parentheses matter! Compare:</p>
<ul>
<li><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code> ‚Äî takes a function, returns a number</li>
<li><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code> ‚Äî takes a number, returns a function</li>
<li><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code> ‚Äî curried function (associates right: <code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code>)</li>
</ul>
<h3 id="function-type-examples"><a class="header" href="#function-type-examples">Function Type Examples</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td><code>‚Ñù ‚Üí ‚Ñù</code></td><td>Function from real to real</td></tr>
<tr><td><code>‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù</code></td><td>Curried binary function</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù</code></td><td>Takes a function, returns a value (e.g., definite integral)</td></tr>
<tr><td><code>‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Returns a function (function factory)</td></tr>
<tr><td><code>(‚Ñù ‚Üí ‚Ñù) ‚Üí (‚Ñù ‚Üí ‚Ñù)</code></td><td>Function transformer (e.g., derivative operator)</td></tr>
</tbody>
</table>
</div>
<h2 id="parametric-types"><a class="header" href="#parametric-types">Parametric Types</a></h2>
<p>Types can have parameters:</p>
<pre><code class="language-kleis">// Parametric type examples:
List(‚Ñ§)           // List of integers
Matrix(3, 3, ‚Ñù)   // 3√ó3 matrix of reals
Vector(4)         // 4-dimensional vector
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Kleis often infers types automatically:</p>
<pre><code class="language-kleis">define double(x) = x + x
// Kleis infers: double : ‚Ñù ‚Üí ‚Ñù (or more general)

define square_five = let y = 5 in y * y
// Kleis infers: y : ‚Ñ§
</code></pre>
<p>But explicit types make code clearer and catch errors earlier!</p>
<h2 id="the-type-hierarchy"><a class="header" href="#the-type-hierarchy">The Type Hierarchy</a></h2>
<pre><code>        Any
       /   \
    Scalar  Collection
    /    \       |
   ‚ÑÇ    Bool   List
   |           /   \
   ‚Ñù      Vector  Matrix
   |
   ‚Ñ§
   |
   ‚Ñï
</code></pre>
<p>Note: <code>‚Ñï ‚äÇ ‚Ñ§ ‚äÇ ‚Ñù ‚äÇ ‚ÑÇ</code> (natural numbers are integers are reals are complex)</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What‚Äôs Next?</a></h2>
<p>Types are the foundation. Now let‚Äôs see how to define functions!</p>
<p>‚Üí <a href="#functions">Next: Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="defining-functions"><a class="header" href="#defining-functions">Defining Functions</a></h2>
<p>Functions are defined with <code>define</code>:</p>
<pre><code class="language-kleis">define square(x) = x * x
define cube(x) = x * x * x
define add(x, y) = x + y
</code></pre>
<h2 id="functions-with-type-annotations"><a class="header" href="#functions-with-type-annotations">Functions with Type Annotations</a></h2>
<p>For clarity and safety, add type annotations:</p>
<pre><code class="language-kleis">define square(x : ‚Ñù) : ‚Ñù = x * x

define distance(x : ‚Ñù, y : ‚Ñù) : ‚Ñù = sqrt(x^2 + y^2)

define normalize(v : Vector(3)) : Vector(3) = v / magnitude(v)
</code></pre>
<h2 id="multi-parameter-functions"><a class="header" href="#multi-parameter-functions">Multi-Parameter Functions</a></h2>
<p>Functions can take multiple parameters:</p>
<pre><code class="language-kleis">define add(x, y) = x + y
define volume_box(l, w, h) = l * w * h
define dot_product(a, b, c, x, y, z) = a*x + b*y + c*z
</code></pre>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive Functions</a></h2>
<p>Functions can call themselves:</p>
<pre><code class="language-kleis">define factorial(n : ‚Ñï) : ‚Ñï =
    if n = 0 then 1
    else n * factorial(n - 1)

define fibonacci(n : ‚Ñï) : ‚Ñï =
    if n ‚â§ 1 then n
    else fibonacci(n-1) + fibonacci(n-2)
</code></pre>
<h2 id="built-in-mathematical-functions"><a class="header" href="#built-in-mathematical-functions">Built-in Mathematical Functions</a></h2>
<p>Kleis includes standard mathematical functions:</p>
<h3 id="trigonometric"><a class="header" href="#trigonometric">Trigonometric</a></h3>
<pre><code class="language-kleis">sin(x)      cos(x)      tan(x)
asin(x)     acos(x)     atan(x)
sinh(x)     cosh(x)     tanh(x)
</code></pre>
<h3 id="exponential-and-logarithmic"><a class="header" href="#exponential-and-logarithmic">Exponential and Logarithmic</a></h3>
<pre><code class="language-kleis">exp(x)      // e^x
ln(x)       // natural log
log(x)      // base-10 log
log(b, x)   // log base b of x
</code></pre>
<h3 id="other"><a class="header" href="#other">Other</a></h3>
<pre><code class="language-kleis">sqrt(x)     // square root
abs(x)      // absolute value
floor(x)    // round down
ceil(x)     // round up
min(x, y)   // minimum
max(x, y)   // maximum
</code></pre>
<h2 id="lambda-expressions-anonymous-functions"><a class="header" href="#lambda-expressions-anonymous-functions">Lambda Expressions (Anonymous Functions)</a></h2>
<p>Lambda expressions allow you to create anonymous functions inline:</p>
<pre><code class="language-kleis">define square_lambda = Œª x . x * x
define increment = lambda x . x + 1
define add_lambda = Œª x . Œª y . x + y
define square_typed = Œª (x : ‚Ñù) . x^2
define curried_add = Œª x . Œª y . x + y
</code></pre>
<p>Lambda expressions are first-class values - you can pass them to functions:</p>
<pre><code class="language-kleis">// Pass lambda to higher-order function
define doubled_list = map(Œª x . x * 2, [1, 2, 3])

// Or define inline
define result = apply(Œª x . x + 1, 5)
</code></pre>
<h2 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher-Order Functions</a></h2>
<p>Functions can take functions as arguments:</p>
<pre><code class="language-kleis">// Apply a function twice
define apply_twice(f, x) = f(f(x))

// Example usage:
define inc(x) = x + 1
define result = apply_twice(inc, 5)   // Result: 7
</code></pre>
<h2 id="partial-application-and-currying"><a class="header" href="#partial-application-and-currying">Partial Application and Currying</a></h2>
<p>With lambda expressions, you can create curried functions:</p>
<pre><code class="language-kleis">// Curried addition
define add = Œª x . Œª y . x + y

// Partial application creates specialized functions
define add5 = add(5)           // Œª y . 5 + y
define eight = add5(3)         // Result: 8
</code></pre>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What‚Äôs Next?</a></h2>
<p>Learn about algebraic data types for structured data!</p>
<p>‚Üí <a href="#algebraic-data-types">Next: Algebraic Types</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<h2 id="what-are-adts"><a class="header" href="#what-are-adts">What Are ADTs?</a></h2>
<p>Algebraic Data Types (ADTs) let you define custom data structures by combining simpler types. There are two main kinds:</p>
<ul>
<li><strong>Product types</strong> ‚Äî ‚Äúthis AND that‚Äù (records, tuples)</li>
<li><strong>Sum types</strong> ‚Äî ‚Äúthis OR that‚Äù (variants, enums)</li>
</ul>
<h2 id="product-types"><a class="header" href="#product-types">Product Types</a></h2>
<p>A product type combines multiple values:</p>
<pre><code class="language-kleis">// A point has an x AND a y
structure Point {
    x : ‚Ñù
    y : ‚Ñù
}

// A person has a name AND an age
structure Person {
    name : String
    age : ‚Ñï
}
</code></pre>
<h2 id="sum-types-variants"><a class="header" href="#sum-types-variants">Sum Types (Variants)</a></h2>
<p>A sum type represents alternatives:</p>
<pre><code class="language-kleis">// A shape is a Circle OR a Rectangle OR a Triangle
data Shape {
    Circle(radius : ‚Ñù)
    Rectangle(width : ‚Ñù, height : ‚Ñù)
    Triangle(a : ‚Ñù, b : ‚Ñù, c : ‚Ñù)
}

// An optional value is Some(value) OR None
data Option(T) {
    Some(value : T)
    None
}

// A result is Ok(value) OR Err(message)
data Result(T, E) {
    Ok(value : T)
    Err(error : E)
}
</code></pre>
<h2 id="pattern-matching-with-adts"><a class="header" href="#pattern-matching-with-adts">Pattern Matching with ADTs</a></h2>
<p>ADTs shine with pattern matching:</p>
<pre><code class="language-kleis">define area(shape) =
    match shape {
        Circle(r) =&gt; œÄ * r^2
        Rectangle(w, h) =&gt; w * h
        Triangle(a, b, c) =&gt; 
            let s = (a + b + c) / 2 in
            sqrt(s * (s-a) * (s-b) * (s-c))
    }
</code></pre>
<h2 id="recursive-types"><a class="header" href="#recursive-types">Recursive Types</a></h2>
<p>Types can refer to themselves:</p>
<pre><code class="language-kleis">// A list is either empty (Nil) or a value followed by another list (Cons)
data List(T) {
    Nil
    Cons(head : T, tail : List(T))
}

// A binary tree
data Tree(T) {
    Leaf(value : T)
    Node(left : Tree(T), value : T, right : Tree(T))
}
</code></pre>
<h2 id="the-mathematical-perspective"><a class="header" href="#the-mathematical-perspective">The Mathematical Perspective</a></h2>
<p>Why ‚Äúalgebraic‚Äù?</p>
<ul>
<li><strong>Product types</strong> correspond to multiplication: <code>Point = ‚Ñù √ó ‚Ñù</code></li>
<li><strong>Sum types</strong> correspond to addition: <code>Option(T) = T + 1</code></li>
</ul>
<p>The number of possible values follows algebra:</p>
<ul>
<li><code>Bool</code> has 2 values</li>
<li><code>Bool √ó Bool</code> has 2 √ó 2 = 4 values</li>
<li><code>Bool + Bool</code> has 2 + 2 = 4 values</li>
</ul>
<h2 id="practical-example-expression-trees"><a class="header" href="#practical-example-expression-trees">Practical Example: Expression Trees</a></h2>
<p>ADTs are perfect for representing mathematical expressions:</p>
<pre><code class="language-kleis">data Expr {
    Const(value : ‚Ñù)
    Var(name : String)
    Add(left : Expr, right : Expr)
    Mul(left : Expr, right : Expr)
    Neg(inner : Expr)
}

define eval(expr, env) =
    match expr {
        Const(v) =&gt; v
        Var(name) =&gt; lookup(env, name)
        Add(l, r) =&gt; eval(l, env) + eval(r, env)
        Mul(l, r) =&gt; eval(l, env) * eval(r, env)
        Neg(e) =&gt; -eval(e, env)
    }
</code></pre>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What‚Äôs Next?</a></h2>
<p>Let‚Äôs dive deeper into pattern matching!</p>
<p>‚Üí <a href="#pattern-matching">Next: Pattern Matching</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<h2 id="the-power-of-match"><a class="header" href="#the-power-of-match">The Power of Match</a></h2>
<p>Pattern matching is one of Kleis‚Äôs most powerful features. It lets you destructure data and handle different cases elegantly:</p>
<pre><code class="language-kleis">define describe(n) =
    match n {
        0 =&gt; 0
        1 =&gt; 1
        _ =&gt; 2
    }
</code></pre>
<h2 id="basic-patterns"><a class="header" href="#basic-patterns">Basic Patterns</a></h2>
<h3 id="literal-patterns"><a class="header" href="#literal-patterns">Literal Patterns</a></h3>
<p>Match exact values:</p>
<pre><code class="language-kleis">define describe_literal(x) =
    match x {
        0 =&gt; "zero"
        1 =&gt; "one"
        42 =&gt; "the answer"
        _ =&gt; "something else"
    }
</code></pre>
<h3 id="variable-patterns"><a class="header" href="#variable-patterns">Variable Patterns</a></h3>
<p>Bind matched values to names:</p>
<pre><code class="language-kleis">define sum_point(point) =
    match point {
        Point(x, y) =&gt; x + y
    }
</code></pre>
<h3 id="wildcard-pattern"><a class="header" href="#wildcard-pattern">Wildcard Pattern</a></h3>
<p>The underscore <code>_</code> matches anything:</p>
<pre><code class="language-kleis">define describe_pair(pair) =
    match pair {
        (_, 0) =&gt; "second is zero"
        (0, _) =&gt; "first is zero"
        _ =&gt; "neither is zero"
    }
</code></pre>
<h2 id="nested-patterns"><a class="header" href="#nested-patterns">Nested Patterns</a></h2>
<p>Patterns can be nested arbitrarily:</p>
<pre><code class="language-kleis">define sum_tree(tree) =
    match tree {
        Leaf(v) =&gt; v
        Node(Leaf(l), v, Leaf(r)) =&gt; l + v + r
        Node(left, v, right) =&gt; v + sum_tree(left) + sum_tree(right)
    }
</code></pre>
<h2 id="guards"><a class="header" href="#guards">Guards</a></h2>
<p>Add conditions to patterns with <code>if</code>:</p>
<pre><code class="language-kleis">define sign(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        x if x &gt; 0 =&gt; "positive"
        _ =&gt; "zero"
    }
</code></pre>
<h2 id="as-patterns"><a class="header" href="#as-patterns">As-Patterns</a></h2>
<p>Bind the whole match while also destructuring:</p>
<pre><code class="language-kleis">define filter_head(list) =
    match list {
        Cons(h, t) as whole =&gt; 
            if h &gt; 10 then whole
            else t
        Nil =&gt; Nil
    }
</code></pre>
<h2 id="pattern-matching-in-let"><a class="header" href="#pattern-matching-in-let">Pattern Matching in Let</a></h2>
<p>Destructure directly in let bindings:</p>
<pre><code class="language-kleis">define distance_squared(origin) =
    let Point(x, y) = origin in x^2 + y^2

define sum_first_two(triple) =
    let (first, second, _) = triple in first + second
</code></pre>
<h2 id="pattern-matching-in-function-parameters"><a class="header" href="#pattern-matching-in-function-parameters">Pattern Matching in Function Parameters</a></h2>
<p>With lambda expressions now available, you can combine them with match:</p>
<pre><code class="language-kleis">// Pattern matching with lambdas
define fst = Œª pair . match pair { (a, _) =&gt; a }
define snd = Œª pair . match pair { (_, b) =&gt; b }
</code></pre>
<p><strong>Alternative workaround:</strong></p>
<pre><code class="language-kleis">define fst(pair) = 
    match pair {
        (a, _) =&gt; a
    }
</code></pre>
<h2 id="exhaustiveness"><a class="header" href="#exhaustiveness">Exhaustiveness</a></h2>
<p>Kleis checks that your patterns cover all cases:</p>
<pre><code class="language-kleis">// ‚ö†Ô∏è Warning: non-exhaustive patterns
define incomplete(opt) =
    match opt {
        Some(x) =&gt; x
    }

// ‚úì Complete
define complete(opt) =
    match opt {
        Some(x) =&gt; x
        None =&gt; 0
    }
</code></pre>
<h2 id="real-world-example-symbolic-differentiation"><a class="header" href="#real-world-example-symbolic-differentiation">Real-World Example: Symbolic Differentiation</a></h2>
<p>Pattern matching makes symbolic math elegant:</p>
<pre><code class="language-kleis">define diff(expr, var) =
    match expr {
        Const(_) =&gt; Const(0)
        
        Var(name) =&gt; 
            if name = var then Const(1)
            else Const(0)
        
        Add(f, g) =&gt; 
            Add(diff(f, var), diff(g, var))
        
        Mul(f, g) =&gt;
            Add(Mul(diff(f, var), g), 
                Mul(f, diff(g, var)))
        
        Neg(f) =&gt; 
            Neg(diff(f, var))
    }
</code></pre>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What‚Äôs Next?</a></h2>
<p>Learn about let bindings for local definitions!</p>
<p>‚Üí <a href="#let-bindings">Next: Let Bindings</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="let-bindings"><a class="header" href="#let-bindings">Let Bindings</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Let bindings introduce local variables with limited scope. They‚Äôre essential for breaking complex expressions into readable parts.</p>
<pre><code class="language-kleis">define square_five = let x = 5 in x * x
// Result: 25
</code></pre>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-kleis">let &lt;name&gt; = &lt;value&gt; in &lt;body&gt;
</code></pre>
<p>The variable <code>name</code> is only visible within <code>body</code>:</p>
<pre><code class="language-kleis">define circle_area = let radius = 10 in œÄ * radius^2
// Result: 314.159...
// 'radius' is not visible outside the let binding
</code></pre>
<h2 id="with-type-annotations"><a class="header" href="#with-type-annotations">With Type Annotations</a></h2>
<p>Add explicit types for clarity:</p>
<pre><code class="language-kleis">define typed_example1 = let x : ‚Ñù = 3.14 in x * 2
define typed_example2 = let n : ‚Ñï = 42 in factorial(n)
define typed_example3 = let v : Vector(3) = [1, 2, 3] in magnitude(v)
</code></pre>
<h2 id="nested-let-bindings"><a class="header" href="#nested-let-bindings">Nested Let Bindings</a></h2>
<p>Chain multiple bindings:</p>
<pre><code class="language-kleis">define nested_example =
    let x = 5 in
    let y = 3 in
    let z = x + y in
        x * y * z
// Result: 5 * 3 * 8 = 120
</code></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Inner bindings can shadow outer ones:</p>
<pre><code class="language-kleis">define shadowing_example =
    let x = 1 in
    let x = x + 1 in
    let x = x * 2 in
        x
// Result: 4  (not 1!)
</code></pre>
<p>Each <code>let</code> creates a new scope where <code>x</code> is rebound.</p>
<h2 id="pure-substitution-semantics"><a class="header" href="#pure-substitution-semantics">Pure Substitution Semantics</a></h2>
<p>In Kleis, <code>let x = e in body</code> is equivalent to substituting <code>e</code> for <code>x</code> in <code>body</code>:</p>
<pre><code class="language-kleis">define substitution_demo = let x = 5 in x + x
// is the same as:
define substitution_result = 5 + 5
</code></pre>
<p>This is <strong>pure functional semantics</strong> ‚Äî no mutation, no side effects.</p>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="quadratic-formula"><a class="header" href="#quadratic-formula">Quadratic Formula</a></h3>
<pre><code class="language-kleis">define quadratic_roots(a, b, c) =
    let discriminant = b^2 - 4*a*c in
    let sqrt_d = sqrt(discriminant) in
    let denom = 2 * a in
        ((-b + sqrt_d) / denom, (-b - sqrt_d) / denom)
</code></pre>
<h3 id="herons-formula"><a class="header" href="#herons-formula">Heron‚Äôs Formula</a></h3>
<pre><code class="language-kleis">define triangle_area(a, b, c) =
    let s = (a + b + c) / 2 in
        sqrt(s * (s - a) * (s - b) * (s - c))
</code></pre>
<h3 id="complex-calculations"><a class="header" href="#complex-calculations">Complex Calculations</a></h3>
<pre><code class="language-kleis">define schwarzschild_metric(r, M) =
    let rs = 2 * G * M / c^2 in
    let factor = 1 - rs / r in
        -c^2 * factor
</code></pre>
<h2 id="let-vs-define"><a class="header" href="#let-vs-define">Let vs Define</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>define</code></th><th><code>let ... in</code></th></tr>
</thead>
<tbody>
<tr><td>Top-level, global</td><td>Local scope only</td></tr>
<tr><td>Named function/constant</td><td>Temporary binding</td></tr>
<tr><td>Visible everywhere</td><td>Visible only in body</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-kleis">// Global constant
define pi = 3.14159

// Local temporary in a function
define circumference(radius) = let two_pi = 2 * pi in two_pi * radius
</code></pre>
<h2 id="whats-next-5"><a class="header" href="#whats-next-5">What‚Äôs Next?</a></h2>
<p>Learn about quantifiers and logic!</p>
<p>‚Üí <a href="#quantifiers-and-logic">Next: Quantifiers and Logic</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="quantifiers-and-logic"><a class="header" href="#quantifiers-and-logic">Quantifiers and Logic</a></h1>
<h2 id="universal-quantifier-"><a class="header" href="#universal-quantifier-">Universal Quantifier (‚àÄ)</a></h2>
<p>The universal quantifier expresses ‚Äúfor all‚Äù:</p>
<pre><code class="language-kleis">// Quantified propositions (used inside axioms)
axiom reflexivity : ‚àÄ(x : ‚Ñù). x = x
axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
axiom commutative : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
</code></pre>
<p>ASCII alternative: <code>forall x . ...</code></p>
<h2 id="existential-quantifier-"><a class="header" href="#existential-quantifier-">Existential Quantifier (‚àÉ)</a></h2>
<p>The existential quantifier expresses ‚Äúthere exists‚Äù:</p>
<pre><code class="language-kleis">// Existential quantifiers
axiom positive_exists : ‚àÉ(x : ‚Ñù). x &gt; 0
axiom sqrt2_exists : ‚àÉ(y : ‚Ñù). y * y = 2
axiom distinct_exists : ‚àÉ(x : ‚Ñù)(y : ‚Ñù). x ‚â† y
</code></pre>
<p>ASCII alternative: <code>exists x . ...</code></p>
<h2 id="combining-quantifiers"><a class="header" href="#combining-quantifiers">Combining Quantifiers</a></h2>
<p>Build complex statements:</p>
<pre><code class="language-kleis">// Every number has a successor
axiom successor : ‚àÄ(n : ‚Ñï). ‚àÉ(m : ‚Ñï). m = n + 1

// Density of rationals: between any two reals is a rational
axiom density : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x &lt; y ‚Üí ‚àÉ(q : ‚Ñö). x &lt; q ‚àß q &lt; y
</code></pre>
<h2 id="logical-connectives"><a class="header" href="#logical-connectives">Logical Connectives</a></h2>
<h3 id="conjunction---and"><a class="header" href="#conjunction---and">Conjunction (‚àß / and)</a></h3>
<pre><code class="language-kleis">define in_range(x) = x &gt; 0 ‚àß x &lt; 10     // x is between 0 and 10
define false_example = True ‚àß False     // False
</code></pre>
<h3 id="disjunction---or"><a class="header" href="#disjunction---or">Disjunction (‚à® / or)</a></h3>
<pre><code class="language-kleis">define is_binary(x) = x = 0 ‚à® x = 1    // x is 0 or 1
define true_example = True ‚à® False     // True
</code></pre>
<h3 id="implication---implies"><a class="header" href="#implication---implies">Implication (‚Üí / implies)</a></h3>
<pre><code class="language-kleis">define sqrt_real(x) = x &gt; 0 ‚Üí sqrt(x) ‚àà ‚Ñù    // If positive, has real square root
define implication(P, Q) = P ‚Üí Q              // If P then Q
</code></pre>
<h3 id="negation---not"><a class="header" href="#negation---not">Negation (¬¨ / not)</a></h3>
<pre><code class="language-kleis">define nonzero(x) = ¬¨(x = 0)     // x is not zero
define not_true = ¬¨True          // False
</code></pre>
<h3 id="biconditional---iff"><a class="header" href="#biconditional---iff">Biconditional (‚Üî / iff)</a></h3>
<pre><code class="language-kleis">define zero_iff_square_zero(x) = x = 0 ‚Üî x * x = 0  // x is zero iff x¬≤ is zero
</code></pre>
<h2 id="type-constraints-in-quantifiers"><a class="header" href="#type-constraints-in-quantifiers">Type Constraints in Quantifiers</a></h2>
<p>Restrict the domain:</p>
<pre><code class="language-kleis">axiom naturals_nonneg : ‚àÄ(x : ‚Ñï). x ‚â• 0
axiom det_inverse : ‚àÄ(M : Matrix(n, n)). det(M * M‚Åª¬π) = 1
</code></pre>
<h2 id="using-quantifiers-in-axioms"><a class="header" href="#using-quantifiers-in-axioms">Using Quantifiers in Axioms</a></h2>
<p>Quantifiers are essential in structure axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G                      // Identity element
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x ‚àß mul(x, e) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h2 id="verification-with-z3"><a class="header" href="#verification-with-z3">Verification with Z3</a></h2>
<p>Kleis uses Z3 to check quantified statements:</p>
<pre><code class="language-kleis">// Z3 can verify this is always true:
axiom add_zero : ‚àÄ(x : ‚Ñù). x + 0 = x

// Z3 can find a counterexample for this:
axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="truth-tables"><a class="header" href="#truth-tables">Truth Tables</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>P</th><th>Q</th><th>P ‚àß Q</th><th>P ‚à® Q</th><th>P ‚Üí Q</th><th>¬¨P</th></tr>
</thead>
<tbody>
<tr><td>T</td><td>T</td><td>T</td><td>T</td><td>T</td><td>F</td></tr>
<tr><td>T</td><td>F</td><td>F</td><td>T</td><td>F</td><td>F</td></tr>
<tr><td>F</td><td>T</td><td>F</td><td>T</td><td>T</td><td>T</td></tr>
<tr><td>F</td><td>F</td><td>F</td><td>F</td><td>T</td><td>T</td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next-6"><a class="header" href="#whats-next-6">What‚Äôs Next?</a></h2>
<p>Learn about conditional expressions!</p>
<p>‚Üí <a href="#conditionals">Next: Conditionals</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="conditionals"><a class="header" href="#conditionals">Conditionals</a></h1>
<h2 id="if-then-else"><a class="header" href="#if-then-else">If-Then-Else</a></h2>
<p>The basic conditional expression:</p>
<pre><code class="language-kleis">if condition then value1 else value2
</code></pre>
<p>Examples:</p>
<pre><code class="language-kleis">define positive_check(x) = if x &gt; 0 then "positive" else "non-positive"

define factorial(n) = if n = 0 then 1 else n * factorial(n - 1)

define abs(x) = if x ‚â• 0 then x else -x
</code></pre>
<h2 id="conditionals-are-expressions"><a class="header" href="#conditionals-are-expressions">Conditionals Are Expressions</a></h2>
<p>In Kleis, <code>if-then-else</code> is an expression that returns a value:</p>
<pre><code class="language-kleis">define doubled_abs(x) =
    let result = if x &gt; 0 then x else -x in
    result * 2

// Both branches must have compatible types!
// if True then 42 else "hello"  // ‚ùå Type error!
</code></pre>
<h2 id="nested-conditionals"><a class="header" href="#nested-conditionals">Nested Conditionals</a></h2>
<pre><code class="language-kleis">define sign(x) =
    if x &gt; 0 then 1
    else if x &lt; 0 then -1
    else 0

define grade(score) =
    if score ‚â• 90 then "A"
    else if score ‚â• 80 then "B"
    else if score ‚â• 70 then "C"
    else if score ‚â• 60 then "D"
    else "F"
</code></pre>
<h2 id="guards-vs-if-then-else"><a class="header" href="#guards-vs-if-then-else">Guards vs If-Then-Else</a></h2>
<p>Pattern matching with guards is often cleaner:</p>
<pre><code class="language-kleis">// With if-then-else
define classify_if(n) =
    if n &lt; 0 then "negative"
    else if n = 0 then "zero"
    else "positive"

// With pattern matching and guards
define classify_match(n) =
    match n {
        x if x &lt; 0 =&gt; "negative"
        0 =&gt; "zero"
        _ =&gt; "positive"
    }
</code></pre>
<h2 id="piecewise-functions"><a class="header" href="#piecewise-functions">Piecewise Functions</a></h2>
<p>Mathematicians love piecewise definitions:</p>
<pre><code class="language-kleis">// Absolute value
define abs_fn(x) =
    if x ‚â• 0 then x else -x

// Heaviside step function
define heaviside(x) =
    if x &lt; 0 then 0
    else if x = 0 then 0.5
    else 1

// Piecewise polynomial
define piecewise_f(x) =
    if x &lt; 0 then x^2
    else if x &lt; 1 then x
    else 2 - x
</code></pre>
<h2 id="boolean-expressions"><a class="header" href="#boolean-expressions">Boolean Expressions</a></h2>
<p>Conditions can be complex:</p>
<pre><code class="language-kleis">define quadrant(x, y) =
    if x &gt; 0 ‚àß y &gt; 0 then "first quadrant"
    else if x &lt; 0 ‚àß y &gt; 0 then "second quadrant"
    else if x &lt; 0 ‚àß y &lt; 0 then "third quadrant"
    else if x &gt; 0 ‚àß y &lt; 0 then "fourth quadrant"
    else "on an axis"
</code></pre>
<h2 id="short-circuit-evaluation"><a class="header" href="#short-circuit-evaluation">Short-Circuit Evaluation</a></h2>
<p>Kleis uses short-circuit evaluation for <code>‚àß</code> and <code>‚à®</code>:</p>
<pre><code class="language-kleis">// If x = 0, division is never evaluated
define check_ratio(x, y) =
    if x ‚â† 0 ‚àß y/x &gt; 1 then "big ratio" else "safe"
</code></pre>
<h2 id="whats-next-7"><a class="header" href="#whats-next-7">What‚Äôs Next?</a></h2>
<p>Learn about structures for defining mathematical objects!</p>
<p>‚Üí <a href="#structures">Next: Structures</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<h2 id="what-are-structures"><a class="header" href="#what-are-structures">What Are Structures?</a></h2>
<p>Structures define mathematical objects with their properties and operations. Think of them as ‚Äúblueprints‚Äù for mathematical concepts.</p>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï) {
    // Operations this structure supports
    operation add : Vector(n) ‚Üí Vector(n)
    operation scale : ‚Ñù ‚Üí Vector(n)
    operation dot : Vector(n) ‚Üí ‚Ñù
    
    // Properties that must hold
    axiom commutative : ‚àÄ(u : Vector(n))(v : Vector(n)).
        add(u, v) = add(v, u)
}
</code></pre>
<h2 id="structure-syntax"><a class="header" href="#structure-syntax">Structure Syntax</a></h2>
<pre><code class="language-kleis">structure Name(parameters) {
    // Fields (data) - no "field" keyword needed
    field1 : Type1
    field2 : Type2
    
    // Operations (functions)
    operation op1 : InputType ‚Üí OutputType
    
    // Axioms (properties)
    axiom property : logical_statement
}
</code></pre>
<h2 id="example-complex-numbers"><a class="header" href="#example-complex-numbers">Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">structure Complex {
    re : ‚Ñù  // real part
    im : ‚Ñù  // imaginary part
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex           // conjugate
    operation mag : ‚Ñù                  // magnitude
    
    axiom add_commutative : ‚àÄ(z : Complex)(w : Complex).
        add(z, w) = add(w, z)
        
    axiom magnitude_positive : ‚àÄ(z : Complex).
        mag(z) ‚â• 0
        
    axiom conj_involution : ‚àÄ(z : Complex).
        conj(conj(z)) = z
}
</code></pre>
<h2 id="parametric-structures"><a class="header" href="#parametric-structures">Parametric Structures</a></h2>
<p>Structures can have type parameters:</p>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    
    axiom transpose_involution : ‚àÄ(A : Matrix(m, n, T)).
        transpose(transpose(A)) = A
}

// Square matrices have more operations
structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    
    axiom det_mul : ‚àÄ(A : SquareMatrix(n, T))(B : SquareMatrix(n, T)).
        det(mul(A, B)) = det(A) * det(B)
}
</code></pre>
<h2 id="nested-structures"><a class="header" href="#nested-structures">Nested Structures</a></h2>
<p>Structures can contain other structures. This enables compositional algebra ‚Äî defining complex structures from simpler parts:</p>
<pre><code class="language-kleis">structure Ring(R) {
    // A ring has an additive group
    structure additive : AbelianGroup(R) {
        operation add : R √ó R ‚Üí R
        operation negate : R ‚Üí R
        zero : R
    }
    
    // And a multiplicative monoid
    structure multiplicative : Monoid(R) {
        operation mul : R √ó R ‚Üí R
        one : R
    }
    
    // With distributivity connecting them
    axiom distributive : ‚àÄ(x : R)(y : R)(z : R).
        mul(x, add(y, z)) = add(mul(x, y), mul(x, z))
}
</code></pre>
<p>Nested structures can go arbitrarily deep:</p>
<pre><code class="language-kleis">structure VectorSpace(V, F) {
    structure vectors : AbelianGroup(V) {
        operation add : V √ó V ‚Üí V
        zero : V
    }
    
    structure scalars : Field(F) {
        operation add : F √ó F ‚Üí F
        operation mul : F √ó F ‚Üí F
    }
    
    operation scale : F √ó V ‚Üí V
}
</code></pre>
<p>When using Z3 verification, axioms from nested structures are automatically available.</p>
<h2 id="the-extends-keyword"><a class="header" href="#the-extends-keyword">The <code>extends</code> Keyword</a></h2>
<p>Structures can extend other structures:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
    
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e ‚àß mul(inv(x), x) = e
}

structure AbelianGroup(G) extends Group(G) {
    axiom commutative : ‚àÄ(x : G)(y : G). mul(x, y) = mul(y, x)
}
</code></pre>
<h2 id="the-where-clause"><a class="header" href="#the-where-clause">The <code>where</code> Clause</a></h2>
<p>Constrain type parameters:</p>
<pre><code class="language-kleis">structure VectorSpace(V, F) where F : Field {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    
    axiom distributive : ‚àÄ(a : F)(u : V)(v : V).
        scale(a, add(u, v)) = add(scale(a, u), scale(a, v))
}
</code></pre>
<h2 id="the-over-keyword"><a class="header" href="#the-over-keyword">The <code>over</code> Keyword</a></h2>
<p>Many mathematical structures are defined ‚Äúover‚Äù a base structure. A vector space is defined over a field, a module over a ring:</p>
<pre><code class="language-kleis">// Vector space over a field
structure VectorSpace(V) over Field(F) {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    
    axiom scalar_identity : ‚àÄ(v : V). scale(1, v) = v
    axiom distributive : ‚àÄ(a : F)(u : V)(v : V).
        scale(a, add(u, v)) = add(scale(a, u), scale(a, v))
}

// Module over a ring (generalization of vector space)
structure Module(M) over Ring(R) {
    operation add : M √ó M ‚Üí M
    operation scale : R √ó M ‚Üí M
}

// Algebra over a ring
structure Algebra(A) over Ring(R) {
    operation add : A √ó A ‚Üí A
    operation scale : R √ó A ‚Üí A
    operation mul : A √ó A ‚Üí A
    
    axiom bilinear : ‚àÄ(r : R)(a : A)(b : A).
        scale(r, mul(a, b)) = mul(scale(r, a), b)
}
</code></pre>
<p>When you use <code>over</code>, Kleis automatically makes the base structure‚Äôs axioms available for verification. For example, when verifying <code>VectorSpace</code> axioms, Z3 knows that <code>F</code> satisfies all <code>Field</code> axioms.</p>
<h2 id="differential-geometry-structures"><a class="header" href="#differential-geometry-structures">Differential Geometry Structures</a></h2>
<p>Kleis shines for differential geometry:</p>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(M)
    operation metric : M ‚Üí Tensor(0, 2)
    
    axiom metric_symmetric : ‚àÄ(p : M).
        metric(p) = transpose(metric(p))
}

structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Tensor(0, 2)
    operation scalar_curvature : M ‚Üí ‚Ñù
    
    // R^a_{bcd} + R^a_{cdb} + R^a_{dbc} = 0
    axiom first_bianchi : ‚àÄ(p : M).
        cyclic_sum(riemann(p)) = 0
}
</code></pre>
<h2 id="whats-next-8"><a class="header" href="#whats-next-8">What‚Äôs Next?</a></h2>
<p>Learn how to implement structures!</p>
<p>‚Üí <a href="#implements">Next: Implements</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="implements"><a class="header" href="#implements">Implements</a></h1>
<h2 id="from-structure-to-implementation"><a class="header" href="#from-structure-to-implementation">From Structure to Implementation</a></h2>
<p>A <code>structure</code> declares what operations exist. An <code>implements</code> block provides the actual definitions:</p>
<pre><code class="language-kleis">structure Addable(T) {
    operation add : T √ó T ‚Üí T
}

implements Addable(‚Ñù) {
    operation add(x, y) = x + y
}

implements Addable(‚Ñ§) {
    operation add(x, y) = x + y
}
</code></pre>
<h2 id="full-example-complex-numbers"><a class="header" href="#full-example-complex-numbers">Full Example: Complex Numbers</a></h2>
<pre><code class="language-kleis">// Declare the structure
structure Complex {
    re : ‚Ñù
    im : ‚Ñù
    
    operation add : Complex ‚Üí Complex
    operation mul : Complex ‚Üí Complex
    operation conj : Complex
    operation mag : ‚Ñù
}

// Implement the operations
implements Complex {
    operation add(z, w) = builtin_complex_add
    operation mul(z, w) = builtin_complex_mul
    operation conj(z) = builtin_complex_conj
    operation mag(z) = sqrt(z.re^2 + z.im^2)
}
</code></pre>
<h2 id="parametric-implementations"><a class="header" href="#parametric-implementations">Parametric Implementations</a></h2>
<p>Implement structures with type parameters:</p>
<pre><code class="language-kleis">structure Stack(T) {
    operation push : T ‚Üí Stack(T)
    operation pop : Stack(T)
    operation top : T
    operation empty : Bool
}

implements Stack(‚Ñ§) {
    operation push = builtin_stack_push
    operation pop = builtin_stack_pop
    operation top = builtin_stack_top
    operation empty = builtin_stack_empty
}
</code></pre>
<h2 id="multiple-implementations"><a class="header" href="#multiple-implementations">Multiple Implementations</a></h2>
<p>The same structure can have multiple implementations:</p>
<pre><code class="language-kleis">structure Orderable(T) {
    operation compare : T √ó T ‚Üí Ordering
}

// Natural ordering
implements Orderable(‚Ñ§) {
    operation compare = builtin_int_compare
}
</code></pre>
<h2 id="implementing-extended-structures"><a class="header" href="#implementing-extended-structures">Implementing Extended Structures</a></h2>
<p>When a structure extends another, implement all operations:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    operation e : M
    operation mul : M √ó M ‚Üí M
}

structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G
}

// Must implement both Monoid and Group operations
implements Group(‚Ñ§) {
    operation e = 0
    operation mul(x, y) = x + y
    operation inv(x) = -x
}
</code></pre>
<h2 id="builtin-operations"><a class="header" href="#builtin-operations">Builtin Operations</a></h2>
<p>Some operations can‚Äôt be defined in pure Kleis ‚Äî they need native code. The <code>builtin_</code> prefix connects Kleis to underlying implementations:</p>
<pre><code class="language-kleis">implements Matrix(m, n, ‚Ñù) {
    operation transpose = builtin_transpose
    operation add = builtin_matrix_add
    operation mul = builtin_matrix_mul
}
</code></pre>
<h3 id="how-builtins-work"><a class="header" href="#how-builtins-work">How Builtins Work</a></h3>
<p>When Kleis sees <code>builtin_foo</code>, it:</p>
<ol>
<li>Looks up <code>foo</code> in the native runtime</li>
<li>Calls the Rust/C/hardware implementation</li>
<li>Returns the result to Kleis</li>
</ol>
<p>This enables:</p>
<ul>
<li><strong>Performance</strong>: Native BLAS for matrix operations</li>
<li><strong>Hardware access</strong>: GPUs, network cards, sensors</li>
<li><strong>System calls</strong>: File I/O, networking, threading</li>
<li><strong>FFI</strong>: Calling existing libraries</li>
</ul>
<h3 id="the-vision-hardware-as-structures"><a class="header" href="#the-vision-hardware-as-structures">The Vision: Hardware as Structures</a></h3>
<p>Imagine:</p>
<pre><code class="language-kleis">structure NetworkInterface(N) {
    operation send : Packet ‚Üí Result(Unit, Error)
    operation receive : Unit ‚Üí Result(Packet, Error)
    
    axiom delivery : ‚àÄ(p : Packet).
        connected ‚Üí eventually(delivered(p))
}

implements NetworkInterface(EthernetCard) {
    operation send = builtin_eth_send
    operation receive = builtin_eth_receive
}
</code></pre>
<p>The <strong>axioms</strong> define the contract. The <strong>builtins</strong> provide the implementation. Z3 can verify that higher-level protocols satisfy their specifications <em>given</em> the hardware axioms.</p>
<p>This is how Kleis becomes a <strong>universal verification platform</strong> ‚Äî not just for math, but for any system with verifiable properties.</p>
<h2 id="verification-of-implementations"><a class="header" href="#verification-of-implementations">Verification of Implementations</a></h2>
<p>Kleis + Z3 can verify that implementations satisfy axioms:</p>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M
    operation mul : M √ó M ‚Üí M
    
    axiom identity : ‚àÄ(x : M). mul(e, x) = x ‚àß mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

implements Monoid(String) {
    element e = ""
    operation mul = builtin_concat
}

// Kleis can verify:
// 1. concat("", s) = s for all s ‚úì
// 2. concat(s, "") = s for all s ‚úì
// 3. concat(concat(a, b), c) = concat(a, concat(b, c)) ‚úì
</code></pre>
<h2 id="whats-next-9"><a class="header" href="#whats-next-9">What‚Äôs Next?</a></h2>
<p>Learn about Z3 verification in depth!</p>
<p>‚Üí <a href="#z3-verification">Next: Z3 Verification</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="z3-verification"><a class="header" href="#z3-verification">Z3 Verification</a></h1>
<h2 id="what-is-z3"><a class="header" href="#what-is-z3">What is Z3?</a></h2>
<p><a href="https://github.com/Z3Prover/z3">Z3</a> is a theorem prover from Microsoft Research. Kleis uses Z3 to:</p>
<ul>
<li><strong>Verify</strong> mathematical statements</li>
<li><strong>Find counterexamples</strong> when statements are false</li>
<li><strong>Check</strong> that implementations satisfy axioms</li>
</ul>
<h2 id="basic-verification"><a class="header" href="#basic-verification">Basic Verification</a></h2>
<p>Use <code>verify</code> to check a statement:</p>
<pre><code class="language-kleis">axiom commutativity : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). x + y = y + x
// Z3 verifies: ‚úì Valid

axiom zero_annihilates : ‚àÄ(x : ‚Ñù). x * 0 = 0
// Z3 verifies: ‚úì Valid

axiom all_positive : ‚àÄ(x : ‚Ñù). x &gt; 0
// Z3 finds counterexample: x = -1
</code></pre>
<h2 id="verifying-quantified-statements"><a class="header" href="#verifying-quantified-statements">Verifying Quantified Statements</a></h2>
<p>Z3 handles universal and existential quantifiers:</p>
<pre><code class="language-kleis">axiom additive_identity : ‚àÄ(x : ‚Ñù). x + 0 = x
// Z3 verifies: ‚úì Valid

axiom squares_nonnegative : ‚àÄ(x : ‚Ñù). x * x ‚â• 0
// Z3 verifies: ‚úì Valid (squares are non-negative)

axiom no_real_sqrt_neg1 : ‚àÉ(x : ‚Ñù). x * x = -1
// Z3: ‚úó Invalid (no real square root of -1)

axiom complex_sqrt_neg1 : ‚àÉ(x : ‚ÑÇ). x * x = -1
// Z3 verifies: ‚úì Valid (x = i works)
</code></pre>
<h2 id="checking-axioms"><a class="header" href="#checking-axioms">Checking Axioms</a></h2>
<p>Verify that definitions satisfy axioms:</p>
<pre><code class="language-kleis">structure Group(G) {
    e : G
    operation mul : G √ó G ‚Üí G
    operation inv : G ‚Üí G
    
    axiom identity : ‚àÄ(x : G). mul(e, x) = x
    axiom inverse : ‚àÄ(x : G). mul(x, inv(x)) = e
    axiom associative : ‚àÄ(x : G)(y : G)(z : G).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}

// Define integers with addition
implements Group(‚Ñ§) {
    element e = 0
    operation mul = builtin_add
    operation inv = builtin_negate
}

// Kleis verifies each axiom automatically!
</code></pre>
<h2 id="implication-verification"><a class="header" href="#implication-verification">Implication Verification</a></h2>
<p>Prove that premises imply conclusions:</p>
<pre><code class="language-kleis">// If x &gt; 0 and y &gt; 0, then x + y &gt; 0
axiom sum_positive : ‚àÄ(x : ‚Ñù)(y : ‚Ñù). (x &gt; 0 ‚àß y &gt; 0) ‚Üí x + y &gt; 0
// Z3 verifies: ‚úì Valid

// Triangle inequality
axiom triangle_ineq : ‚àÄ(x : ‚Ñù)(y : ‚Ñù)(a : ‚Ñù)(b : ‚Ñù).
    (abs(x) ‚â§ a ‚àß abs(y) ‚â§ b) ‚Üí abs(x + y) ‚â§ a + b
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="counterexamples"><a class="header" href="#counterexamples">Counterexamples</a></h2>
<p>When verification fails, Z3 provides counterexamples:</p>
<pre><code class="language-kleis">axiom square_equals_self : ‚àÄ(x : ‚Ñù). x^2 = x
// Z3: ‚úó Invalid, Counterexample: x = 2 (since 4 ‚â† 2)

axiom positive_greater_than_one : ‚àÄ(n : ‚Ñï). n &gt; 0 ‚Üí n &gt; 1
// Z3: ‚úó Invalid, Counterexample: n = 1
</code></pre>
<h2 id="timeout-and-limits"><a class="header" href="#timeout-and-limits">Timeout and Limits</a></h2>
<p>Complex statements may time out:</p>
<pre><code class="language-kleis">// Very complex statement
verify ‚àÄ M : Matrix(100, 100) . det(M * M') ‚â• 0
// Result: ‚è± Timeout (statement too complex)
</code></pre>
<h2 id="what-z3-can-and-cannot-do"><a class="header" href="#what-z3-can-and-cannot-do">What Z3 Can and Cannot Do</a></h2>
<h3 id="z3-excels-at"><a class="header" href="#z3-excels-at">Z3 Excels At:</a></h3>
<ul>
<li>Linear arithmetic</li>
<li>Boolean logic</li>
<li>Array reasoning</li>
<li>Simple quantifiers</li>
<li>Algebraic identities</li>
</ul>
<h3 id="z3-struggles-with"><a class="header" href="#z3-struggles-with">Z3 Struggles With:</a></h3>
<ul>
<li>Non-linear real arithmetic (undecidable in general)</li>
<li>Very deep quantifier nesting</li>
<li>Transcendental functions (sin, cos, exp)</li>
<li>Infinite structures</li>
</ul>
<h2 id="practical-workflow"><a class="header" href="#practical-workflow">Practical Workflow</a></h2>
<ol>
<li><strong>Write structure with axioms</strong></li>
<li><strong>Implement operations</strong></li>
<li><strong>Kleis auto-verifies</strong> axioms are satisfied</li>
<li><strong>Use <code>verify</code></strong> for additional properties</li>
<li><strong>Examine counterexamples</strong> when verification fails</li>
</ol>
<pre><code class="language-kleis">// Step 1: Define structure
structure Ring(R) {
    zero : R
    one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    axiom add_assoc : ‚àÄ(a : R)(b : R)(c : R).
        add(add(a, b), c) = add(a, add(b, c))
}

// Step 2: Implement for integers
implements Ring(‚Ñ§) {
    element zero = 0
    element one = 1
    operation add = builtin_add
    operation mul = builtin_mul
    operation neg = builtin_negate
}

// Step 3: Auto-verification happens!

// Step 4: Check additional properties
axiom mul_zero : ‚àÄ(x : ‚Ñ§). mul(x, zero) = zero
// Z3 verifies: ‚úì Valid
</code></pre>
<h2 id="whats-next-10"><a class="header" href="#whats-next-10">What‚Äôs Next?</a></h2>
<p>Try the interactive REPL!</p>
<p>‚Üí <a href="#the-repl-1">Next: The REPL</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="the-repl-1"><a class="header" href="#the-repl-1">The REPL</a></h1>
<h2 id="what-is-the-repl"><a class="header" href="#what-is-the-repl">What is the REPL?</a></h2>
<p>The REPL (Read-Eval-Print Loop) is an interactive environment for experimenting with Kleis:</p>
<pre><code class="language-bash">$ cargo run --bin repl
Kleis REPL v0.7
Type 'help' for commands, 'quit' to exit.

kleis&gt;
</code></pre>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Enter expressions to evaluate them:</p>
<pre><code>Œª&gt; 2 + 2
2 + 2

Œª&gt; let x = 5 in x * x
times(5, 5)

Œª&gt; sin(œÄ / 2)
sin(divide(œÄ, 2))
</code></pre>
<h2 id="defining-functions-1"><a class="header" href="#defining-functions-1">Defining Functions</a></h2>
<p>Define functions interactively:</p>
<pre><code>Œª&gt; define square(x) = x * x
‚ùå Parse error: Kleis parse error at position 7: Unexpected character: 's'

Œª&gt; square(7)
square(7)

Œª&gt; define compose(f, g, x) = f(g(x))
‚ùå Parse error: Kleis parse error at position 7: Unexpected character: 'c'

Œª&gt; compose(square, square, 2)
compose(square, square, 2)
</code></pre>
<h2 id="working-with-types"><a class="header" href="#working-with-types">Working with Types</a></h2>
<p>Check types and use annotations:</p>
<pre><code>Œª&gt; type 42
‚ùå Parse error: Kleis parse error at position 5: Unexpected character: '4'

Œª&gt; :type sin
üìê Type: Œ±0

Œª&gt; let x : ‚Ñù = 3.14 in x * 2
times(3.14, 2)
</code></pre>
<h2 id="repl-commands"><a class="header" href="#repl-commands">REPL Commands</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Command</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>:help</code> or <code>?</code></td><td>Show help</td></tr>
<tr><td><code>:type &lt;expr&gt;</code></td><td>Show expression type</td></tr>
<tr><td><code>:quit</code> or <code>q</code></td><td>Exit REPL</td></tr>
<tr><td><code>:clear</code></td><td>Clear definitions</td></tr>
<tr><td><code>:load &lt;file&gt;</code></td><td>Load Kleis file</td></tr>
<tr><td><code>:env</code></td><td>Show current environment</td></tr>
</tbody>
</table>
</div>
<h2 id="loading-files"><a class="header" href="#loading-files">Loading Files</a></h2>
<p>Load Kleis source files:</p>
<pre><code>kleis&gt; :load stdlib/prelude.kleis
Loaded: stdlib/prelude.kleis

kleis&gt; :load examples/geometry.kleis
Loaded: examples/geometry.kleis
</code></pre>
<h2 id="verification-in-repl"><a class="header" href="#verification-in-repl">Verification in REPL</a></h2>
<p>Run verifications interactively:</p>
<pre><code>kleis&gt; verify x + y = y + x
‚úì Valid

kleis&gt; verify ‚àÄ n : ‚Ñï . n ‚â• 0
‚úì Valid

kleis&gt; verify x &gt; 0
‚úó Invalid
Counterexample: x = -1
</code></pre>
<h2 id="multi-line-input"><a class="header" href="#multi-line-input">Multi-line Input</a></h2>
<p>For complex expressions, use continuation:</p>
<pre><code>kleis&gt; define factorial(n) =
...&gt;     if n = 0 then 1
...&gt;     else n * factorial(n - 1)
Defined: factorial
</code></pre>
<h2 id="lambda-expressions-in-repl"><a class="header" href="#lambda-expressions-in-repl">Lambda Expressions in REPL</a></h2>
<p>Lambda expressions work in the REPL:</p>
<pre><code>kleis&gt; Œª x . x * 2
Œª x . x * 2

kleis&gt; (Œª x . x + 1)(5)
6

kleis&gt; define double = Œª x . x * 2
Defined: double

kleis&gt; double(21)
42
</code></pre>
<p>You can use both the <code>Œª</code> symbol and the <code>lambda</code> keyword.</p>
<h2 id="example-session"><a class="header" href="#example-session">Example Session</a></h2>
<pre><code>kleis&gt; // Define a structure
kleis&gt; structure Point { x : ‚Ñù, y : ‚Ñù }

kleis&gt; // Create a point
kleis&gt; let p = Point { x = 3, y = 4 } in
...&gt;     sqrt(p.x^2 + p.y^2)
5.0

kleis&gt; // Verify properties
kleis&gt; verify ‚àÄ a : ‚Ñù . ‚àÄ b : ‚Ñù . (a + b)^2 = a^2 + 2*a*b + b^2
‚úì Valid

kleis&gt; :quit
Goodbye!
</code></pre>
<h2 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h2>
<ol>
<li><strong>Use tab completion</strong> for function names</li>
<li><strong>Arrow keys</strong> navigate history</li>
<li><strong>Ctrl+C</strong> cancels current input</li>
<li><strong>Ctrl+D</strong> exits (like <code>:quit</code>)</li>
</ol>
<h2 id="whats-next-11"><a class="header" href="#whats-next-11">What‚Äôs Next?</a></h2>
<p>See practical applications!</p>
<p>‚Üí <a href="#applications">Next: Applications</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<h2 id="differential-geometry"><a class="header" href="#differential-geometry">Differential Geometry</a></h2>
<p>Kleis excels at differential geometry calculations:</p>
<pre><code class="language-kleis">// Christoffel symbols for spherical coordinates
structure SphericalMetric {
    operation metric : (‚Ñù, ‚Ñù) ‚Üí Matrix(2, 2, ‚Ñù)
    operation christoffel : (‚Ñù, ‚Ñù) ‚Üí Tensor(1, 2)
}

implements SphericalMetric {
    // Metric tensor: ds¬≤ = r¬≤(dŒ∏¬≤ + sin¬≤Œ∏ dœÜ¬≤)
    operation metric(r, Œ∏) = Matrix [
        [r^2, 0],
        [0, r^2 * sin(Œ∏)^2]
    ]
    
    // Christoffel symbols Œì‚Å±‚±º‚Çñ
    operation christoffel(r, Œ∏) = 
        let g = metric(r, Œ∏) in
        let g_inv = inverse(g) in
        // ... compute from metric derivatives
}
</code></pre>
<h2 id="tensor-calculus"><a class="header" href="#tensor-calculus">Tensor Calculus</a></h2>
<pre><code class="language-kleis">// Einstein field equations
structure EinsteinEquations {
    // Ricci tensor
    operation ricci : Manifold ‚Üí Tensor(0, 2)
    // Scalar curvature
    operation scalar : Manifold ‚Üí ‚Ñù
    // Einstein tensor
    operation einstein : Manifold ‚Üí Tensor(0, 2)
    
    axiom einstein_tensor : ‚àÄ(M : Manifold).
        einstein(M) = ricci(M) - (scalar(M) / 2) * metric(M)
}
</code></pre>
<h2 id="symbolic-differentiation"><a class="header" href="#symbolic-differentiation">Symbolic Differentiation</a></h2>
<pre><code class="language-kleis">data Expr {
    Const(value : ‚Ñù)
    Var(name : String)
    Add(left : Expr, right : Expr)
    Mul(left : Expr, right : Expr)
    Pow(base : Expr, exp : Expr)
    Sin(arg : Expr)
    Cos(arg : Expr)
    Exp(arg : Expr)
    Ln(arg : Expr)
}

define diff(e, x) =
    match e {
        Const(_) =&gt; Const(0)
        Var(y) =&gt; if y = x then Const(1) else Const(0)
        
        Add(f, g) =&gt; Add(diff(f, x), diff(g, x))
        
        Mul(f, g) =&gt;
            Add(Mul(diff(f, x), g), Mul(f, diff(g, x)))
            
        Pow(f, Const(n)) =&gt;
            Mul(Mul(Const(n), Pow(f, Const(n - 1))), diff(f, x))
            
        Sin(f) =&gt; Mul(Cos(f), diff(f, x))
        Cos(f) =&gt; Mul(Mul(Const(-1), Sin(f)), diff(f, x))
        Exp(f) =&gt; Mul(Exp(f), diff(f, x))
        Ln(f) =&gt; Mul(Pow(f, Const(-1)), diff(f, x))
        
        _ =&gt; Const(0)
    }
</code></pre>
<h2 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h2>
<pre><code class="language-kleis">structure LinearSystem(n : ‚Ñï) {
    operation solve : Matrix(n, n, ‚Ñù) √ó Vector(n, ‚Ñù) ‚Üí Vector(n, ‚Ñù)
    
    // Solution satisfies Ax = b
    axiom solution_correct : ‚àÄ(A : Matrix(n, n, ‚Ñù))(b : Vector(n, ‚Ñù)).
        det(A) ‚â† 0 ‚Üí mul(A, solve(A, b)) = b
}

// Eigenvalue problem
structure Eigen(n : ‚Ñï) {
    operation eigenvalues : Matrix(n, n, ‚ÑÇ) ‚Üí List(‚ÑÇ)
    operation eigenvectors : Matrix(n, n, ‚ÑÇ) ‚Üí List(Vector(n, ‚ÑÇ))
    
    axiom eigenpair : ‚àÄ(A : Matrix(n, n, ‚ÑÇ))(i : ‚Ñï).
        let lambda = nth(eigenvalues(A), i) in
        let v = nth(eigenvectors(A), i) in
            mul(A, v) = scale(lambda, v)
}
</code></pre>
<h2 id="quantum-mechanics"><a class="header" href="#quantum-mechanics">Quantum Mechanics</a></h2>
<pre><code class="language-kleis">structure QuantumState(n : ‚Ñï) {
    amplitudes : Vector(n, ‚ÑÇ)
    
    // States must be normalized
    axiom normalized : ‚àÄ(psi : QuantumState(n)).
        sum(map(Œª a . abs(a)^2, psi.amplitudes)) = 1
}

structure Observable(n : ‚Ñï) {
    operation matrix : Matrix(n, n, ‚ÑÇ)
    
    // Observables are Hermitian
    axiom hermitian : ‚àÄ(O : Observable(n)).
        O.matrix = conjugate_transpose(O.matrix)
}

// Expectation value
define expectation(psi, O) =
    real(inner_product(psi.amplitudes, mul(O.matrix, psi.amplitudes)))
</code></pre>
<h2 id="category-theory"><a class="header" href="#category-theory">Category Theory</a></h2>
<pre><code class="language-kleis">structure Category(Obj, Mor) {
    operation id : Obj ‚Üí Mor
    operation compose : Mor √ó Mor ‚Üí Mor
    operation dom : Mor ‚Üí Obj
    operation cod : Mor ‚Üí Obj
    
    axiom identity_left : ‚àÄ(f : Mor).
        compose(id(cod(f)), f) = f
        
    axiom identity_right : ‚àÄ(f : Mor).
        compose(f, id(dom(f))) = f
        
    axiom associativity : ‚àÄ(f : Mor)(g : Mor)(h : Mor).
        compose(compose(h, g), f) = compose(h, compose(g, f))
}

structure Functor(C, D) {
    operation map_obj : C ‚Üí D
    operation map_mor : C ‚Üí D
    
    axiom preserves_id : ‚àÄ(x : C).
        map_mor(id(x)) = id(map_obj(x))
        
    axiom preserves_compose : ‚àÄ(f : C)(g : C).
        map_mor(compose(g, f)) = compose(map_mor(g), map_mor(f))
}
</code></pre>
<h2 id="physics-classical-mechanics"><a class="header" href="#physics-classical-mechanics">Physics: Classical Mechanics</a></h2>
<pre><code class="language-kleis">structure LagrangianMechanics(n : ‚Ñï) {
    // Generalized coordinates and velocities
    operation q : ‚Ñï ‚Üí ‚Ñù     // Position
    operation q_dot : ‚Ñï ‚Üí ‚Ñù  // Velocity
    operation t : ‚Ñù          // Time
    
    // Lagrangian L = T - V
    operation lagrangian : ‚Ñù
    
    // Euler-Lagrange equations
    // Using Mathematica-style: Dt for total derivative, D for partial
    axiom euler_lagrange : ‚àÄ i : ‚Ñï . i &lt; n ‚Üí
        Dt(D(lagrangian, q_dot(i)), t) = D(lagrangian, q(i))
}
</code></pre>
<h2 id="whats-next-12"><a class="header" href="#whats-next-12">What‚Äôs Next?</a></h2>
<p>Check out the reference appendices!</p>
<p>‚Üí <a href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a>
‚Üí <a href="#appendix-b-operators">Appendix B: Operators</a>
‚Üí <a href="#appendix-c-standard-library">Appendix C: Standard Library</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-a-grammar-reference"><a class="header" href="#appendix-a-grammar-reference">Appendix A: Grammar Reference</a></h1>
<p>This appendix provides a reference to Kleis syntax based on the formal grammar specification (v0.7).</p>
<blockquote>
<p><strong>Complete Grammar:</strong> See <code>docs/grammar/kleis_grammar_v07.ebnf</code> for the full EBNF specification.</p>
</blockquote>
<h2 id="program-structure"><a class="header" href="#program-structure">Program Structure</a></h2>
<pre><code class="language-ebnf">program ::= { declaration }

declaration ::= libraryAnnotation
              | versionAnnotation
              | structureDef
              | implementsDef
              | dataDef
              | functionDef
              | operationDecl
              | typeAlias
</code></pre>
<h2 id="annotations"><a class="header" href="#annotations">Annotations</a></h2>
<pre><code class="language-ebnf">libraryAnnotation ::= "@library" "(" string ")"
versionAnnotation ::= "@version" "(" string ")"
</code></pre>
<p>Example:</p>
<pre><code class="language-text">@library("stdlib/algebra")
@version("0.7")
</code></pre>
<h2 id="data-type-definitions"><a class="header" href="#data-type-definitions">Data Type Definitions</a></h2>
<pre><code class="language-ebnf">dataDef ::= "data" identifier [ "(" typeParams ")" ] "="
            dataVariant { "|" dataVariant }

dataVariant ::= identifier [ "(" dataFields ")" ]

dataField ::= identifier ":" type    // Named field
            | type                   // Positional field
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">data Bool {
    True
    False
}
data Option(T) {
    None
    Some(value : T)
}
</code></pre>
<h2 id="pattern-matching-1"><a class="header" href="#pattern-matching-1">Pattern Matching</a></h2>
<pre><code class="language-ebnf">matchExpr ::= "match" expression "{" matchCases "}"

matchCase ::= pattern "=&gt;" expression

pattern ::= "_"                              // Wildcard
          | identifier                       // Variable
          | identifier [ "(" patternArgs ")" ]  // Constructor
          | number | string | boolean        // Constant
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">match x { True =&gt; 1 | False =&gt; 0 }
match opt { None =&gt; 0 | Some(x) =&gt; x }
match result { Ok(Some(x)) =&gt; x | Ok(None) =&gt; 0 | Err(_) =&gt; -1 }
</code></pre>
<h2 id="structure-definitions"><a class="header" href="#structure-definitions">Structure Definitions</a></h2>
<pre><code class="language-ebnf">structureDef ::= "structure" identifier "(" typeParams ")"
                 [ extendsClause ] [ overClause ]
                 "{" { structureMember } "}"

extendsClause ::= "extends" identifier [ "(" typeArgs ")" ]
overClause ::= "over" "Field" "(" type ")"

structureMember ::= operationDecl
                  | elementDecl
                  | axiomDecl
                  | nestedStructure
                  | functionDef
</code></pre>
<p>Example:</p>
<pre><code class="language-text">structure VectorSpace(V) over Field(F) extends AbelianGroup(V) {
    operation (¬∑) : F √ó V ‚Üí V
    
    axiom scalar_distributive : ‚àÄ(a : F)(b : F)(v : V).
        (a + b) ¬∑ v = a ¬∑ v + b ¬∑ v
}
</code></pre>
<h2 id="implements-1"><a class="header" href="#implements-1">Implements</a></h2>
<pre><code class="language-ebnf">implementsDef ::= "implements" identifier "(" typeArgs ")"
                  [ overClause ]
                  [ "{" { implMember } "}" ]

implMember ::= elementImpl | operationImpl | verifyStmt

operationImpl ::= "operation" operatorSymbol "=" implementation
                | "operation" operatorSymbol "(" params ")" "=" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-text">implements Ring(‚Ñù) {
    operation add = builtin_add
    operation mul = builtin_mul
    element zero = 0
    element one = 1
}
</code></pre>
<h2 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h2>
<pre><code class="language-ebnf">functionDef ::= "define" identifier [ typeAnnotation ] "=" expression
              | "define" identifier "(" params ")" [ ":" type ] "=" expression

param ::= identifier [ ":" type ]
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">define pi = 3.14159
define square(x) = x * x
define add(x: ‚Ñù, y: ‚Ñù) : ‚Ñù = x + y
</code></pre>
<h2 id="type-system"><a class="header" href="#type-system">Type System</a></h2>
<pre><code class="language-ebnf">type ::= primitiveType
       | parametricType
       | functionType
       | typeVariable
       | "(" type ")"

primitiveType ::= "‚Ñù" | "‚ÑÇ" | "‚Ñ§" | "‚Ñï" | "‚Ñö"
                | "Real" | "Complex" | "Integer" | "Nat" | "Rational"
                | "Bool" | "String"

parametricType ::= identifier "(" typeArgs ")"

functionType ::= type "‚Üí" type | type "-&gt;" type

typeAlias ::= "type" identifier "=" type
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">‚Ñù                    // Real numbers
Vector(3)            // Parameterized type
‚Ñù ‚Üí ‚Ñù               // Function type
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù         // Higher-order function
type RealFunc = ‚Ñù ‚Üí ‚Ñù  // Type alias
</code></pre>
<h2 id="expressions"><a class="header" href="#expressions">Expressions</a></h2>
<pre><code class="language-ebnf">expression ::= primary
             | matchExpr
             | prefixOp expression
             | expression postfixOp
             | expression infixOp expression
             | expression "(" [ arguments ] ")"
             | "[" [ expressions ] "]"           // List literal
             | lambda
             | letBinding
             | conditional

primary ::= identifier | number | string | symbolicConstant
          | "(" expression ")" | placeholder

symbolicConstant ::= "œÄ" | "e" | "i" | "‚Ñè" | "c" | "œÜ" | "‚àû" | "‚àÖ"

placeholder ::= "‚ñ°"
</code></pre>
<h2 id="lambda-expressions"><a class="header" href="#lambda-expressions">Lambda Expressions</a></h2>
<pre><code class="language-ebnf">lambda ::= "Œª" params "." expression
         | "lambda" params "." expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">Œª x . x + 1              // Simple lambda
Œª x y . x * y            // Multiple parameters
Œª (x : ‚Ñù) . x^2          // With type annotation
lambda x . x             // Using keyword
</code></pre>
<h2 id="let-bindings-1"><a class="header" href="#let-bindings-1">Let Bindings</a></h2>
<pre><code class="language-ebnf">letBinding ::= "let" identifier [ typeAnnotation ] "=" expression "in" expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">let x = 5 in x + x
let x : ‚Ñù = 3.14 in x * 2
let s = (a + b + c) / 2 in sqrt(s * (s-a) * (s-b) * (s-c))
</code></pre>
<h2 id="conditionals-1"><a class="header" href="#conditionals-1">Conditionals</a></h2>
<pre><code class="language-ebnf">conditional ::= "if" expression "then" expression "else" expression
</code></pre>
<p>Example:</p>
<pre><code class="language-text">if x &gt; 0 then x else -x
</code></pre>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<pre><code class="language-ebnf">forAllProp ::= ("‚àÄ" | "forall") variables [ whereClause ] "." proposition
existsProp ::= ("‚àÉ" | "exists") variables [ whereClause ] "." proposition

varDecl ::= identifier [ ":" type ]
          | identifier "‚àà" type
          | "(" identifier { identifier } ":" type ")"

whereClause ::= "where" expression
</code></pre>
<p>Examples:</p>
<pre><code class="language-text">‚àÄ(x : ‚Ñù). x + 0 = x
‚àÉ(x : ‚Ñ§). x * x = 4
‚àÄ(a : ‚Ñù)(b : ‚Ñù) where a ‚â† 0 . a * (1/a) = 1
</code></pre>
<h2 id="calculus-notation-v07"><a class="header" href="#calculus-notation-v07">Calculus Notation (v0.7)</a></h2>
<p>Kleis uses Mathematica-style notation for calculus operations:</p>
<pre><code class="language-ebnf">// Derivatives (function calls)
D(f, x)              // Partial derivative ‚àÇf/‚àÇx
D(f, x, y)           // Mixed partial ‚àÇ¬≤f/‚àÇx‚àÇy
D(f, {x, n})         // nth derivative ‚àÇ‚Åøf/‚àÇx‚Åø
Dt(f, x)             // Total derivative df/dx

// Integrals
Integrate(f, x)           // Indefinite ‚à´f dx
Integrate(f, x, a, b)     // Definite ‚à´[a,b] f dx

// Sums and Products
Sum(expr, i, 1, n)        // Œ£·µ¢‚Çå‚ÇÅ‚Åø expr
Product(expr, i, 1, n)    // Œ†·µ¢‚Çå‚ÇÅ‚Åø expr

// Limits
Limit(f, x, a)            // lim_{x‚Üía} f
</code></pre>
<p>Note: Legacy notation like <code>‚àÇf/‚àÇx</code> and <code>df/dx</code> is deprecated. Use <code>D(f, x)</code> and <code>Dt(f, x)</code> instead.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<h3 id="prefix-operators"><a class="header" href="#prefix-operators">Prefix Operators</a></h3>
<pre><code class="language-ebnf">prefixOp ::= "-" | "¬¨" | "‚àá" | "‚àö" | "‚à´" | "‚à¨" | "‚à≠" | "‚àÆ" | "‚àØ"
</code></pre>
<h3 id="postfix-operators"><a class="header" href="#postfix-operators">Postfix Operators</a></h3>
<pre><code class="language-ebnf">postfixOp ::= "!" | "‚Ä†" | "*" | "·µÄ" | "^T" | "^‚Ä†"
</code></pre>
<h3 id="infix-operators-by-precedence-low-to-high"><a class="header" href="#infix-operators-by-precedence-low-to-high">Infix Operators (by precedence, low to high)</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Precedence</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code> <code>iff</code></td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> <code>implies</code> <code>‚üπ</code> <code>‚áí</code></td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code> <code>or</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code> <code>and</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code> <code>not</code> (prefix)</td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>‚â†</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>‚â•</code> <code>‚âà</code> <code>‚â°</code> <code>‚àà</code> <code>‚àâ</code></td><td>Non-assoc</td></tr>
<tr><td>7</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>*</code> <code>√ó</code> <code>/</code> <code>¬∑</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>^</code></td><td>Right</td></tr>
<tr><td>10</td><td><code>-</code> (unary)</td><td>Prefix</td></tr>
<tr><td>11</td><td>Function application</td><td>Left</td></tr>
<tr><td>12</td><td>Postfix (<code>!</code>, <code>·µÄ</code>, <code>‚Ä†</code>)</td><td>Postfix</td></tr>
</tbody>
</table>
</div>
<h2 id="comments-1"><a class="header" href="#comments-1">Comments</a></h2>
<pre><code class="language-ebnf">lineComment ::= "//" { any character except newline } newline
blockComment ::= "/*" { any character } "*/"
</code></pre>
<p><strong>Note:</strong> Kleis uses C-style comments (<code>//</code> and <code>/* */</code>), not Haskell-style (<code>--</code> and <code>{- -}</code>).</p>
<h2 id="unicode-equivalents"><a class="header" href="#unicode-equivalents">Unicode Equivalents</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unicode</th><th>ASCII</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>‚àÄ</code></td><td><code>forall</code></td><td>Universal quantifier</td></tr>
<tr><td><code>‚àÉ</code></td><td><code>exists</code></td><td>Existential quantifier</td></tr>
<tr><td><code>‚Üí</code></td><td><code>-&gt;</code></td><td>Function type / implies</td></tr>
<tr><td><code>√ó</code></td><td><code>*</code></td><td>Product type / multiplication</td></tr>
<tr><td><code>‚àß</code></td><td><code>and</code>, <code>/\</code></td><td>Logical and</td></tr>
<tr><td><code>‚à®</code></td><td><code>or</code>, <code>\/</code></td><td>Logical or</td></tr>
<tr><td><code>¬¨</code></td><td><code>not</code>, <code>~</code></td><td>Logical not</td></tr>
<tr><td><code>‚â§</code></td><td><code>&lt;=</code></td><td>Less or equal</td></tr>
<tr><td><code>‚â•</code></td><td><code>&gt;=</code></td><td>Greater or equal</td></tr>
<tr><td><code>‚â†</code></td><td><code>!=</code>, <code>/=</code></td><td>Not equal</td></tr>
<tr><td><code>‚Ñï</code></td><td><code>Nat</code></td><td>Natural numbers</td></tr>
<tr><td><code>‚Ñ§</code></td><td><code>Int</code></td><td>Integers</td></tr>
<tr><td><code>‚Ñù</code></td><td><code>Real</code></td><td>Real numbers</td></tr>
<tr><td><code>‚ÑÇ</code></td><td><code>Complex</code></td><td>Complex numbers</td></tr>
<tr><td><code>Œª</code></td><td><code>lambda</code></td><td>Lambda</td></tr>
<tr><td><code>œÄ</code></td><td><code>pi</code></td><td>Pi constant</td></tr>
<tr><td><code>‚àû</code></td><td><code>infinity</code></td><td>Infinity</td></tr>
</tbody>
</table>
</div>
<h2 id="lexical-elements"><a class="header" href="#lexical-elements">Lexical Elements</a></h2>
<pre><code class="language-ebnf">identifier ::= letter { letter | digit | "_" }

number ::= integer | decimal | scientific
integer ::= digit { digit }
decimal ::= digit { digit } "." { digit }
scientific ::= decimal ("e" | "E") ["+"|"-"] digit { digit }

string ::= '"' { character } '"'

letter ::= "a".."z" | "A".."Z" | greekLetter
digit ::= "0".."9"

greekLower ::= "Œ±" | "Œ≤" | "Œ≥" | "Œ¥" | "Œµ" | "Œ∂" | "Œ∑" | "Œ∏"
             | "Œπ" | "Œ∫" | "Œª" | "Œº" | "ŒΩ" | "Œæ" | "Œø" | "œÄ"
             | "œÅ" | "œÉ" | "œÑ" | "œÖ" | "œÜ" | "œá" | "œà" | "œâ"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-b-operators"><a class="header" href="#appendix-b-operators">Appendix B: Operators</a></h1>
<h2 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th><th>Result</th></tr>
</thead>
<tbody>
<tr><td><code>+</code></td><td>Addition</td><td><code>3 + 4</code></td><td><code>7</code></td></tr>
<tr><td><code>-</code></td><td>Subtraction</td><td><code>10 - 3</code></td><td><code>7</code></td></tr>
<tr><td><code>*</code></td><td>Multiplication</td><td><code>6 * 7</code></td><td><code>42</code></td></tr>
<tr><td><code>/</code></td><td>Division</td><td><code>15 / 3</code></td><td><code>5</code></td></tr>
<tr><td><code>^</code></td><td>Exponentiation</td><td><code>2 ^ 10</code></td><td><code>1024</code></td></tr>
<tr><td><code>-</code> (unary)</td><td>Negation</td><td><code>-5</code></td><td><code>-5</code></td></tr>
</tbody>
</table>
</div>
<h2 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>=</code></td><td></td><td>Equality</td><td><code>x = y</code></td></tr>
<tr><td><code>!=</code></td><td><code>‚â†</code></td><td>Inequality</td><td><code>x ‚â† y</code></td></tr>
<tr><td><code>&lt;</code></td><td></td><td>Less than</td><td><code>x &lt; y</code></td></tr>
<tr><td><code>&gt;</code></td><td></td><td>Greater than</td><td><code>x &gt; y</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>‚â§</code></td><td>Less or equal</td><td><code>x ‚â§ y</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>‚â•</code></td><td>Greater or equal</td><td><code>x ‚â• y</code></td></tr>
</tbody>
</table>
</div>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>and</code></td><td><code>‚àß</code></td><td>Conjunction</td><td><code>P ‚àß Q</code></td></tr>
<tr><td><code>or</code></td><td><code>‚à®</code></td><td>Disjunction</td><td><code>P ‚à® Q</code></td></tr>
<tr><td><code>not</code></td><td><code>¬¨</code></td><td>Negation</td><td><code>¬¨P</code></td></tr>
<tr><td><code>implies</code></td><td><code>‚Üí</code></td><td>Implication</td><td><code>P ‚Üí Q</code></td></tr>
<tr><td><code>iff</code></td><td><code>‚Üî</code></td><td>Biconditional</td><td><code>P ‚Üî Q</code></td></tr>
</tbody>
</table>
</div>
<h2 id="set-operators"><a class="header" href="#set-operators">Set Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Unicode</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>in</code></td><td><code>‚àà</code></td><td>Membership</td><td><code>x ‚àà S</code></td></tr>
<tr><td><code>notin</code></td><td><code>‚àâ</code></td><td>Non-membership</td><td><code>x ‚àâ S</code></td></tr>
<tr><td><code>subset</code></td><td><code>‚äÜ</code></td><td>Subset</td><td><code>A ‚äÜ B</code></td></tr>
<tr><td><code>superset</code></td><td><code>‚äá</code></td><td>Superset</td><td><code>A ‚äá B</code></td></tr>
<tr><td><code>union</code></td><td><code>‚à™</code></td><td>Union</td><td><code>A ‚à™ B</code></td></tr>
<tr><td><code>intersect</code></td><td><code>‚à©</code></td><td>Intersection</td><td><code>A ‚à© B</code></td></tr>
</tbody>
</table>
</div>
<h2 id="type-operators"><a class="header" href="#type-operators">Type Operators</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Operator</th><th>Name</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>‚Üí</code></td><td>Function type</td><td><code>‚Ñù ‚Üí ‚Ñù</code></td></tr>
<tr><td><code>√ó</code></td><td>Product type</td><td><code>‚Ñù √ó ‚Ñù</code></td></tr>
<tr><td><code>:</code></td><td>Type annotation</td><td><code>x : ‚Ñù</code></td></tr>
</tbody>
</table>
</div>
<h2 id="precedence-table"><a class="header" href="#precedence-table">Precedence Table</a></h2>
<p>From lowest to highest precedence:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Level</th><th>Operators</th><th>Associativity</th></tr>
</thead>
<tbody>
<tr><td>1</td><td><code>‚Üî</code></td><td>Left</td></tr>
<tr><td>2</td><td><code>‚Üí</code> (logical)</td><td>Right</td></tr>
<tr><td>3</td><td><code>‚à®</code></td><td>Left</td></tr>
<tr><td>4</td><td><code>‚àß</code></td><td>Left</td></tr>
<tr><td>5</td><td><code>¬¨</code></td><td>Prefix</td></tr>
<tr><td>6</td><td><code>=</code> <code>‚â†</code> <code>&lt;</code> <code>&gt;</code> <code>‚â§</code> <code>‚â•</code></td><td>None</td></tr>
<tr><td>7</td><td><code>‚à™</code> <code>‚à©</code></td><td>Left</td></tr>
<tr><td>8</td><td><code>+</code> <code>-</code></td><td>Left</td></tr>
<tr><td>9</td><td><code>*</code> <code>/</code></td><td>Left</td></tr>
<tr><td>10</td><td><code>^</code></td><td>Right</td></tr>
<tr><td>11</td><td><code>-</code> (unary)</td><td>Prefix</td></tr>
<tr><td>12</td><td><code>.</code> (field access)</td><td>Left</td></tr>
</tbody>
</table>
</div>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<pre><code class="language-kleis">define ex1 = 2 + 3 * 4        // 14 (not 20)
define ex2 = (2 + 3) * 4      // 20
define ex3 = 2 ^ 3 ^ 2        // 512 (= 2^9, right associative)
define neg_sq(x) = -x^2       // -(x^2), not (-x)^2
</code></pre>
<h3 id="logical"><a class="header" href="#logical">Logical</a></h3>
<pre><code class="language-kleis">define logic1(P, Q, R) = P ‚àß Q ‚à® R        // (P ‚àß Q) ‚à® R
define logic2(P, Q, R) = P ‚Üí Q ‚Üí R        // P ‚Üí (Q ‚Üí R) (right associative)
define logic3(P, Q) = ¬¨P ‚àß Q              // (¬¨P) ‚àß Q
</code></pre>
<h3 id="type-expressions"><a class="header" href="#type-expressions">Type Expressions</a></h3>
<pre><code class="language-kleis">‚Ñù ‚Üí ‚Ñù ‚Üí ‚Ñù        // ‚Ñù ‚Üí (‚Ñù ‚Üí ‚Ñù) (curried binary function)
(‚Ñù ‚Üí ‚Ñù) ‚Üí ‚Ñù      // Higher-order: takes function, returns value
‚Ñù √ó ‚Ñù ‚Üí ‚Ñù        // Takes pair, returns value
</code></pre>
<h2 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in Functions</a></h2>
<h3 id="mathematical-functions"><a class="header" href="#mathematical-functions">Mathematical Functions</a></h3>
<pre><code class="language-kleis">sqrt(x)          // Square root
abs(x)           // Absolute value
floor(x)         // Round down
ceil(x)          // Round up
round(x)         // Round to nearest
min(x, y)        // Minimum
max(x, y)        // Maximum
</code></pre>
<h3 id="trigonometric-functions"><a class="header" href="#trigonometric-functions">Trigonometric Functions</a></h3>
<pre><code class="language-kleis">sin(x)   cos(x)   tan(x)
asin(x)  acos(x)  atan(x)
sinh(x)  cosh(x)  tanh(x)
</code></pre>
<h3 id="exponential-and-logarithmic-1"><a class="header" href="#exponential-and-logarithmic-1">Exponential and Logarithmic</a></h3>
<pre><code class="language-kleis">exp(x)           // e^x
ln(x)            // Natural logarithm
log(x)           // Base-10 logarithm
log(b, x)        // Logarithm base b
</code></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<pre><code class="language-kleis">œÄ                // Pi (3.14159...)
e                // Euler's number (2.71828...)
i                // Imaginary unit
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="appendix-c-standard-library"><a class="header" href="#appendix-c-standard-library">Appendix C: Standard Library</a></h1>
<p>The Kleis standard library provides foundational types, structures, and operations.</p>
<h2 id="core-types"><a class="header" href="#core-types">Core Types</a></h2>
<h3 id="numeric-types-1"><a class="header" href="#numeric-types-1">Numeric Types</a></h3>
<pre><code class="language-kleis">// These are primitive types built into Kleis:
‚Ñï  (or Nat)      // Natural numbers (0, 1, 2, ...)
‚Ñ§  (or Int)      // Integers (..., -1, 0, 1, ...)
‚Ñù  (or Real)     // Real numbers
‚ÑÇ  (or Complex)  // Complex numbers
</code></pre>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h3>
<pre><code class="language-kleis">Bool  // True or False
</code></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h3>
<pre><code class="language-kleis">Unit  // Single value: ()
</code></pre>
<h2 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h2>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<pre><code class="language-kleis">structure List(T) {
    operation head : T
    operation tail : List(T)
    operation length : ‚Ñï
    operation append : List(T) ‚Üí List(T)
    operation map : (T ‚Üí U) ‚Üí List(U)
    operation filter : (T ‚Üí Bool) ‚Üí List(T)
}
</code></pre>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<pre><code class="language-kleis">structure Vector(n : ‚Ñï, T) {
    operation get : ‚Ñï ‚Üí T
    operation length : ‚Ñï
    operation dot : Vector(n, T) ‚Üí T
    operation magnitude : ‚Ñù
    operation normalize : Vector(n, T)
}
</code></pre>
<h3 id="matrix"><a class="header" href="#matrix">Matrix</a></h3>
<pre><code class="language-kleis">structure Matrix(m : ‚Ñï, n : ‚Ñï, T) {
    operation get : ‚Ñï √ó ‚Ñï ‚Üí T
    operation rows : ‚Ñï
    operation cols : ‚Ñï
    operation transpose : Matrix(n, m, T)
    operation add : Matrix(m, n, T) ‚Üí Matrix(m, n, T)
    operation mul : Matrix(n, p, T) ‚Üí Matrix(m, p, T)
}

structure SquareMatrix(n : ‚Ñï, T) extends Matrix(n, n, T) {
    operation det : T
    operation trace : T
    operation inv : SquareMatrix(n, T)
    operation eigenvalues : List(‚ÑÇ)
}
</code></pre>
<h2 id="algebraic-structures"><a class="header" href="#algebraic-structures">Algebraic Structures</a></h2>
<h3 id="monoid"><a class="header" href="#monoid">Monoid</a></h3>
<pre><code class="language-kleis">structure Monoid(M) {
    e : M                         // Identity element
    operation mul : M √ó M ‚Üí M     // Binary operation
    
    axiom identity_left : ‚àÄ(x : M). mul(e, x) = x
    axiom identity_right : ‚àÄ(x : M). mul(x, e) = x
    axiom associative : ‚àÄ(x : M)(y : M)(z : M).
        mul(mul(x, y), z) = mul(x, mul(y, z))
}
</code></pre>
<h3 id="group"><a class="header" href="#group">Group</a></h3>
<pre><code class="language-kleis">structure Group(G) extends Monoid(G) {
    operation inv : G ‚Üí G         // Inverse
    
    axiom inverse_left : ‚àÄ(x : G). mul(inv(x), x) = e
    axiom inverse_right : ‚àÄ(x : G). mul(x, inv(x)) = e
}
</code></pre>
<h3 id="ring"><a class="header" href="#ring">Ring</a></h3>
<pre><code class="language-kleis">structure Ring(R) {
    operation zero : R
    operation one : R
    operation add : R √ó R ‚Üí R
    operation mul : R √ó R ‚Üí R
    operation neg : R ‚Üí R
    
    // (R, add, zero) is an abelian group
    // (R, mul, one) is a monoid
    // mul distributes over add
}
</code></pre>
<h3 id="field"><a class="header" href="#field">Field</a></h3>
<pre><code class="language-kleis">structure Field(F) extends Ring(F) {
    operation inv : F ‚Üí F  // Multiplicative inverse (for non-zero)
    
    axiom mul_inverse : ‚àÄ(x : F). x ‚â† zero ‚Üí mul(x, inv(x)) = one
    axiom mul_commutative : ‚àÄ(x : F)(y : F). mul(x, y) = mul(y, x)
}
</code></pre>
<h3 id="vector-space"><a class="header" href="#vector-space">Vector Space</a></h3>
<pre><code class="language-kleis">structure VectorSpace(V, F) where F : Field {
    operation add : V √ó V ‚Üí V
    operation scale : F √ó V ‚Üí V
    zero : V
    
    // (V, add, zero) is an abelian group
    // scale distributes over add
    // scale is associative with field multiplication
}
</code></pre>
<h2 id="geometric-structures"><a class="header" href="#geometric-structures">Geometric Structures</a></h2>
<h3 id="metric-space"><a class="header" href="#metric-space">Metric Space</a></h3>
<pre><code class="language-kleis">structure MetricSpace(M) {
    operation distance : M √ó M ‚Üí ‚Ñù
    
    axiom non_negative : ‚àÄ(x : M)(y : M). distance(x, y) ‚â• 0
    axiom identity : ‚àÄ(x : M)(y : M). distance(x, y) = 0 ‚Üî x = y
    axiom symmetric : ‚àÄ(x : M)(y : M). distance(x, y) = distance(y, x)
    axiom triangle : ‚àÄ(x : M)(y : M)(z : M).
        distance(x, z) ‚â§ distance(x, y) + distance(y, z)
}
</code></pre>
<h3 id="manifold"><a class="header" href="#manifold">Manifold</a></h3>
<pre><code class="language-kleis">structure Manifold(M, dim : ‚Ñï) {
    operation tangent : M ‚Üí TangentSpace(dim)
    operation chart : M ‚Üí Vector(dim, ‚Ñù)  // Local coordinates
}
</code></pre>
<h3 id="riemannian-manifold"><a class="header" href="#riemannian-manifold">Riemannian Manifold</a></h3>
<pre><code class="language-kleis">structure RiemannianManifold(M, dim : ‚Ñï) extends Manifold(M, dim) {
    operation metric : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation christoffel : M ‚Üí Tensor(1, 2)
    operation riemann : M ‚Üí Tensor(1, 3)
    operation ricci : M ‚Üí Matrix(dim, dim, ‚Ñù)
    operation scalar_curvature : M ‚Üí ‚Ñù
}
</code></pre>
<h2 id="option-and-result-types"><a class="header" href="#option-and-result-types">Option and Result Types</a></h2>
<h3 id="option"><a class="header" href="#option">Option</a></h3>
<pre><code class="language-kleis">data Option(T) {
    Some(value : T)
    None
}

// Operations
define is_some(opt) =
    match opt {
        Some(_) =&gt; True
        None =&gt; False
    }

define unwrap_or(opt, default) =
    match opt {
        Some(v) =&gt; v
        None =&gt; default
    }
</code></pre>
<h3 id="result"><a class="header" href="#result">Result</a></h3>
<pre><code class="language-kleis">data Result(T, E) {
    Ok(value : T)
    Err(error : E)
}

// Operations
define is_ok(res) =
    match res {
        Ok(_) =&gt; True
        Err(_) =&gt; False
    }

define map_result(res, f) =
    match res {
        Ok(v) =&gt; Ok(f(v))
        Err(e) =&gt; Err(e)
    }
</code></pre>
<h2 id="loading-the-standard-library"><a class="header" href="#loading-the-standard-library">Loading the Standard Library</a></h2>
<p>In the REPL:</p>
<pre><code>kleis&gt; :load stdlib/prelude.kleis
Loaded standard library.
</code></pre>
<p>In files:</p>
<pre><code class="language-kleis">import stdlib.prelude
import stdlib.linear_algebra
import stdlib.differential_geometry
</code></pre>
<h2 id="file-organization"><a class="header" href="#file-organization">File Organization</a></h2>
<pre><code>stdlib/
‚îú‚îÄ‚îÄ prelude.kleis          // Core types and functions
‚îú‚îÄ‚îÄ numeric.kleis          // Numeric operations
‚îú‚îÄ‚îÄ collections.kleis      // List, Vector, Matrix
‚îú‚îÄ‚îÄ algebraic.kleis        // Group, Ring, Field, etc.
‚îú‚îÄ‚îÄ linear_algebra.kleis   // Matrix operations
‚îú‚îÄ‚îÄ differential_geometry.kleis  // Manifolds, tensors
‚îî‚îÄ‚îÄ category_theory.kleis  // Categories, functors
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
