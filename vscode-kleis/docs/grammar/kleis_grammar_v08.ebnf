(* ============================================ *)
(* Kleis Grammar v0.8 - EBNF Specification     *)
(* Date: 2025-12-18                             *)
(* NEW: Advanced Pattern Matching               *)
(*   - Pattern Guards                           *)
(*   - As-Patterns (Alias Binding)              *)
(*   - Let Destructuring                        *)
(*   - Import Statements                        *)
(* Includes: Data Types, Pattern Matching,      *)
(*           Type System, Structures, Axioms    *)
(* ============================================ *)

(* Top-Level Program *)
program ::= { declaration } ;

declaration
    ::= importDecl           (* v0.8: Module imports *)
      | libraryAnnotation
      | versionAnnotation
      | structureDef
      | implementsDef
      | dataDef              (* v0.4: Algebraic data types *)
      | functionDef
      | operationDecl
      | objectDecl
      | typeAlias
      ;

(* ============================================ *)
(* ANNOTATIONS                                  *)
(* ============================================ *)

libraryAnnotation ::= "@library" "(" string ")" ;
versionAnnotation ::= "@version" "(" string ")" ;

(* ============================================ *)
(* IMPORT STATEMENTS - v0.8                     *)
(* ============================================ *)

(*
  Import statements load definitions from other .kleis files.
  
  Syntax:
    import "stdlib/algebra.kleis"
    import "./local/types.kleis"
  
  Semantics:
    - Loads all structures, data types, functions into current scope
    - Cascading: imports in loaded files are also processed
    - Circular-safe: same file loaded at most once
    - Typically placed at beginning of file
    
  Path resolution:
    - Absolute paths: used as-is
    - "stdlib/" prefix: relative to stdlib directory
    - Relative paths: relative to importing file's directory
*)

importDecl ::= "import" string ;

(* ============================================ *)
(* DATA TYPE DEFINITIONS (ADR-021) - v0.4      *)
(* ============================================ *)

(*
  Algebraic data types enable user-defined types.
  
  Examples:
    data Bool = True | False
    data Option(T) = None | Some(T)
    data Type = Scalar | Vector(n: Nat) | Matrix(m: Nat, n: Nat)
    
  This is the foundation for self-hosting: Kleis types defined in Kleis!
*)

dataDef
    ::= "data" identifier [ "(" typeParams ")" ] "="
        dataVariant { "|" dataVariant }
    ;

dataVariant
    ::= identifier [ "(" dataFields ")" ]
    ;

dataFields ::= dataField { "," dataField } ;

dataField
    ::= identifier ":" type      (* Named field: m: Nat, value: T *)
      | type                      (* Positional field: T, Nat *)
    ;

(* ============================================ *)
(* PATTERN MATCHING (v0.8) - Enhanced           *)
(* ============================================ *)

(*
  Pattern matching enables using algebraic data types.
  
  v0.8 ENHANCEMENTS:
    - Pattern Guards: n if n < 0 => "negative"
    - As-Patterns: Cons(h, t) as whole => ...
    - Let Destructuring: let Point(x, y) = p in ...
  
  Examples:
    match x { True => 1 | False => 0 }
    match opt { None => 0 | Some(x) => x }
    match x { n if n < 0 => "negative" | _ => "non-negative" }
    match list { Cons(h, t) as whole => process(whole) | Nil => empty }
    
  Features:
    - Wildcard patterns: _
    - Variable binding: x, value
    - Constructor patterns: Some(x), None
    - Constant patterns: 0, 1, "hello"
    - Nested patterns: Ok(Some(x))
    - Pattern guards: x if condition => ... (v0.8)
    - As-patterns: pattern as alias (v0.8)
    - Exhaustiveness checking (compile-time warnings)
*)

matchExpr
    ::= "match" expression "{" matchCases "}"
    ;

matchCases
    ::= matchCase { caseSeparator matchCase }
    ;

caseSeparator
    ::= "|"               (* Pipe separator *)
      | newline           (* Newline separator *)
      ;

(* v0.8: Match case with optional guard *)
matchCase
    ::= pattern [ "if" guardExpression ] "=>" expression
    ;

(*
  Guard expressions (v0.8)
  
  Guards are boolean expressions evaluated after pattern match.
  If guard evaluates to False, matching continues to next case.
  
  Examples:
    n if n < 0 => "negative"
    x if is_valid(x) => process(x)
    Pair(a, b) if a > b => "first larger"
*)
guardExpression
    ::= expression        (* Must evaluate to Bool *)
    ;

(* v0.8: Pattern with optional as-binding *)
pattern
    ::= basePattern [ "as" identifier ]
    ;

(*
  As-patterns (alias binding) - v0.8
  
  Bind both the destructured parts AND the whole value.
  
  Examples:
    Cons(h, t) as whole     -- whole = entire list, h = head, t = tail
    Some(x) as original     -- original = Some(x), x = inner value
*)

basePattern
    ::= wildcardPattern
      | variablePattern
      | constructorPattern
      | constantPattern
      ;

wildcardPattern
    ::= "_"
    ;

variablePattern
    ::= identifier       (* Must start with lowercase *)
    ;

constructorPattern
    ::= identifier [ "(" patternArgs ")" ]
    ;                    (* Constructor must start with uppercase *)

patternArgs
    ::= pattern { "," pattern }
    ;

constantPattern
    ::= number
      | string
      | boolean
      ;

boolean ::= "True" | "False" ;

(* ============================================ *)
(* STRUCTURE DEFINITIONS                        *)
(* ============================================ *)

structureDef
    ::= "structure" identifier "(" typeParams ")"
        [ extendsClause ]
        [ overClause ]
        "{" { structureMember } "}"
    ;

typeParams ::= typeParam { "," typeParam } ;
typeParam ::= identifier [ ":" kind ] ;

kind
    ::= "Type"
      | "ℕ" | "Nat"
      | "Field"
      | "*"
      | kind "→" kind
      ;

extendsClause ::= "extends" identifier [ "(" typeArgs ")" ] ;
overClause ::= "over" "Field" "(" type ")" ;

structureMember
    ::= operationDecl
      | elementDecl
      | axiomDecl
      | nestedStructure
      | supportsBlock
      | notationDecl
      | functionDef        (* v0.6: Derived operations *)
      ;

operationDecl ::= "operation" operatorSymbol ":" typeSignature ;
elementDecl ::= "element" identifier ":" type ;
axiomDecl ::= "axiom" identifier ":" proposition ;

nestedStructure
    ::= "structure" identifier ":" identifier "(" type ")"
        "{" { structureMember } "}"
    ;

supportsBlock ::= "supports" "{" { operationDecl } "}" ;
notationDecl ::= "notation" identifier "(" params ")" "=" expression ;

(* ============================================ *)
(* IMPLEMENTATIONS                              *)
(* ============================================ *)

implementsDef
    ::= "implements" identifier "(" typeArgs ")"
        [ overClause ]
        [ "{" { implMember } "}" ]
    ;

implMember
    ::= elementImpl
      | operationImpl
      | verifyStmt
      ;

elementImpl ::= "element" identifier "=" expression ;

operationImpl
    ::= "operation" operatorSymbol "=" implementation
      | "operation" operatorSymbol "(" params ")" "=" expression
      ;

implementation
    ::= identifier        (* Function name like builtin_add *)
      | expression        (* Inline expression *)
      ;

verifyStmt ::= "verify" identifier ;

(* ============================================ *)
(* FUNCTION DEFINITIONS                         *)
(* ============================================ *)

functionDef
    ::= "define" identifier [ typeAnnotation ] "=" expression
      | "define" identifier "(" params ")" [ ":" type ] "=" expression
      ;

params ::= param { "," param } ;

param
    ::= identifier [ ":" type ]
      | "(" identifier { identifier } ":" type ")"
      ;

(* ============================================ *)
(* TYPE SYSTEM                                  *)
(* ============================================ *)

typeSignature
    ::= polymorphicType
      | type
      ;

polymorphicType
    ::= forAllQuantifier typeVarList "." [ constraints ] type
    ;

forAllQuantifier ::= "∀" | "forall" ;

typeVarList
    ::= typeVarDecl { typeVarDecl }
      | "(" typeVarDecl { "," typeVarDecl } ")"
    ;

typeVarDecl ::= identifier [ ":" kind ] ;

constraints ::= constraint { "," constraint } implication ;
implication ::= "⇒" | "=>" ;

constraint
    ::= identifier "(" type ")"         (* Monoid(T) *)
      | type "=" type                   (* m = n *)
      | expression                      (* x ≠ 0 *)
      ;

type
    ::= primitiveType
      | parametricType
      | functionType
      | typeVariable
      | "(" type ")"
      ;

primitiveType
    ::= "ℝ" | "ℂ" | "ℤ" | "ℕ" | "ℚ"
      | "Real" | "Complex" | "Integer" | "Nat" | "Rational"
      | "Bool" | "String"
      ;

parametricType ::= identifier "(" typeArgs ")" ;
typeArgs ::= type { "," type } ;

functionType
    ::= type "→" type
      | type "->" type
      ;

typeVariable
    ::= greekLower      (* α, β, γ *)
      | identifier       (* a, b, T, M *)
      ;

typeAnnotation ::= ":" type ;

typeAlias ::= "type" identifier "=" type ;

(* ============================================ *)
(* PROPOSITIONS (for axioms)                   *)
(* ============================================ *)

proposition
    ::= forAllProp
      | existsProp
      | expression
      ;

forAllProp
    ::= forAllQuantifier variables [ whereClause ] "." proposition
    ;

existsProp
    ::= existsQuantifier variables [ whereClause ] "." proposition
    ;

existsQuantifier ::= "∃" | "exists" ;

variables
    ::= varDecl { varDecl }
      | "(" varDecl { varDecl } ")"
      ;

varDecl
    ::= identifier [ ":" type ]
      | "(" identifier { identifier } ":" type ")"
      | identifier "∈" type
      | identifier "∈" expression
      ;

whereClause ::= "where" expression ;

(* ============================================ *)
(* EXPRESSIONS                                  *)
(* ============================================ *)

expression
    ::= primary
      | matchExpr                           (* v0.5: Pattern matching *)
      | prefixOp expression
      | expression postfixOp
      | expression infixOp expression
      | expression "(" [ arguments ] ")"    (* Function application *)
      | "[" [ expressions ] "]"             (* Vector/list literal *)
      | "{" [ expressions ] "}"             (* Set literal *)
      | lambda
      | letBinding
      | conditional
      | summation
      | productNotation
      | integral
      | limit                               (* v0.7: Limit notation *)
      ;

primary
    ::= identifier
      | number
      | string
      | symbolicConstant
      | "(" expression ")"
      | placeholder
      ;

symbolicConstant
    ::= "π" | "e" | "i" | "ℏ" | "c" | "φ" | "∞" | "∅"
      ;

placeholder ::= "□" ;

(* Operators *)

prefixOp
    ::= "-" | "¬" | "∇" | "√"
      (* NOTE: ∂ removed as prefix - use D(f, x) instead (v0.7) *)
      ;

postfixOp
    ::= "!" | "†" | "*" | "ᵀ" | "^T" | "^†"
      ;

infixOp
    ::= arithmeticOp
      | relationOp
      | logicOp
      ;

arithmeticOp
    ::= "+" | "-" | "×" | "/" | "·" | "*" | "^"
      | "⊗" | "∘" | "∗"
      | customOperator
      ;

(* Custom user-defined operators *)
(* Any Unicode math symbol (Symbol, Math category) *)
(* Examples: •, ⊗, ⊕, ⊙, ⊛, ∪, ∩, ⋆, etc. *)
customOperator
    ::= (* Unicode Symbol, Math (Sm) category *)
      | (* Excluding: +, -, *, /, ^, ×, · (built-in arithmetic) *)
      | (* Excluding: =, <, >, ≤, ≥, ≠ (comparisons) *)
      | (* Excluding: ∧, ∨, ¬, ⟹ (logical) *)
      | (* Excluding: (), [], {}, ,, ., :, ; (delimiters) *)
      ;

relationOp
    ::= "=" | "==" | "≠" | "<" | ">" | "≤" | "≥"
      | "≈" | "≡" | "~" | "∈" | "∉" | "⊂" | "⊆"
      ;

logicOp
    ::= "∧" | "∨" | "⟹" | "⟺" | "→" | "⇒"
      ;

operatorSymbol
    ::= "(" infixOp ")"          (* Infix as function: (+) *)
      | infixOp
      | prefixOp
      | postfixOp
      | identifier                 (* Named operations *)
      ;

arguments ::= expression { "," expression } ;
expressions ::= expression { "," expression } ;

(* Lambda *)

lambda
    ::= "λ" params "." expression
      | "lambda" params "." expression
      ;

(* Let binding - v0.8: Supports full patterns *)

(*
  Let Destructuring (v0.8)
  
  Use patterns in let bindings, not just variable names.
  
  Examples:
    let x = 5 in x + x                       -- Simple (as before)
    let Point(x, y) = p in x^2 + y^2         -- Constructor pattern
    let Cons(h, t) = list in h               -- Destructure list
    let Some(Pair(a, b)) = opt in a + b      -- Nested destructuring
    
  Notes:
    - Type annotation only valid for simple Variable patterns
    - Pattern must match value (runtime error if not)
*)
letBinding
    ::= "let" pattern [ typeAnnotation ] "=" expression "in" expression
    ;

(* Conditional *)

conditional
    ::= "if" expression "then" expression "else" expression
    ;

(* ============================================ *)
(* CALCULUS NOTATION (v0.7 - Mathematica-style) *)
(* ============================================ *)

(*
  v0.7 CHANGE: Kleis adopts Mathematica-style for derivatives.
  
  DEPRECATED (no longer valid Kleis):
    ∂f/∂x   - Use D(f, x) instead
    df/dx   - Use Dt(f, x) instead
  
  VALID KLEIS CALCULUS NOTATION:
  
  Derivatives (function call style):
    D(f, x)           - Partial derivative ∂f/∂x
    D(f, x, y)        - Mixed partial ∂²f/∂x∂y
    D(f, {x, n})      - nth derivative ∂ⁿf/∂xⁿ
    Dt(f, x)          - Total derivative df/dx (chain rule applies)
  
  Integrals (Unicode prefix + function call):
    ∫ f               - Indefinite integral (prefix operator)
    Integrate(f, x)   - Indefinite integral ∫f dx
    Integrate(f, x, a, b) - Definite integral ∫[a,b] f dx
  
  Sums and Products (Unicode with subscript/superscript):
    Σ_{i=1}^{n} expr  - Summation (visual)
    Sum(expr, i, 1, n) - Summation (function call)
    Π_{i=1}^{n} expr  - Product (visual)
    Product(expr, i, 1, n) - Product (function call)
  
  Limits (v0.7 NEW):
    Limit(f, x, a)    - Limit as x → a
    Limit(f, x, a, Direction → "Left")  - Left limit
*)

summation
    ::= "Σ" [ subscript ] [ superscript ] expression
      | "Sum" "(" expression "," identifier "," expression "," expression ")"
      ;

productNotation
    ::= "Π" [ subscript ] [ superscript ] expression
      | "Product" "(" expression "," identifier "," expression "," expression ")"
      ;

integral
    ::= "∫" [ subscript ] [ superscript ] expression [ "d" identifier ]
      | "Integrate" "(" expression "," identifier ")"
      | "Integrate" "(" expression "," identifier "," expression "," expression ")"
      ;

(* v0.7 NOTE: Limit is a standard function call - no special grammar rule needed *)
(* Limit(body, var, target) is just: expression "(" arguments ")" *)
(* This rule is here for documentation only: *)
limit
    ::= "Limit" "(" expression "," identifier "," expression ")"
      ;

subscript ::= "_" ( identifier | "{" expression "}" ) ;
superscript ::= "^" ( identifier | "{" expression "}" ) ;

(* ============================================ *)
(* EQUALITY TYPES (from v0.2)                  *)
(* ============================================ *)

defineStmt ::= "define" identifier "=" expression ;
assertStmt ::= "assert" expression "==" expression ;
equivStmt ::= "equiv" expression "~" expression ;
approxStmt ::= "approx" expression "≈" expression ;

(* ============================================ *)
(* LEXICAL ELEMENTS                            *)
(* ============================================ *)

identifier ::= letter { letter | digit | "_" } ;

greekLower
    ::= "α" | "β" | "γ" | "δ" | "ε" | "ζ" | "η" | "θ"
      | "ι" | "κ" | "λ" | "μ" | "ν" | "ξ" | "ο" | "π"
      | "ρ" | "σ" | "τ" | "υ" | "φ" | "χ" | "ψ" | "ω"
      ;

number
    ::= integer
      | decimal
      | scientific
      ;

integer ::= digit { digit } ;
decimal ::= digit { digit } "." { digit } ;
scientific ::= decimal [eE] [+-]? digit { digit } ;

string ::= '"' { character } '"' ;
character ::= (* any character except " and \ *) ;

letter ::= "a".."z" | "A".."Z" ;
digit ::= "0".."9" ;

(* Whitespace and comments *)
whitespace ::= " " | "\t" | "\r" | "\n" ;
lineComment ::= "//" { (* any character except newline *) } "\n" ;
blockComment ::= "/*" { (* any character *) } "*/" ;

(* ============================================ *)
(* CHANGE LOG                                   *)
(* ============================================ *)

(*
  Version 0.8 (2025-12-18):
    - NEW: Pattern Guards - match x { n if n < 0 => "negative" | _ => "non-negative" }
    - NEW: As-Patterns - Cons(h, t) as whole binds both parts and whole
    - NEW: Let Destructuring - let Point(x, y) = p in x^2 + y^2
    - Updated matchCase rule: pattern [ "if" guardExpression ] "=>" expression
    - Updated pattern rule: basePattern [ "as" identifier ]
    - Updated letBinding rule: "let" pattern [ typeAnnotation ] "=" expression "in" expression
    - Full Z3 integration for all new features
    - No breaking changes from v0.7
  
  Version 0.7 (2025-12-13):
    - BREAKING: Removed ∂f/∂x and df/dx derivative notation
    - Adopted Mathematica-style derivatives: D(f, x), Dt(f, x)
    - Added Limit(f, x, a) for limit expressions
    - Added function-call alternatives for Sum, Product, Integrate
    - Removed ∂ from prefixOp (no longer standalone prefix)
    - Renamed 'product' to 'productNotation' to avoid conflict
  
  Version 0.6 (2025-12-12):
    - Added functionDef to structureMember (derived operations)
    - Allows default implementations inside structures
    - Example: define (-)(x, y) = x + negate(y) in Ring
  
  Version 0.5 (2025-12-08):
    - Added pattern matching (matchExpr, pattern, matchCase)
    - Completes ADR-021: Can now USE algebraic data types
    - Wildcard, variable, constructor, and constant patterns
    - Nested pattern matching support
    - Exhaustiveness checking
    
  Version 0.4 (2025-12-08):
    - Added algebraic data types (dataDef, dataVariant, dataField)
    - Implements ADR-021 Part 1: DEFINE data types
    
  Version 0.3 (2025-12-05):
    - Type system with polymorphism
    - Structure definitions with axioms
    - Implements blocks
    
  Version 0.2:
    - Basic mathematical expressions
    - Function definitions
*)

