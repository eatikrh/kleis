// ============================================================================
// KLEISDOC COMPREHENSIVE TYPES
// ============================================================================
//
// This file defines all data types needed for the .kleisdoc persistent format.
// These types capture everything a publishable document might contain.
//
// Design principles:
// 1. Types are self-documenting
// 2. Provenance is always tracked (where did this content come from?)
// 3. Cross-references are first-class
// 4. Validation status is tracked per-element
//
// ============================================================================

import "stdlib/prelude.kleis"

// ============================================================================
// 1. AUTHOR AND AFFILIATION
// ============================================================================

// Author role in the document
data AuthorRole = 
    Primary           // Main author
  | Advisor           // Thesis supervisor
  | Contributor       // Contributing author
  | Reviewer          // Internal reviewer

// Author information
data Author = Author(
    id: String,           // "author-001"
    name: String,         // "Jane Smith"
    email: String,        // "jane@mit.edu"
    orcid: String,        // "0000-0002-1234-5678" or ""
    affiliation: String,  // "MIT CSAIL"
    role: AuthorRole
)

// ============================================================================
// 2. CONTENT SOURCE - Provenance Tracking
// ============================================================================

// How was this content created?
data ContentSource =
    // Can be regenerated by running Kleis code
    Regenerable(
        kleis_code: String,      // The source code
        dependencies: List(String)  // Files this code imports
    )
    
    // Static content - manually written or imported
  | Static
  
    // Computed and cached - Kleis code + its output
  | Computed(
        kleis_code: String,
        cached_result: String,
        computed_at: String      // ISO timestamp
    )
    
    // Imported from external source
  | Imported(
        path: String,            // Original file path
        hash: String             // SHA256 for cache invalidation
    )

// ============================================================================
// 3. VALIDATION STATUS
// ============================================================================

data ValidationStatus =
    Unchecked                      // Not yet validated
  | Valid(checked_at: String)      // Passes all axioms
  | Warning(message: String)       // Passes with warnings
  | Invalid(message: String)       // Fails validation

// ============================================================================
// 4. EDITOR NODE - Visual Equation AST (mirrors Rust's EditorNode)
// ============================================================================

// Placeholder for user input (the □ boxes)
data PlaceholderData = Placeholder(id: ℕ, hint: String)

// Index position for tensors
data IndexPosition = Upper | Lower

// Index structure for a single index
data IndexMeta = IndexMeta(position: IndexPosition, name: String)

// Metadata for operations (especially tensors)
data NodeMetadata = 
    NoMeta
  | TensorMeta(indices: List(IndexMeta))
  | MatrixMeta(rows: ℕ, cols: ℕ)

// The EditorNode AST - what the Equation Editor produces
data EditorNode =
    // Simple symbol: x, α, Γ
    EObject(symbol: String)
    
    // Numeric or string constant: 42, "hello"
  | EConst(value: String)
  
    // Placeholder for user input: □
  | EPlaceholder(data: PlaceholderData)
  
    // Operation with args and optional semantic metadata
  | EOp(name: String, args: List(EditorNode), kind: String, meta: NodeMetadata)
  
    // List of nodes
  | EList(nodes: List(EditorNode))

// ============================================================================
// 5. EQUATION REPRESENTATION
// ============================================================================

// How is the equation stored?
data EquationFormat =
    // Just LaTeX string (legacy, no re-editing)
    LatexOnly(latex: String)
    
    // Kleis text (for verification, can be parsed)
  | KleisExpr(kleis_text: String)
  
    // EditorNode AST (full fidelity, re-editable!)
  | EditorAST(ast: EditorNode)
  
    // JSON string (for interop with JS Equation Editor)
  | EditorJSON(json: String)
  
    // All formats (maximum compatibility)
  | AllFormats(latex: String, kleis_text: String, ast: EditorNode)

data Equation = Equation(
    id: String,                    // "eq-einstein"
    label: String,                 // "eq:einstein"
    numbered: Bool,
    format: EquationFormat,
    typst_code: String,            // Rendered Typst: "$ E = mc^2 $ <eq:einstein>"
    validation: ValidationStatus   // Has this been verified?
)

// ============================================================================
// 5. FIGURE REPRESENTATION
// ============================================================================

data FigurePlacement = Here | Top | Bottom | FullPage

data Figure = Figure(
    id: String,                    // "ch1-fig1"
    label: String,                 // "fig:quadratic"
    caption: String,
    alt_text: String,              // Accessibility
    source: ContentSource,
    typst_fragment: String,        // The lq.diagram(...) code
    svg_cache: String,             // Path to cached SVG
    width: String,                 // "70%" or "auto"
    placement: FigurePlacement
)

// ============================================================================
// 6. TABLE REPRESENTATION
// ============================================================================

data TableAlignment = AlignLeft | AlignCenter | AlignRight

data TableRow = Row(cells: List(String))

data Table = Table(
    id: String,
    label: String,
    caption: String,
    headers: List(String),
    alignments: List(TableAlignment),
    rows: List(TableRow),
    source: ContentSource,         // Static or computed from data
    typst_code: String
)

// ============================================================================
// 7. CODE BLOCK REPRESENTATION
// ============================================================================

data CodeLanguage = 
    Kleis | Python | Rust | JavaScript | Latex | Typst | Plain

data CodeBlock = CodeBlock(
    id: String,
    label: String,
    language: CodeLanguage,
    source_code: String,
    executable: Bool,              // Can this be run?
    output_cache: String,          // Cached execution output
    line_numbers: Bool
)

// ============================================================================
// 8. THEOREM-LIKE ENVIRONMENTS
// ============================================================================

data TheoremType = 
    ThmTheorem | ThmLemma | ThmProposition | ThmCorollary | ThmConjecture

data Thm = Thm(
    id: String,
    theorem_type: TheoremType,
    number: String,                // "3.1" or ""
    name: String,                  // "Fermat's Last Theorem" or ""
    statement: String,
    proof: String                  // "" if no proof given
)

data Definition = Definition(
    id: String,
    term: String,
    definition: String
)

data Example = Example(
    id: String,
    description: String,
    content: String
)

// ============================================================================
// 9. GENERIC TEXT CHUNKS
// ============================================================================

data TextFormat = Markdown | PlainText

data TextChunk = TextChunk(
    id: String,
    format: TextFormat,
    content: String,
    typst_code: String             // Rendered to Typst
)

// ============================================================================
// 10. CROSS-REFERENCES
// ============================================================================

data RefType = 
    RefFigure | RefTable | RefEquation | RefSection | RefTheorem | RefCitation

data CrossRef = CrossRef(
    ref_type: RefType,
    label: String,                 // "fig:quadratic"
    display: String,               // "Figure 1.1"
    target_id: String              // "ch1-fig1"
)

// ============================================================================
// 11. BIBLIOGRAPHY
// ============================================================================

data BibEntry = BibEntry(
    key: String,                   // "demoura2008"
    entry_type: String,            // "inproceedings", "article", etc.
    title: String,
    authors: String,
    venue: String,                 // Journal or conference
    year: String,
    doi: String,
    bibtex: String,                // Full BibTeX entry
    formatted: String              // Formatted citation text
)

// ============================================================================
// 12. CHUNK UNION TYPE - Any content chunk
// ============================================================================

// A chunk is any piece of document content
data Chunk =
    CText(chunk: TextChunk)
  | CEq(equation: Equation)
  | CFig(figure: Figure)
  | CTab(table: Table)
  | CCode(code: CodeBlock)
  | CThm(theorem: Thm)
  | CDef(definition: Definition)
  | CEx(example: Example)

// ============================================================================
// 13. DOCUMENT STRUCTURE
// ============================================================================

// Section level
data SectionLevel = 
    Chapter | Section | Subsection | Subsubsection

// A section contains chunks
data DocSection = DocSection(
    id: String,
    level: SectionLevel,
    number: String,                // "1" or "1.1" or "1.1.1"
    title: String,
    chunks: List(Chunk),
    subsections: List(DocSection)  // Nested sections
)

// Front matter types
data FrontMatter =
    TitlePage(title: String, authors: List(Author), date: String, degree: String, department: String)
  | Abstract(text: String, supervisor: String)
  | Acknowledgments(text: String)
  | Dedication(text: String)
  | TableOfContents
  | ListOfFigures
  | ListOfTables

// Back matter types
data BackMatter =
    Bibliography(entries: List(BibEntry))
  | AppendixList(appendices: List(DocSection))
  | Index(entries: List(String))  // Simplified for now
  | Glossary(terms: List(Definition))

// ============================================================================
// 14. DOCUMENT METADATA
// ============================================================================

data DocTemplate = 
    MITThesisTemplate
  | ArxivPaperTemplate
  | IEEEPaperTemplate
  | BookTemplate
  | CustomTemplate(name: String, path: String)

data License =
    CCBY | CCBYSA | CCBYNC | MIT | AllRightsReserved | Custom(text: String)

data DocMetadata = DocMetadata(
    id: String,                    // UUID
    title: String,
    authors: List(Author),
    keywords: List(String),
    language: String,              // "en-US"
    license: License,
    template: DocTemplate,
    doi: String,
    created: String,               // ISO timestamp
    modified: String,              // ISO timestamp
    version: ℕ,
    git_commit: String             // Link to code version
)

// ============================================================================
// 15. COMPILATION STATE
// ============================================================================

data OutputFormat = PDF | Typst | HTML | LaTeX

data CompiledOutput = CompiledOutput(
    format: OutputFormat,
    path: String,
    hash: String,
    generated_at: String
)

data CompilationState = CompilationState(
    last_compiled: String,
    outputs: List(CompiledOutput),
    overall_validation: ValidationStatus
)

// ============================================================================
// 16. JUPYTER INTEGRATION
// ============================================================================

data CellType = CodeCell | MarkdownCell | RawCell

data JupyterMapping = JupyterMapping(
    cell_id: String,
    cell_type: CellType,
    tags: List(String),            // ["kleisdoc:ch1-fig1"]
    chunk_id: String,
    execution_count: ℕ
)

data JupyterState = JupyterState(
    notebook_path: String,
    last_sync: String,
    mappings: List(JupyterMapping)
)

// ============================================================================
// 17. HISTORY AND COLLABORATION
// ============================================================================

data HistoryEntry = HistoryEntry(
    version: ℕ,
    timestamp: String,
    author_id: String,
    message: String,
    chunks_modified: List(String),
    chunks_added: List(String),
    chunks_deleted: List(String)
)

data Comment = Comment(
    id: String,
    author_id: String,
    timestamp: String,
    chunk_id: String,
    text: String,
    resolved: Bool
)

// ============================================================================
// 18. COMPLETE KLEISDOC TYPE
// ============================================================================

data KleisDoc = KleisDoc(
    metadata: DocMetadata,
    front_matter: List(FrontMatter),
    main_sections: List(DocSection),
    back_matter: List(BackMatter),
    cross_refs: List(CrossRef),
    compilation: CompilationState,
    jupyter: JupyterState,         // Or use Maybe(JupyterState) when we have it
    history: List(HistoryEntry),
    comments: List(Comment)
)

// ============================================================================
// BUILDER FUNCTIONS
// ============================================================================

// Create a simple author
define make_author(name: String, email: String, affiliation: String) : Author =
    Author("auto-id", name, email, "", affiliation, Primary)

// Create a text chunk
define make_text(id: String, content: String) : Chunk =
    CText(TextChunk(id, Markdown, content, content))

// Create an equation
define make_equation(id: String, latex: String, label: String) : Chunk =
    CEq(Equation(
        id, 
        label, 
        True,
        LatexOnly(latex),
        concat4("$ ", latex, " $ <", concat(label, ">")),
        Unchecked
    ))

// Create a figure from Kleis code
define make_plot_figure(id: String, label: String, kleis_code: String, caption: String) : Chunk =
    CFig(Figure(
        id,
        label,
        caption,
        "",  // alt_text
        Regenerable(kleis_code, Nil),
        "",  // typst_fragment - to be generated
        "",  // svg_cache - to be generated
        "auto",
        Here
    ))

// Create a chapter
define make_chapter(num: String, title: String, chunks: List(Chunk)) : DocSection =
    DocSection("ch-auto", Chapter, num, title, chunks, Nil)

// Create a section within a chapter
define make_section(num: String, title: String, chunks: List(Chunk)) : DocSection =
    DocSection("sec-auto", Section, num, title, chunks, Nil)

// ============================================================================
// EXAMPLE USAGE
// ============================================================================

example "create_author" {
    let author = make_author("Jane Smith", "jane@mit.edu", "MIT CSAIL")
    out("Created author")
}

example "create_equation" {
    let eq = make_equation("eq-001", "E = mc^2", "eq:einstein")
    out("Created equation chunk")
}

example "create_chapter" {
    let text1 = make_text("ch1-p1", "This is the introduction.")
    let eq1 = make_equation("ch1-eq1", "f(x) = x^2", "eq:quadratic")
    let chapter = make_chapter("1", "Introduction", Cons(text1, Cons(eq1, Nil)))
    out("Created chapter with 2 chunks")
}

example "chunk_types" {
    // Show that we can pattern match on chunk types
    let text_chunk = make_text("test", "Hello")
    let eq_chunk = make_equation("test-eq", "x^2", "eq:test")
    
    let chunk_type_name = fn(c: Chunk) match c {
        CText(_) => "text"
      | CEq(_) => "equation"
      | CFig(_) => "figure"
      | CTab(_) => "table"
      | CCode(_) => "code"
      | CThm(_) => "theorem"
      | CDef(_) => "definition"
      | CEx(_) => "example"
    }
    
    out(chunk_type_name(text_chunk))
    out(chunk_type_name(eq_chunk))
}

