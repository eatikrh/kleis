// =============================================================================
// Eigenvalue Computation: Closed-Form Solutions
// =============================================================================
// 
// This example demonstrates symbolic eigenvalue calculation for small matrices
// using closed-form solutions. These are exact (no numerical approximation).
//
// For control systems: eigenvalues determine stability!
//   • All Re(λ) < 0  →  Stable (continuous-time)
//   • All |λ| < 1    →  Stable (discrete-time)
// =============================================================================


// =============================================================================
// 2×2 Eigenvalues: Quadratic Formula
// =============================================================================
// 
// For matrix A = [[a, b], [c, d]]
// Characteristic polynomial: λ² - tr(A)·λ + det(A) = 0
// 
// where:
//   tr(A)  = a + d           (trace)
//   det(A) = a·d - b·c       (determinant)
//
// Eigenvalues by quadratic formula:
//   λ₁,₂ = (tr ± √(tr² - 4·det)) / 2

structure Matrix2x2() {
    element a : ℝ
    element b : ℝ  
    element c : ℝ
    element d : ℝ
    
    // Derived quantities
    operation trace : ℝ
    operation det : ℝ
    operation discriminant : ℝ
    
    axiom trace_def: trace = a + d
    axiom det_def: det = a * d - b * c
    axiom discriminant_def: discriminant = trace^2 - 4 * det
}

// Eigenvalue pair for 2×2 matrix
structure Eigenvalues2x2() {
    element eig1 : ℂ
    element eig2 : ℂ
}

// Closed-form eigenvalue computation and stability theory for 2×2 matrices
structure EigenvalueTheory2x2() {
    operation eigenvalues : Matrix2x2 → Eigenvalues2x2

    // Eigenvalue formulas via quadratic formula
    axiom eigenvalue_1:
        ∀ M : Matrix2x2 .
        let tr = trace(M) in
        let disc = discriminant(M) in
        eig1(eigenvalues(M)) = (tr + sqrt(disc)) / 2

    axiom eigenvalue_2:
        ∀ M : Matrix2x2 .
        let tr = trace(M) in
        let disc = discriminant(M) in
        eig2(eigenvalues(M)) = (tr - sqrt(disc)) / 2

    // Stability condition: both eigenvalues have negative real part
    operation is_stable : Matrix2x2 → Bool

    axiom stability_condition_2x2:
        ∀ M : Matrix2x2 .
        is_stable(M) ↔ (Re(eig1(eigenvalues(M))) < 0 ∧ Re(eig2(eigenvalues(M))) < 0)

    // Equivalent condition using trace and determinant (faster to check!)
    axiom hurwitz_2x2:
        ∀ M : Matrix2x2 .
        is_stable(M) ↔ (trace(M) < 0 ∧ det(M) > 0)
}


// =============================================================================
// 3×3 Eigenvalues: Cardano's Formula
// =============================================================================
//
// For matrix A (3×3), characteristic polynomial is:
//   λ³ - p·λ² + q·λ - r = 0
//
// where:
//   p = tr(A)                           (trace)
//   q = (tr(A)² - tr(A²)) / 2           (sum of 2×2 principal minors)
//   r = det(A)                          (determinant)
//
// Cardano's formula gives exact solutions (may involve complex cube roots)

structure Matrix3x3() {
    element a₁₁ : ℝ    element a₁₂ : ℝ    element a₁₃ : ℝ
    element a₂₁ : ℝ    element a₂₂ : ℝ    element a₂₃ : ℝ
    element a₃₁ : ℝ    element a₃₂ : ℝ    element a₃₃ : ℝ
    
    // Coefficients of characteristic polynomial
    operation p : ℝ  // coefficient of λ²
    operation q : ℝ  // coefficient of λ
    operation r : ℝ  // constant term (det)
    
    axiom p_def: p = a₁₁ + a₂₂ + a₃₃  // trace
    
    axiom q_def: q = (a₁₁*a₂₂ - a₁₂*a₂₁) 
                   + (a₁₁*a₃₃ - a₁₃*a₃₁) 
                   + (a₂₂*a₃₃ - a₂₃*a₃₂)
    
    axiom r_def: r = a₁₁*(a₂₂*a₃₃ - a₂₃*a₃₂) 
                   - a₁₂*(a₂₁*a₃₃ - a₂₃*a₃₁) 
                   + a₁₃*(a₂₁*a₃₂ - a₂₂*a₃₁)
}

structure Eigenvalues3x3() {
    element eig1 : ℂ
    element eig2 : ℂ
    element eig3 : ℂ
}

// Cardano's method and stability theory for 3×3 matrices
structure EigenvalueTheory3x3() {
    // Reduce to depressed cubic t³ + at + b = 0
    // where t = λ - p/3
    operation eigenvalues : Matrix3x3 → Eigenvalues3x3

    axiom eigenvalues_3x3_cardano:
        ∀ M : Matrix3x3 .
        let mp = p(M) in
        let mq = q(M) in
        let mr = r(M) in
        // Depressed cubic coefficients
        let a = mq - mp^2/3 in
        let b = mr - mp*mq/3 + 2*mp^3/27 in
        // Cardano discriminant
        let Δ = -4*a^3 - 27*b^2 in
        // Solutions via Cardano (simplified for real case)
        let Q = (a/3) in
        let R = (b/2) in
        let D = Q^3 + R^2 in
        // When D ≥ 0: one real, two complex conjugate
        // When D < 0: three distinct real (use trigonometric method)
        eigenvalues(M) = cardano_solve(mp, a, b, D)

    // Routh-Hurwitz stability criterion for 3×3
    // All eigenvalues have Re(λ) < 0 iff:
    //   p > 0, r > 0, and p·q > r
    operation is_stable : Matrix3x3 → Bool

    axiom hurwitz_3x3:
        ∀ M : Matrix3x3 .
        is_stable(M) ↔ (p(M) > 0 ∧ r(M) > 0 ∧ p(M) * q(M) > r(M))
}


// =============================================================================
// Example: Mass-Spring-Damper System
// =============================================================================
//
//   m·ẍ + c·ẋ + k·x = 0
//
// State-space form: ẋ = A·x where
//   x = [position, velocity]ᵀ
//   A = [[0, 1], [-k/m, -c/m]]
//
// System is stable iff c > 0 and k > 0 (positive damping and stiffness)

example "Mass-Spring-Damper Stability" {
    // For m=1, c=2, k=3:
    //   A = [[0, 1], [-3, -2]]
    //   trace = 0 + (-2) = -2 < 0 ✓
    //   det = 0·(-2) - 1·(-3) = 3 > 0 ✓
    //   Therefore stable by Hurwitz criterion!
    out("Mass-spring-damper with m=1, c=2, k=3")
    out("  trace = -2 < 0, det = 3 > 0 → Stable!")
}


// =============================================================================
// Example: Inverted Pendulum (Unstable Open-Loop)
// =============================================================================
//
// Linearized about upright position:
//   A = [[0, 1], [g/L, 0]]
//
// where g = gravity, L = pendulum length
// 
// This is UNSTABLE (one positive eigenvalue)

example "Inverted Pendulum (Unstable Open-Loop)" {
    // Linearized about upright: A = [[0, 1], [g/L, 0]]
    // For g=9.81, L=1.0:
    //   trace = 0 (not < 0!)
    //   det = 0·0 - 1·9.81 = -9.81 < 0 (not > 0!)
    //   Therefore UNSTABLE - needs a controller!
    out("Inverted pendulum with g=9.81, L=1.0")
    out("  trace = 0 (not negative), det = -9.81 < 0 → Unstable!")
}


// =============================================================================
// Control Design Preview
// =============================================================================
//
// To stabilize the inverted pendulum, we add state feedback:
//   u = -K·x = -[k₁, k₂]·[θ, θ̇]ᵀ
//
// Closed-loop: A_cl = A - B·K
//
// Choose K such that A_cl has eigenvalues with Re(λ) < 0
// This is pole placement / LQR design!
//
// See: lqg_controller.kleis for full LQG design example


