// =============================================================================
// Sudoku Rules in Kleis
// =============================================================================
//
// A Sudoku puzzle is a 9×9 grid where:
//   1. Each row contains digits 1-9 exactly once
//   2. Each column contains digits 1-9 exactly once  
//   3. Each 3×3 box contains digits 1-9 exactly once
//
// The grid is divided into 9 boxes (3×3 arrangement of 3×3 boxes):
//   Box(1,1) | Box(1,2) | Box(1,3)
//   Box(2,1) | Box(2,2) | Box(2,3)
//   Box(3,1) | Box(3,2) | Box(3,3)
//
// =============================================================================

// Type aliases for clarity
type Digit = ℕ
type Row   = ℕ
type Col   = ℕ
type BoxRow = ℕ  // 1, 2, or 3
type BoxCol = ℕ  // 1, 2, or 3

structure Sudoku {
    // =========================================================================
    // Core Operation: Access a cell in the grid
    // cell(g, r, c) returns the digit at row r, column c
    // =========================================================================
    operation cell : Grid × Row × Col → Digit
    
    // =========================================================================
    // Helper: Compute which box a cell belongs to
    // box_of(r, c) returns (box_row, box_col)
    // =========================================================================
    operation box_row : Row → BoxRow
    operation box_col : Col → BoxCol
    
    // =========================================================================
    // Validity predicate
    // =========================================================================
    operation valid_digit : Digit → Bool
    operation valid_index : ℕ → Bool
    operation valid_grid : Grid → Bool
    
    // =========================================================================
    // AXIOM: Valid indices are 1-9
    // =========================================================================
    axiom valid_index_def :
        ∀(i : ℕ). valid_index(i) = (i ≥ 1 ∧ i ≤ 9)
    
    // =========================================================================
    // AXIOM: Valid digits are 1-9
    // =========================================================================
    axiom valid_digit_def :
        ∀(d : Digit). valid_digit(d) = (d ≥ 1 ∧ d ≤ 9)
    
    // =========================================================================
    // AXIOM: All cells in a valid grid contain valid digits
    // =========================================================================
    axiom cells_contain_valid_digits :
        ∀(g : Grid). ∀(r : Row). ∀(c : Col).
            (valid_index(r) ∧ valid_index(c)) →
            valid_digit(cell(g, r, c))
    
    // =========================================================================
    // AXIOM: Box row calculation
    // Rows 1-3 → Box row 1, Rows 4-6 → Box row 2, Rows 7-9 → Box row 3
    // =========================================================================
    axiom box_row_1 : ∀(r : Row). (r ≥ 1 ∧ r ≤ 3) → box_row(r) = 1
    axiom box_row_2 : ∀(r : Row). (r ≥ 4 ∧ r ≤ 6) → box_row(r) = 2
    axiom box_row_3 : ∀(r : Row). (r ≥ 7 ∧ r ≤ 9) → box_row(r) = 3
    
    // =========================================================================
    // AXIOM: Box column calculation
    // Cols 1-3 → Box col 1, Cols 4-6 → Box col 2, Cols 7-9 → Box col 3
    // =========================================================================
    axiom box_col_1 : ∀(c : Col). (c ≥ 1 ∧ c ≤ 3) → box_col(c) = 1
    axiom box_col_2 : ∀(c : Col). (c ≥ 4 ∧ c ≤ 6) → box_col(c) = 2
    axiom box_col_3 : ∀(c : Col). (c ≥ 7 ∧ c ≤ 9) → box_col(c) = 3
    
    // =========================================================================
    // AXIOM: Same box predicate
    // Two cells are in the same box if their box_row and box_col are equal
    // =========================================================================
    operation same_box : Row × Col × Row × Col → Bool
    
    axiom same_box_def :
        ∀(r1 : Row). ∀(c1 : Col). ∀(r2 : Row). ∀(c2 : Col).
            same_box(r1, c1, r2, c2) = (box_row(r1) = box_row(r2) ∧ box_col(c1) = box_col(c2))
    
    // =========================================================================
    // RULE 1: Row Uniqueness
    // No two cells in the same row have the same digit
    // =========================================================================
    axiom row_uniqueness :
        ∀(g : Grid). ∀(r : Row). ∀(c1 : Col). ∀(c2 : Col).
            (valid_index(r) ∧ valid_index(c1) ∧ valid_index(c2) ∧ c1 ≠ c2) →
            cell(g, r, c1) ≠ cell(g, r, c2)
    
    // =========================================================================
    // RULE 2: Column Uniqueness
    // No two cells in the same column have the same digit
    // =========================================================================
    axiom col_uniqueness :
        ∀(g : Grid). ∀(r1 : Row). ∀(r2 : Row). ∀(c : Col).
            (valid_index(r1) ∧ valid_index(r2) ∧ valid_index(c) ∧ r1 ≠ r2) →
            cell(g, r1, c) ≠ cell(g, r2, c)
    
    // =========================================================================
    // RULE 3: Box Uniqueness
    // No two distinct cells in the same 3×3 box have the same digit
    // =========================================================================
    axiom box_uniqueness :
        ∀(g : Grid). ∀(r1 : Row). ∀(c1 : Col). ∀(r2 : Row). ∀(c2 : Col).
            (valid_index(r1) ∧ valid_index(c1) ∧ valid_index(r2) ∧ valid_index(c2) ∧
             same_box(r1, c1, r2, c2) ∧ (r1 ≠ r2 ∨ c1 ≠ c2)) →
            cell(g, r1, c1) ≠ cell(g, r2, c2)
}

// =============================================================================
// Sudoku Puzzle (with givens)
// =============================================================================

structure SudokuPuzzle {
    // A puzzle has some cells pre-filled (givens)
    operation is_given : Grid × Row × Col → Bool
    operation given_value : Grid × Row × Col → Digit
    
    // A solution must match all givens
    operation is_solution : Grid × Grid → Bool
    
    axiom solution_respects_givens :
        ∀(puzzle : Grid). ∀(solution : Grid). ∀(r : Row). ∀(c : Col).
            (is_solution(solution, puzzle) ∧ is_given(puzzle, r, c)) →
            cell(solution, r, c) = given_value(puzzle, r, c)
}

// =============================================================================
// Concrete Calculations with eval()
// =============================================================================
//
// Kleis now supports `eval()` for concrete evaluation of ground terms!
// Ground terms are expressions with no free variables.
//
// eval(expr) uses Z3's simplify to reduce expressions to concrete values.
//
// =============================================================================

// Computable definitions for box calculation
define compute_box_row(r) = if r ≤ 3 then 1 else if r ≤ 6 then 2 else 3
define compute_box_col(c) = if c ≤ 3 then 1 else if c ≤ 6 then 2 else 3
define in_same_box(r1, c1, r2, c2) = 
    compute_box_row(r1) = compute_box_row(r2) ∧ compute_box_col(c1) = compute_box_col(c2)

// =============================================================================
// Examples: Concrete Calculations with eval()
// =============================================================================

example "eval: arithmetic" {
    // Basic arithmetic evaluation
    assert(eval(1 + 2 * 3) = 7)
    assert(eval(10 - 4) = 6)
    assert(eval(3 * 4) = 12)
}

example "eval: box_row calculations" {
    // Using eval() to compute concrete box assignments
    assert(eval(compute_box_row(1)) = 1)
    assert(eval(compute_box_row(4)) = 2)
    assert(eval(compute_box_row(9)) = 3)
}

example "eval: boolean negation" {
    // Boolean evaluation - use negation to test boolean results
    // eval() returns Const("true") or Const("false") as strings
    // For now, verify by checking the conditional reduces correctly
    assert(eval(if 5 ≤ 3 then 1 else 0) = 0)  // 5 ≤ 3 is false
    assert(eval(if 3 ≤ 5 then 1 else 0) = 1)  // 3 ≤ 5 is true
    assert(eval(if 2 = 2 then 1 else 0) = 1)  // 2 = 2 is true
}

example "eval: same_box via conditional" {
    // Test box membership using conditional to convert bool to int
    assert(eval(if in_same_box(1, 1, 3, 3) then 1 else 0) = 1)   // Top-left box
    assert(eval(if in_same_box(1, 1, 4, 4) then 1 else 0) = 0)   // Different boxes
    assert(eval(if in_same_box(4, 4, 6, 6) then 1 else 0) = 1)   // Center box
}

// =============================================================================
// Examples: Verify Sudoku Properties with Z3 (Symbolic)
// =============================================================================

example "row uniqueness - different columns have different values" {
    // Direct consequence of row_uniqueness axiom
    assert(∀(g : Grid). ∀(r : Row).
        (r ≥ 1 ∧ r ≤ 9) →
        cell(g, r, 1) ≠ cell(g, r, 2))
}

example "column uniqueness - different rows have different values" {
    // Direct consequence of col_uniqueness axiom
    assert(∀(g : Grid). ∀(c : Col).
        (c ≥ 1 ∧ c ≤ 9) →
        cell(g, 1, c) ≠ cell(g, 2, c))
}

example "box uniqueness - cells (1,1) and (2,2) in same box differ" {
    // Cells (1,1) and (2,2) are both in box(1,1) since rows 1-3 and cols 1-3 → box 1
    // The box_uniqueness axiom requires them to have different values
    // We need to provide Z3 with the conditions for the axiom to fire
    assert(∀(g : Grid).
        (valid_index(1) ∧ valid_index(2) ∧ 
         same_box(1, 1, 2, 2) ∧ (1 ≠ 2 ∨ 1 ≠ 2)) →
        cell(g, 1, 1) ≠ cell(g, 2, 2))
}

example "box calculation axioms are consistent" {
    // Verify the box_row axioms are logically consistent
    // If r is in range [1,3], then box_row(r) = 1
    // If r is in range [7,9], then box_row(r) = 3
    // These should be derivable from the axioms
    assert(∀(r : Row). (r ≥ 1 ∧ r ≤ 3) → box_row(r) = 1)
    assert(∀(r : Row). (r ≥ 7 ∧ r ≤ 9) → box_row(r) = 3)
}

example "valid digits are bounded" {
    assert(∀(d : Digit). valid_digit(d) → (d ≥ 1 ∧ d ≤ 9))
}

example "each row has 9 distinct values" {
    // If all pairs in a row are distinct, and all values are 1-9,
    // then the row is a permutation of 1-9
    // This is a consequence of row_uniqueness + valid_digit constraints
    assert(∀(g : Grid). ∀(r : Row).
        (r ≥ 1 ∧ r ≤ 9) →
        (cell(g, r, 1) ≠ cell(g, r, 2) ∧
         cell(g, r, 1) ≠ cell(g, r, 3) ∧
         cell(g, r, 2) ≠ cell(g, r, 3)))
}
