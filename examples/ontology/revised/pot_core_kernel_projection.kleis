// Projected Ontology Theory - Core (v4, with n-ary product types)
//
// New in v4:
// - Uses n-ary product types from grammar v0.94
// - Cleaner type signatures: FieldR4 × Event × Channel → ℝ
// - Removed workaround structures: MetricProbeArgs, PointPair, etc.
//
// From v3:
// 1. Typed channels for residues (scalable conserved quantities)
// 2. Particle = residue support predicate
// 3. Universe refinement ordering
// 4. POT sanity theorems

import "spacetime_type_kernel_projection.kleis"



// =============================================================================
// Projection semantics clarification (Flow→Field, complex→real)
// =============================================================================
// In POT, Flow is NOT a point in ℂ³.
// Conceptually, Flow is a complex-valued modal flow τ ↦ ψ(τ) ∈ Vector(3, ℂ),
// where τ is an ontological evolution parameter (not physical time).
//
// Likewise, FieldR4 is an observable field indexed by Events,
// e ↦ f(e) ∈ Vector(4, ℝ).
//
// We keep Flow and FieldR4 abstract in the core, but equip them with
// evaluation operations and extensionality axioms. This makes the
// Fourier/Green-kernel analogy precise without requiring function types.
// =============================================================================

structure FlowAsFunction {
    operation flow_at : Flow × ℝ → Vector(3, ℂ)

    axiom flow_ext: ∀(a b : Flow).
        (∀(τ : ℝ). flow_at(a, τ) = flow_at(b, τ)) → a = b
}

structure FieldAsFunction {
    operation field_at : FieldR4 × Event → Vector(4, ℝ)

    axiom field_ext: ∀(f g : FieldR4).
        (∀(e : Event). field_at(f, e) = field_at(g, e)) → f = g
}

// =============================================================================
// 1. H_ont = ℂ³ with inner product
// =============================================================================

structure InnerProductSpace(n : Nat) {
    operation add   : Vector(n, ℂ) × Vector(n, ℂ) → Vector(n, ℂ)
    operation scale : ℂ × Vector(n, ℂ) → Vector(n, ℂ)
    element zero    : Vector(n, ℂ)

    operation inner : Vector(n, ℂ) × Vector(n, ℂ) → ℂ

    axiom add_comm:  ∀(u v : Vector(n, ℂ)). add(u, v) = add(v, u)
    axiom add_assoc: ∀(u v w : Vector(n, ℂ)).
        add(add(u, v), w) = add(u, add(v, w))
    axiom add_id:    ∀(v : Vector(n, ℂ)). add(v, zero) = v

    axiom inner_conj_sym: ∀(x y : Vector(n, ℂ)).
        inner(x, y) = conjugate(inner(y, x))
}

// =============================================================================
// 2. Views/contexts as projectors on H_ont
// =============================================================================

structure Projector(n : Nat) over InnerProductSpace(n) {
    operation P : Vector(n, ℂ) → Vector(n, ℂ)

    axiom idempotent: ∀(v : Vector(n, ℂ)). P(P(v)) = P(v)
    axiom self_adjoint: ∀(x y : Vector(n, ℂ)).
        inner(P(x), y) = inner(x, P(y))
}

// =============================================================================
// 3. Ontology map Φ : Entity → H_ont
// =============================================================================

structure OntologyMap over InnerProductSpace(3) {
    operation Phi : Entity → Vector(3, ℂ)
    operation sim : Entity × Entity → ℝ

    axiom sim_symmetric: ∀(a b : Entity). sim(a, b) = sim(b, a)
    axiom sim_self:      ∀(a : Entity). sim(a, a) = 1
}

// =============================================================================
// 4. Fields and Flow algebras
// =============================================================================

structure FieldR4Algebra {
    operation field_add  : FieldR4 × FieldR4 → FieldR4
    operation field_smul : ℂ × FieldR4 → FieldR4
    element field_zero   : FieldR4

    axiom field_add_comm: ∀(f g : FieldR4). field_add(f, g) = field_add(g, f)
    axiom field_add_id:   ∀(f : FieldR4). field_add(f, field_zero) = f
}

structure FlowAlgebra {
    operation flow_add  : Flow × Flow → Flow
    operation flow_smul : ℂ × Flow → Flow
    element flow_zero   : Flow

    axiom flow_add_comm: ∀(a b : Flow). flow_add(a, b) = flow_add(b, a)
}

// =============================================================================
// 5. Green Kernel: Projects Flow → FieldR4
// =============================================================================
//
// OPTION A REFACTOR: All projection is now kernel-parameterized.
// There is no implicit "current kernel" - every projection explicitly names G.
// This makes multi-universe semantics unambiguous.

// Top-level projection operation (canonical notion)
operation apply_kernel : GreenKernel × Flow → FieldR4

structure GreenKernel {
    // Kernel action (abstract): contribution of modal value at τ to event e.
    // Think of this as the integrand of a Green/Fourier-type transform.
    operation kernel_action : Event × ℝ × Vector(3, ℂ) → Vector(4, ℝ)

    // Minimal kernel-mediated requirement: pointwise-equal flows project to the same field.
    axiom project_extensional: ∀(G : GreenKernel, a b : Flow).
        (∀(τ : ℝ). flow_at(a, τ) = flow_at(b, τ)) → apply_kernel(G, a) = apply_kernel(G, b)

    axiom project_lin_add: ∀(G : GreenKernel, a b : Flow).
        apply_kernel(G, flow_add(a, b)) = field_add(apply_kernel(G, a), apply_kernel(G, b))

    axiom project_lin_smul: ∀(G : GreenKernel, c : ℂ, a : Flow).
        apply_kernel(G, flow_smul(c, a)) = field_smul(c, apply_kernel(G, a))

    operation in_nullspace : GreenKernel × Flow → Bool

    // in_nullspace is DEFINITIONAL: ψ is in nullspace iff it projects to zero
    axiom nullspace_elim: ∀(G : GreenKernel, a : Flow).
        in_nullspace(G, a) → apply_kernel(G, a) = field_zero

    axiom nullspace_intro: ∀(G : GreenKernel, a : Flow).
        apply_kernel(G, a) = field_zero → in_nullspace(G, a)
}

// =============================================================================
// 6. TYPED CHANNELS (scalable conserved quantities)
// =============================================================================

structure ConservedChannel {
    element Mass   : Channel
    element EM     : Channel
    element Spin   : Channel
    element Color  : Channel

    // v0.94: Direct n-ary product type!
    // Previously: residue : ResiduePair × Channel → ℝ (needed wrapper)
    operation residue : FieldR4 × Event × Channel → ℝ
}

// =============================================================================
// 7. POINT SOURCES
// =============================================================================

structure PointSources {
    operation point_mass   : Event × ℝ → FieldR4
    operation point_charge : Event × ℝ → FieldR4

    // v0.94: Direct 3-arg product type in axioms
    axiom residue_point_mass: ∀(e : Event, m : ℝ).
        residue(point_mass(e, m), e, Mass) = m

    axiom residue_point_charge: ∀(e : Event, q : ℝ).
        residue(point_charge(e, q), e, EM) = q

    axiom point_mass_nonzero: ∀(e : Event, m : ℝ).
        m ≠ 0 → point_mass(e, m) ≠ field_zero
}

// =============================================================================
// 8. PARTICLE = RESIDUE SUPPORT
// =============================================================================

structure ParticlePredicates {
    // v0.94: Use product type directly
    operation has_mass : FieldR4 × Event → Bool

    axiom has_mass_def: ∀(f : FieldR4, e : Event).
        has_mass(f, e) → residue(f, e, Mass) ≠ 0

    operation is_particle : FieldR4 × Event → Bool

    axiom particle_is_mass: ∀(f : FieldR4, e : Event).
        is_particle(f, e) → has_mass(f, e)
}

// =============================================================================
// 9. EQUIVALENCE UNDER KERNEL (quotient by ker(apply_kernel))
// =============================================================================
//
// OPTION A: equiv is now parameterized by kernel G.
// equiv_G(a, b) ↔ apply_kernel(G, a) = apply_kernel(G, b)

structure ProjectiveEquivalence {
    // Equivalence is kernel-relative
    operation equiv : GreenKernel × Flow × Flow → Bool

    // equiv is exactly the kernel-quotient: same projection ↔ equivalent
    // These two axioms define equiv as the quotient relation.
    // refl/sym/trans are DERIVABLE from these (via equality properties).
    axiom equiv_elim: ∀(G : GreenKernel, a b : Flow).
        equiv(G, a, b) → apply_kernel(G, a) = apply_kernel(G, b)

    axiom equiv_intro: ∀(G : GreenKernel, a b : Flow).
        apply_kernel(G, a) = apply_kernel(G, b) → equiv(G, a, b)
}

// DERIVED THEOREMS: Standard equivalence relation properties
// These follow from equiv_elim + equiv_intro and properties of equality.
// Note: All are parameterized by kernel G.

example "equiv is reflexive (derived)" {
    // ∀(G : GreenKernel, a : Flow). equiv(G, a, a)
    // Proof sketch:
    //   apply_kernel(G, a) = apply_kernel(G, a)   by reflexivity of equality
    //   equiv(G, a, a)                            by equiv_intro
    assert(∀(G : GreenKernel, a : Flow). equiv(G, a, a))
}

example "equiv is symmetric (derived)" {
    // ∀(G : GreenKernel, a b : Flow). equiv(G, a, b) → equiv(G, b, a)
    // Proof sketch:
    //   equiv(G, a, b)                            assumption
    //   apply_kernel(G, a) = apply_kernel(G, b)   by equiv_elim
    //   apply_kernel(G, b) = apply_kernel(G, a)   by symmetry of equality
    //   equiv(G, b, a)                            by equiv_intro
    assert(∀(G : GreenKernel, a b : Flow). equiv(G, a, b) → equiv(G, b, a))
}

example "equiv is transitive (derived)" {
    // ∀(G : GreenKernel, a b c : Flow). equiv(G, a, b) ∧ equiv(G, b, c) → equiv(G, a, c)
    // Proof sketch:
    //   equiv(G, a, b) ∧ equiv(G, b, c)           assumption
    //   apply_kernel(G, a) = apply_kernel(G, b)   by equiv_elim
    //   apply_kernel(G, b) = apply_kernel(G, c)   by equiv_elim
    //   apply_kernel(G, a) = apply_kernel(G, c)   by transitivity of equality
    //   equiv(G, a, c)                            by equiv_intro
    assert(∀(G : GreenKernel, a b c : Flow). equiv(G, a, b) ∧ equiv(G, b, c) → equiv(G, a, c))
}

// =============================================================================
// 10. KERNEL → GEOMETRY INTERFACE (bridges field to metric)
// =============================================================================

structure KernelMetricInterface {
    // v0.94: Direct n-ary product type - no wrapper structure needed!
    // Previously: metric_probe : MetricProbeArgs → ℝ (with wrapper)
    operation metric_probe : FieldR4 × Vector(4, ℝ) × Vector(4, ℝ) → ℝ

    // POT BRIDGE AXIOM: Geometry is kernel-induced
    // Any projected field carries the same induced bilinear form
    // because geometry is a kernel property, not flow-dependent
    // OPTION A: Now explicit about kernel G
    axiom probe_recovers_kernel_inner: ∀(G : GreenKernel, psi : Flow, u v : Vector(4, ℝ)).
        metric_probe(apply_kernel(G, psi), u, v) = kernel_inner(u, v)

    // Probe is symmetric (inherits from metric symmetry)
    axiom probe_symmetric: ∀(f : FieldR4, u v : Vector(4, ℝ)).
        metric_probe(f, u, v) = metric_probe(f, v, u)
}

// =============================================================================
// 11. UNIVERSE REFINEMENT (partial order by information)
// =============================================================================

structure UniverseOrder {
    operation refines : GreenKernel × GreenKernel → Bool

    axiom refines_refl: ∀(G : GreenKernel). refines(G, G)

    axiom refines_trans: ∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1)
}

structure UniverseDistinction {
    operation different_universes : GreenKernel × GreenKernel → Bool

    // NOTE: apply_kernel is now a top-level operation (see section 5)
    // No need to redeclare it here.

    // DEFINITION of different_universes (both directions)
    // Direction 1: witnessing a difference → universes are different
    axiom different_universes_intro: ∀(G1 G2 : GreenKernel, psi : Flow).
        apply_kernel(G1, psi) ≠ apply_kernel(G2, psi) → different_universes(G1, G2)

    // Direction 2: universes are different → there exists a witnessing flow
    // (This is the key axiom for deriving universe_distinguishable)
    axiom different_universes_elim: ∀(G1 G2 : GreenKernel).
        different_universes(G1, G2) → ∃(psi : Flow).
            apply_kernel(G1, psi) ≠ apply_kernel(G2, psi)
}

// =============================================================================
// 12. POT CORE AXIOMS (minimal set)
// =============================================================================

structure POTCoreAxioms {
    // AXIOM 1: Equivalence preserves all channel residues
    // OPTION A: Now explicit about kernel G
    axiom equiv_preserves_residue: ∀(G : GreenKernel, psi1 psi2 : Flow, e : Event, c : Channel).
        equiv(G, psi1, psi2) →
            residue(apply_kernel(G, psi1), e, c) = residue(apply_kernel(G, psi2), e, c)

    // AXIOM 2: Fields distinguishable by residues (EXISTENTIAL separation)
    // If fields differ, there EXISTS some (event, channel) that detects it
    // This is the minimal separation principle.
    axiom field_distinguishable: ∀(f1 f2 : FieldR4).
        f1 ≠ f2 → ∃(e : Event, c : Channel). residue(f1, e, c) ≠ residue(f2, e, c)

    // NOTE: universe_distinguishable is now a DERIVED THEOREM, not an axiom!
    // It follows from: different_universes_elim + field_distinguishable
    // See example block "universe distinguishable theorem" below.
}

// =============================================================================
// 13. EXAMPLES
// =============================================================================

example "projector is idempotent" {
    assert(∀(v : Vector(3, ℂ)). P(P(v)) = P(v))
}

example "equivalence is reflexive" {
    assert(∀(G : GreenKernel, psi : Flow). equiv(G, psi, psi))
}

example "refinement is transitive" {
    assert(∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1))
}

example "point mass residue (v0.94: 3-arg call)" {
    // v0.94: residue(field, event, channel) - no wrapper!
    assert(∀(e : Event, m : ℝ).
        residue(point_mass(e, m), e, Mass) = m)
}

example "metric probe symmetry (v0.94: 3-arg call)" {
    // v0.94: metric_probe(field, u, v) - no wrapper!
    assert(∀(f : FieldR4, u v : Vector(4, ℝ)).
        metric_probe(f, u, v) = metric_probe(f, v, u))
}

// =============================================================================
// DERIVED THEOREM: Universe Distinguishability
// =============================================================================
//
// This is NOT an axiom - it follows from:
//   1. different_universes_elim: different_universes(G1,G2) → ∃psi. apply_kernel differs
//   2. field_distinguishable: f1 ≠ f2 → ∃(e,c). residue differs
//
// Proof sketch:
//   - From different_universes(G1,G2), get witness psi via (1)
//   - Let f1 = apply_kernel(G1,psi), f2 = apply_kernel(G2,psi), with f1 ≠ f2
//   - Apply (2) to get (e,c) such that residue(f1,e,c) ≠ residue(f2,e,c)
//   - Done: we have (psi, e, c) witnessing the observable difference

example "universe distinguishable theorem (derived)" {
    // Key POT result: different kernels produce distinguishable physics
    // This follows from different_universes_elim + field_distinguishable
    assert(∀(G1 G2 : GreenKernel).
        different_universes(G1, G2) →
            ∃(psi : Flow, e : Event, c : Channel).
                residue(apply_kernel(G1, psi), e, c) ≠
                residue(apply_kernel(G2, psi), e, c))
}
