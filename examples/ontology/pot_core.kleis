// Projected Ontology Theory - Core (v3, with ChatGPT enhancements)
//
// New in v3:
// 1. Typed channels for residues (scalable conserved quantities)
// 2. Particle = residue support predicate
// 3. Universe refinement ordering
// 4. POT sanity theorems

import "spacetime_type.kleis"

// =============================================================================
// 1. H_ont = ℂ³ with inner product
// =============================================================================

structure InnerProductSpace(n : Nat) {
    operation add   : Vector(n, ℂ) × Vector(n, ℂ) → Vector(n, ℂ)
    operation scale : ℂ × Vector(n, ℂ) → Vector(n, ℂ)
    element zero    : Vector(n, ℂ)

    operation inner : Vector(n, ℂ) × Vector(n, ℂ) → ℂ

    axiom add_comm:  ∀(u v : Vector(n, ℂ)). add(u, v) = add(v, u)
    axiom add_assoc: ∀(u v w : Vector(n, ℂ)).
        add(add(u, v), w) = add(u, add(v, w))
    axiom add_id:    ∀(v : Vector(n, ℂ)). add(v, zero) = v

    axiom inner_conj_sym: ∀(x y : Vector(n, ℂ)).
        inner(x, y) = conjugate(inner(y, x))
}

// =============================================================================
// 2. Views/contexts as projectors on H_ont
// =============================================================================

structure Projector(n : Nat) over InnerProductSpace(n) {
    operation P : Vector(n, ℂ) → Vector(n, ℂ)

    axiom idempotent: ∀(v : Vector(n, ℂ)). P(P(v)) = P(v)
    axiom self_adjoint: ∀(x y : Vector(n, ℂ)).
        inner(P(x), y) = inner(x, P(y))
}

// =============================================================================
// 3. Ontology map Φ : Entity → H_ont
// =============================================================================

structure OntologyMap over InnerProductSpace(3) {
    operation Phi : Entity → Vector(3, ℂ)
    operation sim : Entity × Entity → ℝ

    axiom sim_symmetric: ∀(a b : Entity). sim(a, b) = sim(b, a)
    axiom sim_self:      ∀(a : Entity). sim(a, a) = 1
}

// =============================================================================
// 4. Fields and Flow algebras
// =============================================================================

structure FieldR4Algebra {
    operation field_add  : FieldR4 × FieldR4 → FieldR4
    operation field_smul : ℂ × FieldR4 → FieldR4
    element field_zero   : FieldR4
    
    axiom field_add_comm: ∀(f g : FieldR4). field_add(f, g) = field_add(g, f)
    axiom field_add_id:   ∀(f : FieldR4). field_add(f, field_zero) = f
}

structure FlowAlgebra {
    operation flow_add  : Flow × Flow → Flow
    operation flow_smul : ℂ × Flow → Flow
    element flow_zero   : Flow
    
    axiom flow_add_comm: ∀(a b : Flow). flow_add(a, b) = flow_add(b, a)
}

// =============================================================================
// 5. Green Kernel: Projects Flow → FieldR4
// =============================================================================

structure GreenKernel {
    operation project : Flow → FieldR4

    axiom project_lin_add: ∀(a b : Flow).
        project(flow_add(a, b)) = field_add(project(a), project(b))

    axiom project_lin_smul: ∀(c : ℂ, a : Flow).
        project(flow_smul(c, a)) = field_smul(c, project(a))

    operation in_nullspace : Flow → Bool
    
    axiom nullspace_def: ∀(a : Flow).
        in_nullspace(a) → project(a) = field_zero
}

// =============================================================================
// 6. TYPED CHANNELS (scalable conserved quantities)
// =============================================================================

structure ConservedChannel {
    element Mass   : Channel
    element EM     : Channel
    element Spin   : Channel
    element Color  : Channel
    
    operation residue : ResiduePair × Channel → ℝ
}

// =============================================================================
// 7. RESIDUE PAIR AND POINT SOURCES
// =============================================================================

structure ResiduePair {
    element field : FieldR4
    element event : Event
}

structure PointSources {
    operation make_pair : FieldR4 × Event → ResiduePair
    
    operation point_mass   : Event × ℝ → FieldR4
    operation point_charge : Event × ℝ → FieldR4

    axiom residue_point_mass: ∀(e : Event, m : ℝ).
        residue(make_pair(point_mass(e, m), e), Mass) = m

    axiom residue_point_charge: ∀(e : Event, q : ℝ).
        residue(make_pair(point_charge(e, q), e), EM) = q
    
    axiom point_mass_nonzero: ∀(e : Event, m : ℝ).
        m ≠ 0 → point_mass(e, m) ≠ field_zero
}

// =============================================================================
// 8. PARTICLE = RESIDUE SUPPORT
// =============================================================================

structure ParticlePredicates {
    operation has_mass : ResiduePair → Bool
    
    axiom has_mass_def: ∀(rp : ResiduePair).
        has_mass(rp) → residue(rp, Mass) ≠ 0
    
    operation is_particle : ResiduePair → Bool
    
    axiom particle_is_mass: ∀(rp : ResiduePair).
        is_particle(rp) → has_mass(rp)
}

// =============================================================================
// 9. EQUIVALENCE UNDER KERNEL
// =============================================================================

structure ProjectiveEquivalence over GreenKernel {
    operation equiv : Flow × Flow → Bool
    
    axiom equiv_def: ∀(a b : Flow).
        equiv(a, b) → project(a) = project(b)

    axiom refl:  ∀(a : Flow). equiv(a, a)
    axiom sym:   ∀(a b : Flow). equiv(a, b) → equiv(b, a)
    axiom trans: ∀(a b c : Flow). equiv(a, b) ∧ equiv(b, c) → equiv(a, c)
}

// =============================================================================
// 10. KERNEL → GEOMETRY INTERFACE (bridges field to metric)
// =============================================================================

// MetricProbeArgs bundles (field, u, v) for probe operation
// Workaround for n-ary product types not yet supported
structure MetricProbeArgs {
    element field : FieldR4
    element u     : Vector(4, ℝ)
    element v     : Vector(4, ℝ)
}

structure KernelMetricInterface {
    // Build probe arguments
    operation make_probe_args : FieldR4 × PointPair → MetricProbeArgs
    
    // Metric probe: extracts bilinear form from field
    operation metric_probe : MetricProbeArgs → ℝ
    
    // POT BRIDGE AXIOM: Geometry is kernel-induced
    // Any projected field carries the same induced bilinear form
    // because geometry is a kernel property, not flow-dependent
    axiom probe_recovers_kernel_inner: ∀(psi : Flow, u v : Vector(4, ℝ)).
        metric_probe(make_probe_args(project(psi), make_point_pair(u, v))) = 
            kernel_inner(u, v)
    
    // Probe is symmetric (inherits from metric symmetry)
    axiom probe_symmetric: ∀(f : FieldR4, u v : Vector(4, ℝ)).
        metric_probe(make_probe_args(f, make_point_pair(u, v))) = 
        metric_probe(make_probe_args(f, make_point_pair(v, u)))
}

// PointPair bundles two vectors for probe
structure PointPair {
    element u : Vector(4, ℝ)
    element v : Vector(4, ℝ)
}

structure PointPairOps {
    operation make_point_pair : Vector(4, ℝ) × Vector(4, ℝ) → PointPair
}

// =============================================================================
// 11. UNIVERSE REFINEMENT (partial order by information)
// =============================================================================

structure UniverseOrder {
    operation refines : GreenKernel × GreenKernel → Bool
    
    axiom refines_refl: ∀(G : GreenKernel). refines(G, G)
    
    axiom refines_trans: ∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1)
}

structure UniverseDistinction {
    operation different_universes : GreenKernel × GreenKernel → Bool
    
    // Helper: apply kernel to flow
    operation apply_kernel : GreenKernel × Flow → FieldR4
    
    // Definition: different universes iff some flow projects differently
    axiom different_universes_witness: ∀(G1 G2 : GreenKernel, psi : Flow).
        apply_kernel(G1, psi) ≠ apply_kernel(G2, psi) → different_universes(G1, G2)
}

// =============================================================================
// 11. POT SANITY THEOREMS
// =============================================================================

structure POTSanityTheorems {
    // THEOREM 1: Equivalence preserves all channel residues
    axiom equiv_preserves_residue: ∀(psi1 psi2 : Flow, e : Event, c : Channel).
        equiv(psi1, psi2) → 
            residue(make_pair(project(psi1), e), c) = 
            residue(make_pair(project(psi2), e), c)
    
    // THEOREM 2: Fields distinguishable by residues (contrapositive form)
    // If all residues match, fields are equal
    axiom field_distinguishable: ∀(f1 f2 : FieldR4, e : Event, c : Channel).
        f1 ≠ f2 → residue(make_pair(f1, e), c) ≠ residue(make_pair(f2, e), c)
    
    // THEOREM 3: Different projections → different residues
    // (Key POT result: kernel determines what's observable)
    axiom projection_distinguishable: ∀(f1 f2 : FieldR4, e : Event, c : Channel).
        f1 ≠ f2 → residue(make_pair(f1, e), c) ≠ residue(make_pair(f2, e), c)
}

// =============================================================================
// 12. EXAMPLES
// =============================================================================

example "projector is idempotent" {
    assert(∀(v : Vector(3, ℂ)). P(P(v)) = P(v))
}

example "equivalence is reflexive" {
    assert(∀(psi : Flow). equiv(psi, psi))
}

example "refinement is transitive" {
    assert(∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1))
}

example "point mass residue" {
    assert(∀(e : Event, m : ℝ).
        residue(make_pair(point_mass(e, m), e), Mass) = m)
}
