// Projected Ontology Theory - Core (v2, SMT-friendly)
//
// Fixes from ChatGPT review:
// 1. GreenKernel.project returns FieldR4 (not a single point)
// 2. Nullspace as predicate (more SMT-friendly than Set)
// 3. Flow/field linear structure axioms
// 4. Consistent use of ℝ and ℂ symbols

import "spacetime_type.kleis"

// =============================================================================
// 1. H_ont = ℂ³ with inner product
// =============================================================================

structure InnerProductSpace(n : Nat) {
    operation add   : Vector(n, ℂ) × Vector(n, ℂ) → Vector(n, ℂ)
    operation scale : ℂ × Vector(n, ℂ) → Vector(n, ℂ)
    element zero    : Vector(n, ℂ)

    operation inner : Vector(n, ℂ) × Vector(n, ℂ) → ℂ

    axiom add_comm:  ∀(u v : Vector(n, ℂ)). add(u, v) = add(v, u)
    axiom add_assoc: ∀(u v w : Vector(n, ℂ)).
        add(add(u, v), w) = add(u, add(v, w))
    axiom add_id:    ∀(v : Vector(n, ℂ)). add(v, zero) = v

    // Hermitian symmetry
    axiom inner_conj_sym: ∀(x y : Vector(n, ℂ)).
        inner(x, y) = conjugate(inner(y, x))
}

// =============================================================================
// 2. Views/contexts as projectors on H_ont
// =============================================================================

structure Projector(n : Nat) over InnerProductSpace(n) {
    operation P : Vector(n, ℂ) → Vector(n, ℂ)

    axiom idempotent: ∀(v : Vector(n, ℂ)). P(P(v)) = P(v)

    axiom self_adjoint: ∀(x y : Vector(n, ℂ)).
        inner(P(x), y) = inner(x, P(y))
}

// =============================================================================
// 3. Ontology map Φ : Entity → H_ont (n=3)
// =============================================================================

structure OntologyMap over InnerProductSpace(3) {
    operation Phi : Entity → Vector(3, ℂ)

    operation sim : Entity × Entity → ℝ

    axiom sim_symmetric: ∀(a b : Entity). sim(a, b) = sim(b, a)
    axiom sim_self:      ∀(a : Entity). sim(a, a) = 1
}

// =============================================================================
// 4. Fields on ℝ⁴ and Flow algebra
// =============================================================================

// FieldR4 represents a scalar field on spacetime
structure FieldR4Algebra {
    operation field_add  : FieldR4 × FieldR4 → FieldR4
    operation field_smul : ℂ × FieldR4 → FieldR4
    element field_zero   : FieldR4
    
    axiom field_add_comm: ∀(f g : FieldR4). field_add(f, g) = field_add(g, f)
    axiom field_add_id:   ∀(f : FieldR4). field_add(f, field_zero) = f
}

// Flow linear structure
structure FlowAlgebra {
    operation flow_add  : Flow × Flow → Flow
    operation flow_smul : ℂ × Flow → Flow
    element flow_zero   : Flow
    
    axiom flow_add_comm: ∀(a b : Flow). flow_add(a, b) = flow_add(b, a)
}

// =============================================================================
// 5. Green Kernel: Projects Flow → FieldR4 (KEY FIX)
// =============================================================================

structure GreenKernel {
    // Project modal flow to an ℝ⁴-field (not a single point!)
    operation project : Flow → FieldR4

    // Linearity axioms (captures Green-like kernel without integrals)
    axiom project_lin_add: ∀(a b : Flow).
        project(flow_add(a, b)) = field_add(project(a), project(b))

    axiom project_lin_smul: ∀(c : ℂ, a : Flow).
        project(flow_smul(c, a)) = field_smul(c, project(a))

    // Nullspace as predicate (SMT-friendly)
    operation in_nullspace : Flow → Bool
    
    axiom nullspace_def: ∀(a : Flow).
        in_nullspace(a) → project(a) = field_zero
}

// =============================================================================
// 6. Residues: Point-like observables as projection residues
// =============================================================================

// Residue pair bundles field and event together
structure ResiduePair {
    element field : FieldR4
    element event : Event
}

structure ResidueOperations {
    // Residue operations on pairs
    operation residue_mass   : ResiduePair → ℝ
    operation residue_charge : ResiduePair → ℝ

    // Make a residue pair
    operation make_pair : FieldR4 × Event → ResiduePair
    
    // Point-source constructors
    operation point_mass   : Event × ℝ → FieldR4
    operation point_charge : Event × ℝ → FieldR4

    axiom residue_point_mass: ∀(e : Event, m : ℝ).
        residue_mass(make_pair(point_mass(e, m), e)) = m

    axiom residue_point_charge: ∀(e : Event, q : ℝ).
        residue_charge(make_pair(point_charge(e, q), e)) = q
}

// KEY POT CLAIM: mass at event = residue of projected field
// mass_at(G, ψ, e) = residue_mass(make_pair(G.project(ψ), e))

// =============================================================================
// 7. Equivalence under a kernel (universe-scoped)
// =============================================================================

structure ProjectiveEquivalence over GreenKernel {
    operation equiv : Flow × Flow → Bool
    
    // Definition: equivalent iff same projected field
    axiom equiv_def: ∀(a b : Flow).
        equiv(a, b) → project(a) = project(b)

    axiom refl:  ∀(a : Flow). equiv(a, a)
    axiom sym:   ∀(a b : Flow). equiv(a, b) → equiv(b, a)
    axiom trans: ∀(a b c : Flow). equiv(a, b) ∧ equiv(b, c) → equiv(a, c)
}

// =============================================================================
// 8. Different kernels ⇒ different universes
// =============================================================================

structure UniverseDistinction {
    operation different_universes : GreenKernel × GreenKernel → Bool
}

// =============================================================================
// 9. Examples (universal axiom checks)
// =============================================================================

example "projector is idempotent" {
    assert(∀(v : Vector(3, ℂ)). P(P(v)) = P(v))
}

example "similarity is symmetric" {
    assert(∀(a b : Entity). sim(a, b) = sim(b, a))
}

example "equivalence is reflexive" {
    assert(∀(psi : Flow). equiv(psi, psi))
}

example "residue recovers point mass" {
    assert(∀(e : Event, m : ℝ).
        residue_mass(make_pair(point_mass(e, m), e)) = m)
}
