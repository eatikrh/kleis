// Projected Ontology Theory - Core (v3, with ChatGPT enhancements)
//
// New in v3:
// 1. Typed channels for residues (scalable conserved quantities)
// 2. Particle = residue support predicate
// 3. Universe refinement ordering
// 4. POT sanity theorems

import "spacetime_type.kleis"

// =============================================================================
// 1. H_ont = ℂ³ with inner product
// =============================================================================

structure InnerProductSpace(n : Nat) {
    operation add   : Vector(n, ℂ) × Vector(n, ℂ) → Vector(n, ℂ)
    operation scale : ℂ × Vector(n, ℂ) → Vector(n, ℂ)
    element zero    : Vector(n, ℂ)

    operation inner : Vector(n, ℂ) × Vector(n, ℂ) → ℂ

    axiom add_comm:  ∀(u v : Vector(n, ℂ)). add(u, v) = add(v, u)
    axiom add_assoc: ∀(u v w : Vector(n, ℂ)).
        add(add(u, v), w) = add(u, add(v, w))
    axiom add_id:    ∀(v : Vector(n, ℂ)). add(v, zero) = v

    axiom inner_conj_sym: ∀(x y : Vector(n, ℂ)).
        inner(x, y) = conjugate(inner(y, x))
}

// =============================================================================
// 2. Views/contexts as projectors on H_ont
// =============================================================================

structure Projector(n : Nat) over InnerProductSpace(n) {
    operation P : Vector(n, ℂ) → Vector(n, ℂ)

    axiom idempotent: ∀(v : Vector(n, ℂ)). P(P(v)) = P(v)
    axiom self_adjoint: ∀(x y : Vector(n, ℂ)).
        inner(P(x), y) = inner(x, P(y))
}

// =============================================================================
// 3. Ontology map Φ : Entity → H_ont
// =============================================================================

structure OntologyMap over InnerProductSpace(3) {
    operation Phi : Entity → Vector(3, ℂ)
    operation sim : Entity × Entity → ℝ

    axiom sim_symmetric: ∀(a b : Entity). sim(a, b) = sim(b, a)
    axiom sim_self:      ∀(a : Entity). sim(a, a) = 1
}

// =============================================================================
// 4. Fields and Flow algebras
// =============================================================================

structure FieldR4Algebra {
    operation field_add  : FieldR4 × FieldR4 → FieldR4
    operation field_smul : ℂ × FieldR4 → FieldR4
    element field_zero   : FieldR4
    
    axiom field_add_comm: ∀(f g : FieldR4). field_add(f, g) = field_add(g, f)
    axiom field_add_id:   ∀(f : FieldR4). field_add(f, field_zero) = f
}

structure FlowAlgebra {
    operation flow_add  : Flow × Flow → Flow
    operation flow_smul : ℂ × Flow → Flow
    element flow_zero   : Flow
    
    axiom flow_add_comm: ∀(a b : Flow). flow_add(a, b) = flow_add(b, a)
}

// =============================================================================
// 5. Green Kernel: Projects Flow → FieldR4
// =============================================================================

structure GreenKernel {
    operation project : Flow → FieldR4

    axiom project_lin_add: ∀(a b : Flow).
        project(flow_add(a, b)) = field_add(project(a), project(b))

    axiom project_lin_smul: ∀(c : ℂ, a : Flow).
        project(flow_smul(c, a)) = field_smul(c, project(a))

    operation in_nullspace : Flow → Bool
    
    axiom nullspace_def: ∀(a : Flow).
        in_nullspace(a) → project(a) = field_zero
}

// =============================================================================
// 6. TYPED CHANNELS (scalable conserved quantities)
// =============================================================================

structure ConservedChannel {
    element Mass   : Channel
    element EM     : Channel
    element Spin   : Channel
    element Color  : Channel
    
    operation residue : ResiduePair × Channel → ℝ
}

// =============================================================================
// 7. RESIDUE PAIR AND POINT SOURCES
// =============================================================================

structure ResiduePair {
    element field : FieldR4
    element event : Event
}

structure PointSources {
    operation make_pair : FieldR4 × Event → ResiduePair
    
    operation point_mass   : Event × ℝ → FieldR4
    operation point_charge : Event × ℝ → FieldR4

    axiom residue_point_mass: ∀(e : Event, m : ℝ).
        residue(make_pair(point_mass(e, m), e), Mass) = m

    axiom residue_point_charge: ∀(e : Event, q : ℝ).
        residue(make_pair(point_charge(e, q), e), EM) = q
    
    axiom point_mass_nonzero: ∀(e : Event, m : ℝ).
        m ≠ 0 → point_mass(e, m) ≠ field_zero
}

// =============================================================================
// 8. PARTICLE = RESIDUE SUPPORT
// =============================================================================

structure ParticlePredicates {
    operation has_mass : ResiduePair → Bool
    
    axiom has_mass_def: ∀(rp : ResiduePair).
        has_mass(rp) → residue(rp, Mass) ≠ 0
    
    operation is_particle : ResiduePair → Bool
    
    axiom particle_is_mass: ∀(rp : ResiduePair).
        is_particle(rp) → has_mass(rp)
}

// =============================================================================
// 9. EQUIVALENCE UNDER KERNEL
// =============================================================================

structure ProjectiveEquivalence over GreenKernel {
    operation equiv : Flow × Flow → Bool
    
    axiom equiv_def: ∀(a b : Flow).
        equiv(a, b) → project(a) = project(b)

    axiom refl:  ∀(a : Flow). equiv(a, a)
    axiom sym:   ∀(a b : Flow). equiv(a, b) → equiv(b, a)
    axiom trans: ∀(a b c : Flow). equiv(a, b) ∧ equiv(b, c) → equiv(a, c)
}

// =============================================================================
// 10. UNIVERSE REFINEMENT (partial order by information)
// =============================================================================

structure UniverseOrder {
    operation refines : GreenKernel × GreenKernel → Bool
    
    axiom refines_refl: ∀(G : GreenKernel). refines(G, G)
    
    axiom refines_trans: ∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1)
}

structure UniverseDistinction {
    operation different_universes : GreenKernel × GreenKernel → Bool
}

// =============================================================================
// 11. POT SANITY THEOREMS
// =============================================================================

structure POTSanityTheorems {
    // THEOREM 1: Equivalence preserves all channel residues
    axiom equiv_preserves_residue: ∀(psi1 psi2 : Flow, e : Event, c : Channel).
        equiv(psi1, psi2) → 
            residue(make_pair(project(psi1), e), c) = 
            residue(make_pair(project(psi2), e), c)
    
    // Key POT result: "Equivalent flows are observationally identical"
}

// =============================================================================
// 12. EXAMPLES
// =============================================================================

example "projector is idempotent" {
    assert(∀(v : Vector(3, ℂ)). P(P(v)) = P(v))
}

example "equivalence is reflexive" {
    assert(∀(psi : Flow). equiv(psi, psi))
}

example "refinement is transitive" {
    assert(∀(G1 G2 G3 : GreenKernel).
        refines(G2, G1) ∧ refines(G3, G2) → refines(G3, G1))
}

example "point mass residue" {
    assert(∀(e : Event, m : ℝ).
        residue(make_pair(point_mass(e, m), e), Mass) = m)
}
