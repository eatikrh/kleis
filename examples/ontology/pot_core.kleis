// Projected Ontology Theory - Core Structures
// Minimal formalization that Kleis can parse and verify
//
// Import spacetime_type.kleis for R4Space, MetricOnR4, etc.

import "spacetime_type.kleis"

// =============================================================================
// COMPLEX VECTOR SPACE (C³ = H_ont)
// =============================================================================

structure ComplexVectorSpace(n : Nat) {
    operation add : Vector(n, C) × Vector(n, C) → Vector(n, C)
    operation scale : C × Vector(n, C) → Vector(n, C)
    element zero : Vector(n, C)
    
    axiom add_commutative: ∀(u v : Vector(n, C)). add(u, v) = add(v, u)
    axiom add_associative: ∀(u v w : Vector(n, C)). 
        add(add(u, v), w) = add(u, add(v, w))
    axiom add_identity: ∀(v : Vector(n, C)). add(v, zero) = v
    axiom scale_identity: ∀(v : Vector(n, C)). scale(1, v) = v
}

// =============================================================================
// INNER PRODUCT (Hilbert structure for H_ont)
// =============================================================================

structure InnerProductSpace(n : Nat) extends ComplexVectorSpace(n) {
    operation inner : Vector(n, C) × Vector(n, C) → C
    
    axiom conjugate_symmetry: ∀(x y : Vector(n, C)). 
        inner(x, y) = conjugate(inner(y, x))
}

// H_ont = C³ with inner product
// This is the ontological Hilbert space

// =============================================================================
// PROJECTION OPERATORS (Views/Contexts)
// =============================================================================

structure Projector(n : Nat) over InnerProductSpace(n) {
    operation P : Vector(n, C) → Vector(n, C)
    
    // P² = P (idempotent)
    axiom idempotent: ∀(v : Vector(n, C)). P(P(v)) = P(v)
    
    // P* = P (self-adjoint)  
    axiom self_adjoint: ∀(x y : Vector(n, C)). 
        inner(P(x), y) = inner(x, P(y))
}

// =============================================================================
// ONTOLOGICAL REPRESENTATION
// =============================================================================

// Entities map to vectors in C³ (H_ont)
structure OntologyMap over InnerProductSpace(3) {
    // Representation map Φ: Entity → H_ont
    operation Phi : Entity → Vector(3, C)
    
    // Similarity via normalized inner product
    operation sim : Entity × Entity → R
    
    axiom similarity_symmetric: ∀(a b : Entity). sim(a, b) = sim(b, a)
    axiom similarity_self: ∀(a : Entity). sim(a, a) = 1
    
    // Orthogonality = maximal distinction
    axiom orthogonal_zero_sim: ∀(a b : Entity). 
        inner(Phi(a), Phi(b)) = 0 → sim(a, b) = 0
}

// =============================================================================
// GREEN KERNEL: Projects H_ont → ℝ⁴
// =============================================================================

// Flow represents modal dynamics in H_ont
// (abstracted here; could be parameterized by τ)

structure GreenKernel {
    // Project modal flow to ℝ⁴ (uses R4Space carrier = Vector(4, ℝ))
    operation project : Flow → Vector(4, ℝ)
    
    // Null space: exists ontologically but invisible in ℝ⁴
    operation nullspace : Set(Flow)
    
    // Zero in spacetime
    element zero_spacetime : Vector(4, ℝ)
    
    axiom null_projects_zero: ∀(psi : Flow). 
        in_set(psi, nullspace) → project(psi) = zero_spacetime
}

// =============================================================================
// FIELD ON R4: What the kernel produces
// =============================================================================

structure FieldR4 {
    // A scalar field on spacetime
    operation value : Vector(4, ℝ) → ℝ
}

// =============================================================================
// RESIDUE OPERATIONS: Mass and Charge as projection residues
// =============================================================================

// Key POT insight: "Point mass is residue of projection"
// Mass and charge are not fundamental - they are emergent from kernel singularities

structure ResidueOperations {
    // Residue of field at an event (like contour integral residue)
    operation residue_mass : FieldR4 × Event → ℝ
    operation residue_charge : FieldR4 × Event → ℝ
    
    // The field induced by projecting a flow
    operation field_from_projection : GreenKernel × Flow → FieldR4
    
    // Observable mass/charge operations
    operation mass_at : GreenKernel × Flow × Event → ℝ
    operation charge_at : GreenKernel × Flow × Event → ℝ
    
    // Mass at event = residue of projected field
    axiom mass_from_projection: ∀(G : GreenKernel, psi : Flow, e : Event).
        mass_at(G, psi, e) = residue_mass(field_from_projection(G, psi), e)
    
    // Charge similarly
    axiom charge_from_projection: ∀(G : GreenKernel, psi : Flow, e : Event).
        charge_at(G, psi, e) = residue_charge(field_from_projection(G, psi), e)
}

// =============================================================================
// EQUIVALENCE UNDER PROJECTION
// =============================================================================

// Same reality = same projection
structure ProjectiveEquivalence {
    operation equiv : Flow × Flow → Bool
    
    // Reflexive
    axiom equiv_refl: ∀(psi : Flow). equiv(psi, psi)
    
    // Symmetric
    axiom equiv_sym: ∀(psi1 psi2 : Flow). equiv(psi1, psi2) → equiv(psi2, psi1)
    
    // Transitive
    axiom equiv_trans: ∀(psi1 psi2 psi3 : Flow). 
        equiv(psi1, psi2) ∧ equiv(psi2, psi3) → equiv(psi1, psi3)
}

// =============================================================================
// KEY THEOREM: Different Kernels → Different Universes
// =============================================================================

structure KernelDistinction {
    operation distinct : GreenKernel × GreenKernel → Bool
}

// =============================================================================
// EXAMPLES
// =============================================================================

example "projector is idempotent" {
    assert(∀(v : Vector(3, C)). P(P(v)) = P(v))
}

example "similarity is symmetric" {
    assert(∀(a b : Entity). sim(a, b) = sim(b, a))
}

example "equivalence is reflexive" {
    assert(∀(psi : Flow). equiv(psi, psi))
}

example "mass comes from residue" {
    // Key POT statement: Mass is not fundamental, it's a residue
    assert(∀(G : GreenKernel, psi : Flow, e : Event).
        mass_at(G, psi, e) = residue_mass(field_from_projection(G, psi), e))
}
