// =============================================================================
// Bounded Model Checking for Mutual Exclusion
// =============================================================================
//
// This version explicitly enumerates reachable markings for Z3 verification.
//
// The mutex net has exactly 3 reachable states:
//
// State 0: Initial   - idle1=1, idle2=1, crit1=0, crit2=0, mutex=1  (sum=3)
// State 1: P1 enters - idle1=0, idle2=1, crit1=1, crit2=0, mutex=0  (sum=2)
// State 2: P2 enters - idle1=1, idle2=0, crit1=0, crit2=1, mutex=0  (sum=2)
//
// Note: Total tokens is NOT conserved (3 → 2) because enter consumes 2, produces 1.
// BUT the INVARIANTS are: idle1+crit1=1, idle2+crit2=1, mutex+crit1+crit2=1
//
// =============================================================================

// Marking function: m(state, place) -> tokens
operation m : ℤ × ℤ → ℤ

// Is this a valid reachable state?
operation valid_state : ℤ → Bool

structure ReachableStates {
    // Only states 0, 1, 2 are valid (3 reachable markings)
    axiom valid_states: ∀(s : ℤ). valid_state(s) ↔ (s = 0 ∨ s = 1 ∨ s = 2)
    
    // State 0: Initial (1, 1, 0, 0, 1)
    axiom s0_idle1: m(0, 0) = 1
    axiom s0_idle2: m(0, 1) = 1
    axiom s0_crit1: m(0, 2) = 0
    axiom s0_crit2: m(0, 3) = 0
    axiom s0_mutex: m(0, 4) = 1
    
    // State 1: P1 in critical (0, 1, 1, 0, 0)
    axiom s1_idle1: m(1, 0) = 0
    axiom s1_idle2: m(1, 1) = 1
    axiom s1_crit1: m(1, 2) = 1
    axiom s1_crit2: m(1, 3) = 0
    axiom s1_mutex: m(1, 4) = 0
    
    // State 2: P2 in critical (1, 0, 0, 1, 0)
    axiom s2_idle1: m(2, 0) = 1
    axiom s2_idle2: m(2, 1) = 0
    axiom s2_crit1: m(2, 2) = 0
    axiom s2_crit2: m(2, 3) = 1
    axiom s2_mutex: m(2, 4) = 0
}

// Transition function - DEFINED for eval() to work on ground terms
define can_fire(s, t) = 
    (s = 0 ∧ t = 0) ∨  // state 0: enter1 enabled
    (s = 0 ∧ t = 1) ∨  // state 0: enter2 enabled
    (s = 1 ∧ t = 2) ∨  // state 1: exit1 enabled
    (s = 2 ∧ t = 3)    // state 2: exit2 enabled

define next(s, t) = 
    if s = 0 ∧ t = 0 then 1      // enter1: 0 → 1
    else if s = 0 ∧ t = 1 then 2 // enter2: 0 → 2
    else if s = 1 ∧ t = 2 then 0 // exit1: 1 → 0
    else if s = 2 ∧ t = 3 then 0 // exit2: 2 → 0
    else s  // no change if invalid

// Axioms for Z3 verification (mirrors the definitions)
structure Transitions {
    axiom s0_enter1: can_fire(0, 0) ∧ next(0, 0) = 1
    axiom s0_enter2: can_fire(0, 1) ∧ next(0, 1) = 2
    axiom s0_no_exit: ¬can_fire(0, 2) ∧ ¬can_fire(0, 3)
    axiom s1_exit1: can_fire(1, 2) ∧ next(1, 2) = 0
    axiom s1_no_enter: ¬can_fire(1, 0) ∧ ¬can_fire(1, 1) ∧ ¬can_fire(1, 3)
    axiom s2_exit2: can_fire(2, 3) ∧ next(2, 3) = 0
    axiom s2_no_enter: ¬can_fire(2, 0) ∧ ¬can_fire(2, 1) ∧ ¬can_fire(2, 2)
}

// -----------------------------------------------------------------------------
// VERIFICATION EXAMPLES - Key properties verified by Z3!
// -----------------------------------------------------------------------------

example "MUTUAL EXCLUSION: crit1 and crit2 never both have tokens" {
    // THE KEY SAFETY PROPERTY - verified by Z3!
    assert(∀(s : ℤ). valid_state(s) → ¬(m(s, 2) ≥ 1 ∧ m(s, 3) ≥ 1))
}

example "MUTEX BOUNDED: mutex is always 0 or 1" {
    assert(∀(s : ℤ). valid_state(s) → (m(s, 4) = 0 ∨ m(s, 4) = 1))
}

example "PROCESS 1 INVARIANT: idle1 + crit1 = 1" {
    // Each process always has exactly 1 token between idle and critical
    assert(∀(s : ℤ). valid_state(s) → m(s, 0) + m(s, 2) = 1)
}

example "PROCESS 2 INVARIANT: idle2 + crit2 = 1" {
    assert(∀(s : ℤ). valid_state(s) → m(s, 1) + m(s, 3) = 1)
}

example "MUTEX INVARIANT: mutex + crit1 + crit2 = 1" {
    // The mutex is available iff no one is in critical section
    assert(∀(s : ℤ). valid_state(s) → m(s, 4) + m(s, 2) + m(s, 3) = 1)
}

example "NO DEADLOCK: some transition always enabled" {
    assert(∀(s : ℤ). valid_state(s) → 
        (can_fire(s, 0) ∨ can_fire(s, 1) ∨ can_fire(s, 2) ∨ can_fire(s, 3)))
}

example "SYMMETRY: both processes can reach critical section" {
    // State 1 has P1 in critical, State 2 has P2 in critical
    assert(∃(s : ℤ). valid_state(s) ∧ m(s, 2) = 1)
    assert(∃(s : ℤ). valid_state(s) ∧ m(s, 3) = 1)
}

example "REVERSIBILITY via Z3: both states can return to initial" {
    // Verified via Z3 with quantifiers
    assert(∀(x : ℤ). x = 1 → can_fire(x, 2))
    assert(∀(x : ℤ). x = 2 → can_fire(x, 3))
    assert(∀(x : ℤ). x = 1 → next(x, 2) = 0)
    assert(∀(x : ℤ). x = 2 → next(x, 3) = 0)
}

example "REVERSIBILITY via eval(): state 1 returns" {
    // eval() with defined functions - ground term evaluation
    // Compare to true constant, not boolean object
    assert(eval(can_fire(1, 2)) = true)
    assert(eval(next(1, 2)) = 0)
}

example "REVERSIBILITY via eval(): state 2 returns" {
    assert(eval(can_fire(2, 3)) = true)
    assert(eval(next(2, 3)) = 0)
}

example "BOUNDED: all places are 1-bounded" {
    // No place ever has more than 1 token
    assert(∀(s : ℤ). valid_state(s) → 
        m(s, 0) ≤ 1 ∧ m(s, 1) ≤ 1 ∧ m(s, 2) ≤ 1 ∧ m(s, 3) ≤ 1 ∧ m(s, 4) ≤ 1)
}
