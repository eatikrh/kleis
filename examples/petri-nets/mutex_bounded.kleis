// =============================================================================
// Bounded Model Checking for Mutual Exclusion
// =============================================================================
//
// This version explicitly enumerates reachable markings for Z3 verification.
//
// The mutex net has exactly 3 reachable states:
//
// State 0: Initial   - idle1=1, idle2=1, crit1=0, crit2=0, mutex=1  (sum=3)
// State 1: P1 enters - idle1=0, idle2=1, crit1=1, crit2=0, mutex=0  (sum=2)
// State 2: P2 enters - idle1=1, idle2=0, crit1=0, crit2=1, mutex=0  (sum=2)
//
// Note: Total tokens is NOT conserved (3 → 2) because enter consumes 2, produces 1.
// BUT the INVARIANTS are: idle1+crit1=1, idle2+crit2=1, mutex+crit1+crit2=1
//
// =============================================================================

// Marking function: m(state, place) -> tokens
operation m : ℤ × ℤ → ℤ

// Is this a valid reachable state?
operation valid_state : ℤ → Bool

structure ReachableStates {
    // Only states 0, 1, 2 are valid (3 reachable markings)
    axiom valid_states: ∀(s : ℤ). valid_state(s) ↔ (s = 0 ∨ s = 1 ∨ s = 2)
    
    // State 0: Initial (1, 1, 0, 0, 1)
    axiom s0_idle1: m(0, 0) = 1
    axiom s0_idle2: m(0, 1) = 1
    axiom s0_crit1: m(0, 2) = 0
    axiom s0_crit2: m(0, 3) = 0
    axiom s0_mutex: m(0, 4) = 1
    
    // State 1: P1 in critical (0, 1, 1, 0, 0)
    axiom s1_idle1: m(1, 0) = 0
    axiom s1_idle2: m(1, 1) = 1
    axiom s1_crit1: m(1, 2) = 1
    axiom s1_crit2: m(1, 3) = 0
    axiom s1_mutex: m(1, 4) = 0
    
    // State 2: P2 in critical (1, 0, 0, 1, 0)
    axiom s2_idle1: m(2, 0) = 1
    axiom s2_idle2: m(2, 1) = 0
    axiom s2_crit1: m(2, 2) = 0
    axiom s2_crit2: m(2, 3) = 1
    axiom s2_mutex: m(2, 4) = 0
}

// Transition function
operation can_fire : ℤ × ℤ → Bool
operation next : ℤ × ℤ → ℤ

structure Transitions {
    // From state 0: can fire enter1 (t=0) → state 1, or enter2 (t=1) → state 2
    axiom s0_enter1: can_fire(0, 0) ∧ next(0, 0) = 1
    axiom s0_enter2: can_fire(0, 1) ∧ next(0, 1) = 2
    axiom s0_no_exit: ¬can_fire(0, 2) ∧ ¬can_fire(0, 3)
    
    // From state 1: can fire exit1 (t=2) → state 0
    axiom s1_exit1: can_fire(1, 2) ∧ next(1, 2) = 0
    axiom s1_no_enter: ¬can_fire(1, 0) ∧ ¬can_fire(1, 1) ∧ ¬can_fire(1, 3)
    
    // From state 2: can fire exit2 (t=3) → state 0
    axiom s2_exit2: can_fire(2, 3) ∧ next(2, 3) = 0
    axiom s2_no_enter: ¬can_fire(2, 0) ∧ ¬can_fire(2, 1) ∧ ¬can_fire(2, 2)
}

// -----------------------------------------------------------------------------
// VERIFICATION EXAMPLES - Key properties verified by Z3!
// -----------------------------------------------------------------------------

example "MUTUAL EXCLUSION: crit1 and crit2 never both have tokens" {
    // THE KEY SAFETY PROPERTY - verified by Z3!
    assert(∀(s : ℤ). valid_state(s) → ¬(m(s, 2) ≥ 1 ∧ m(s, 3) ≥ 1))
}

example "MUTEX BOUNDED: mutex is always 0 or 1" {
    assert(∀(s : ℤ). valid_state(s) → (m(s, 4) = 0 ∨ m(s, 4) = 1))
}

example "PROCESS 1 INVARIANT: idle1 + crit1 = 1" {
    // Each process always has exactly 1 token between idle and critical
    assert(∀(s : ℤ). valid_state(s) → m(s, 0) + m(s, 2) = 1)
}

example "PROCESS 2 INVARIANT: idle2 + crit2 = 1" {
    assert(∀(s : ℤ). valid_state(s) → m(s, 1) + m(s, 3) = 1)
}

example "MUTEX INVARIANT: mutex + crit1 + crit2 = 1" {
    // The mutex is available iff no one is in critical section
    assert(∀(s : ℤ). valid_state(s) → m(s, 4) + m(s, 2) + m(s, 3) = 1)
}

example "NO DEADLOCK: some transition always enabled" {
    assert(∀(s : ℤ). valid_state(s) → 
        (can_fire(s, 0) ∨ can_fire(s, 1) ∨ can_fire(s, 2) ∨ can_fire(s, 3)))
}

example "SYMMETRY: both processes can reach critical section" {
    // State 1 has P1 in critical, State 2 has P2 in critical
    assert(∃(s : ℤ). valid_state(s) ∧ m(s, 2) = 1)
    assert(∃(s : ℤ). valid_state(s) ∧ m(s, 3) = 1)
}

example "REVERSIBILITY: state 1 can return to initial" {
    // From state 1, exit1 (t=2) leads back to state 0
    // This is a ground fact that should be verified by Z3 from axioms
    assert(∀(x : ℤ). x = 1 → can_fire(x, 2))
    assert(∀(x : ℤ). x = 1 → next(x, 2) = 0)
}

example "REVERSIBILITY: state 2 can return to initial" {
    // From state 2, exit2 (t=3) leads back to state 0
    assert(∀(x : ℤ). x = 2 → can_fire(x, 3))
    assert(∀(x : ℤ). x = 2 → next(x, 3) = 0)
}

example "BOUNDED: all places are 1-bounded" {
    // No place ever has more than 1 token
    assert(∀(s : ℤ). valid_state(s) → 
        m(s, 0) ≤ 1 ∧ m(s, 1) ≤ 1 ∧ m(s, 2) ≤ 1 ∧ m(s, 3) ≤ 1 ∧ m(s, 4) ≤ 1)
}
