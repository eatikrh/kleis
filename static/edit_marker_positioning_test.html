<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Marker Positioning Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .instructions {
            background: #fff3cd;
            border: 2px solid #ffc107;
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
        }
        
        .instructions h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .instructions ol {
            margin-left: 20px;
            color: #856404;
        }
        
        .instructions li {
            margin: 8px 0;
        }
        
        .summary {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 15px;
        }
        
        .stat {
            font-size: 2em;
            font-weight: bold;
        }
        
        .stat.good { color: #28a745; }
        .stat.bad { color: #dc3545; }
        .stat.offset { color: #ffc107; }
        
        .stat-label {
            font-size: 0.8em;
            color: #6c757d;
            display: block;
            margin-top: 5px;
        }
        
        .test-section {
            padding: 20px;
        }
        
        .category {
            margin-bottom: 40px;
        }
        
        .category-title {
            font-size: 1.3em;
            color: #667eea;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
        }
        
        .test-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s;
        }
        
        .test-card.good {
            border-color: #28a745;
            background: #f0fff4;
        }
        
        .test-card.bad {
            border-color: #dc3545;
            background: #fff5f5;
        }
        
        .test-card.offset {
            border-color: #ffc107;
            background: #fffbf0;
        }
        
        .template-name {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 0.95em;
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-indicator.good { background: #28a745; }
        .status-indicator.bad { background: #dc3545; }
        .status-indicator.offset { background: #ffc107; }
        .status-indicator.pending { background: #6c757d; }
        
        .render-container {
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fafafa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            position: relative;
            overflow: visible;
        }
        
        .render-container svg {
            max-width: 100%;
            height: auto;
        }
        
        .assessment {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .assessment.good {
            background: #d4edda;
            color: #155724;
        }
        
        .assessment.bad {
            background: #f8d7da;
            color: #721c24;
        }
        
        .assessment.offset {
            background: #fff3cd;
            color: #856404;
        }
        
        .assessment.pending {
            background: #e7f3ff;
            color: #004085;
        }
        
        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 10px;
        }
        
        button:hover {
            background: #5568d3;
        }
        
        .manual-rating {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .rating-btn {
            padding: 8px 16px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .rating-btn.good { background: #28a745; }
        .rating-btn.offset { background: #ffc107; }
        .rating-btn.bad { background: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ Edit Marker Positioning Test</h1>
            <p>Visual verification of overlay accuracy for all 54 templates</p>
            <button onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
            <button onclick="exportResults()">üìä Export Results</button>
        </header>
        
        <div class="instructions">
            <h3>üìã Testing Instructions</h3>
            <ol>
                <li><strong>Click "Run All Tests"</strong> to render all templates with edit markers</li>
                <li><strong>Visually inspect each template</strong> - Are the green/blue boxes positioned correctly over the placeholders (‚ñ°)?</li>
                <li><strong>Rate each template:</strong>
                    <ul>
                        <li>‚úÖ <strong>Good</strong> - Markers perfectly aligned with placeholders</li>
                        <li>‚ö†Ô∏è <strong>Offset</strong> - Markers visible but slightly misaligned</li>
                        <li>‚ùå <strong>Bad</strong> - Markers completely wrong or invisible</li>
                    </ul>
                </li>
                <li><strong>Click rating buttons</strong> under each template to record your assessment</li>
                <li><strong>Export results</strong> when done to get a summary report</li>
            </ol>
        </div>
        
        <div class="summary">
            <h2>Assessment Summary</h2>
            <div class="stats">
                <div>
                    <span class="stat good" id="goodCount">0</span>
                    <span class="stat-label">Good Alignment</span>
                </div>
                <div>
                    <span class="stat offset" id="offsetCount">0</span>
                    <span class="stat-label">Slight Offset</span>
                </div>
                <div>
                    <span class="stat bad" id="badCount">0</span>
                    <span class="stat-label">Poor Alignment</span>
                </div>
                <div>
                    <span class="stat" id="pendingCount">54</span>
                    <span class="stat-label">Not Rated</span>
                </div>
            </div>
        </div>
        
        <div class="test-section">
            <div class="category">
                <h2 class="category-title">üìê Basic Operations</h2>
                <div class="test-grid" id="basic-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">‚à´ Calculus</h2>
                <div class="test-grid" id="calculus-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">üî¢ Matrices</h2>
                <div class="test-grid" id="matrix-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">‚öõÔ∏è Quantum</h2>
                <div class="test-grid" id="quantum-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">‚û°Ô∏è Vectors</h2>
                <div class="test-grid" id="vector-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">üìä Functions</h2>
                <div class="test-grid" id="function-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">üé® Accents</h2>
                <div class="test-grid" id="accent-tests"></div>
            </div>
            
            <div class="category">
                <h2 class="category-title">üìê Tensors</h2>
                <div class="test-grid" id="tensor-tests"></div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:3000/api';
        
        // Import astTemplates from parent or define inline
        const astTemplates = {
            // Basic
            fraction: { Operation: { name: 'scalar_divide', args: [{Placeholder:{id:0,hint:'numerator'}}, {Placeholder:{id:1,hint:'denominator'}}] } },
            sqrt: { Operation: { name: 'sqrt', args: [{Placeholder:{id:0,hint:'radicand'}}] } },
            nthroot: { Operation: { name: 'nthroot', args: [{Placeholder:{id:0,hint:'index'}}, {Placeholder:{id:1,hint:'radicand'}}] } },
            power: { Operation: { name: 'sup', args: [{Placeholder:{id:0,hint:'base'}}, {Placeholder:{id:1,hint:'exponent'}}] } },
            subscript: { Operation: { name: 'sub', args: [{Placeholder:{id:0,hint:'base'}}, {Placeholder:{id:1,hint:'subscript'}}] } },
            tensor_mixed: { Operation: { name: 'index_mixed', args: [{Placeholder:{id:0,hint:'base'}}, {Placeholder:{id:1,hint:'upper'}}, {Placeholder:{id:2,hint:'lower'}}] } },
            binomial: { Operation: { name: 'binomial', args: [{Placeholder:{id:0,hint:'n'}}, {Placeholder:{id:1,hint:'k'}}] } },
            factorial: { Operation: { name: 'factorial', args: [{Placeholder:{id:0,hint:'n'}}] } },
            floor: { Operation: { name: 'floor', args: [{Placeholder:{id:0,hint:'x'}}] } },
            ceiling: { Operation: { name: 'ceiling', args: [{Placeholder:{id:0,hint:'x'}}] } },
            
            // Calculus
            integral: { Operation: { name: 'int_bounds', args: [{Placeholder:{id:0,hint:'integrand'}}, {Placeholder:{id:1,hint:'lower'}}, {Placeholder:{id:2,hint:'upper'}}, {Placeholder:{id:3,hint:'variable'}}] } },
            sum: { Operation: { name: 'sum_bounds', args: [{Placeholder:{id:0,hint:'body'}}, {Placeholder:{id:1,hint:'from'}}, {Placeholder:{id:2,hint:'to'}}] } },
            product: { Operation: { name: 'prod_bounds', args: [{Placeholder:{id:0,hint:'body'}}, {Placeholder:{id:1,hint:'from'}}, {Placeholder:{id:2,hint:'to'}}] } },
            limit: { Operation: { name: 'lim', args: [{Placeholder:{id:0,hint:'body'}}, {Placeholder:{id:1,hint:'var'}}, {Placeholder:{id:2,hint:'target'}}] } },
            partial: { Operation: { name: 'd_part', args: [{Placeholder:{id:0,hint:'function'}}, {Placeholder:{id:1,hint:'variable'}}] } },
            derivative: { Operation: { name: 'd_dt', args: [{Placeholder:{id:0,hint:'function'}}, {Placeholder:{id:1,hint:'variable'}}] } },
            gradient: { Operation: { name: 'grad', args: [{Placeholder:{id:0,hint:'function'}}] } },
            
            // Matrices
            matrix2x2: { Operation: { name: 'matrix2x2', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a21'}}, {Placeholder:{id:3,hint:'a22'}}] } },
            matrix3x3: { Operation: { name: 'matrix3x3', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a13'}}, {Placeholder:{id:3,hint:'a21'}}, {Placeholder:{id:4,hint:'a22'}}, {Placeholder:{id:5,hint:'a23'}}, {Placeholder:{id:6,hint:'a31'}}, {Placeholder:{id:7,hint:'a32'}}, {Placeholder:{id:8,hint:'a33'}}] } },
            pmatrix2x2: { Operation: { name: 'pmatrix2x2', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a21'}}, {Placeholder:{id:3,hint:'a22'}}] } },
            pmatrix3x3: { Operation: { name: 'pmatrix3x3', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a13'}}, {Placeholder:{id:3,hint:'a21'}}, {Placeholder:{id:4,hint:'a22'}}, {Placeholder:{id:5,hint:'a23'}}, {Placeholder:{id:6,hint:'a31'}}, {Placeholder:{id:7,hint:'a32'}}, {Placeholder:{id:8,hint:'a33'}}] } },
            vmatrix2x2: { Operation: { name: 'vmatrix2x2', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a21'}}, {Placeholder:{id:3,hint:'a22'}}] } },
            vmatrix3x3: { Operation: { name: 'vmatrix3x3', args: [{Placeholder:{id:0,hint:'a11'}}, {Placeholder:{id:1,hint:'a12'}}, {Placeholder:{id:2,hint:'a13'}}, {Placeholder:{id:3,hint:'a21'}}, {Placeholder:{id:4,hint:'a22'}}, {Placeholder:{id:5,hint:'a23'}}, {Placeholder:{id:6,hint:'a31'}}, {Placeholder:{id:7,hint:'a32'}}, {Placeholder:{id:8,hint:'a33'}}] } },
            
            // Quantum
            ket: { Operation: { name: 'ket', args: [{Placeholder:{id:0,hint:'state'}}] } },
            bra: { Operation: { name: 'bra', args: [{Placeholder:{id:0,hint:'state'}}] } },
            inner: { Operation: { name: 'inner', args: [{Placeholder:{id:0,hint:'bra'}}, {Placeholder:{id:1,hint:'ket'}}] } },
            outer: { Operation: { name: 'outer', args: [{Placeholder:{id:0,hint:'ket'}}, {Placeholder:{id:1,hint:'bra'}}] } },
            commutator: { Operation: { name: 'commutator', args: [{Placeholder:{id:0,hint:'A'}}, {Placeholder:{id:1,hint:'B'}}] } },
            expectation: { Operation: { name: 'expectation', args: [{Placeholder:{id:0,hint:'operator'}}] } },
            
            // Vectors
            vector_bold: { Operation: { name: 'vector_bold', args: [{Placeholder:{id:0,hint:'vector'}}] } },
            vector_arrow: { Operation: { name: 'vector_arrow', args: [{Placeholder:{id:0,hint:'vector'}}] } },
            dot: { Operation: { name: 'dot', args: [{Placeholder:{id:0,hint:'left'}}, {Placeholder:{id:1,hint:'right'}}] } },
            cross: { Operation: { name: 'cross', args: [{Placeholder:{id:0,hint:'left'}}, {Placeholder:{id:1,hint:'right'}}] } },
            norm: { Operation: { name: 'norm', args: [{Placeholder:{id:0,hint:'vector'}}] } },
            abs: { Operation: { name: 'abs', args: [{Placeholder:{id:0,hint:'value'}}] } },
            
            // Functions
            sin: { Operation: { name: 'sin', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            cos: { Operation: { name: 'cos', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            tan: { Operation: { name: 'tan', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            arcsin: { Operation: { name: 'arcsin', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            arccos: { Operation: { name: 'arccos', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            arctan: { Operation: { name: 'arctan', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            ln: { Operation: { name: 'ln', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            log: { Operation: { name: 'log', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            exp: { Operation: { name: 'exp', args: [{Placeholder:{id:0,hint:'argument'}}] } },
            
            // Accents
            dot_accent: { Operation: { name: 'dot_accent', args: [{Placeholder:{id:0,hint:'variable'}}] } },
            ddot_accent: { Operation: { name: 'ddot_accent', args: [{Placeholder:{id:0,hint:'variable'}}] } },
            hat: { Operation: { name: 'hat', args: [{Placeholder:{id:0,hint:'variable'}}] } },
            bar: { Operation: { name: 'bar', args: [{Placeholder:{id:0,hint:'variable'}}] } },
            tilde: { Operation: { name: 'tilde', args: [{Placeholder:{id:0,hint:'variable'}}] } },
            
            // Tensors
            christoffel: { Operation: { name: 'gamma', args: [{Object: ''}, {Placeholder:{id:0,hint:'upper'}}, {Placeholder:{id:1,hint:'lower1'}}, {Placeholder:{id:2,hint:'lower2'}}] } },
            riemann: { Operation: { name: 'riemann', args: [{Object: ''}, {Placeholder:{id:0,hint:'upper'}}, {Placeholder:{id:1,hint:'lower1'}}, {Placeholder:{id:2,hint:'lower2'}}, {Placeholder:{id:3,hint:'lower3'}}] } },
        };
        
        const testCases = {
            'basic': [
                { name: 'Fraction', astName: 'fraction' },
                { name: 'Square Root', astName: 'sqrt' },
                { name: 'Nth Root', astName: 'nthroot' },
                { name: 'Power', astName: 'power' },
                { name: 'Subscript', astName: 'subscript' },
                { name: 'Mixed Index', astName: 'tensor_mixed' },
                { name: 'Binomial', astName: 'binomial' },
                { name: 'Factorial', astName: 'factorial' },
                { name: 'Floor', astName: 'floor' },
                { name: 'Ceiling', astName: 'ceiling' },
            ],
            'calculus': [
                { name: 'Integral', astName: 'integral' },
                { name: 'Sum', astName: 'sum' },
                { name: 'Product', astName: 'product' },
                { name: 'Limit', astName: 'limit' },
                { name: 'Partial', astName: 'partial' },
                { name: 'Derivative', astName: 'derivative' },
                { name: 'Gradient', astName: 'gradient' },
            ],
            'matrix': [
                { name: 'Matrix 2√ó2 [brackets]', astName: 'matrix2x2' },
                { name: 'Matrix 3√ó3 [brackets]', astName: 'matrix3x3' },
                { name: 'PMatrix 2√ó2 (parens)', astName: 'pmatrix2x2' },
                { name: 'PMatrix 3√ó3 (parens)', astName: 'pmatrix3x3' },
                { name: 'VMatrix 2√ó2 (bars)', astName: 'vmatrix2x2' },
                { name: 'VMatrix 3√ó3 (bars)', astName: 'vmatrix3x3' },
            ],
            'quantum': [
                { name: 'Ket', astName: 'ket' },
                { name: 'Bra', astName: 'bra' },
                { name: 'Inner Product', astName: 'inner' },
                { name: 'Outer Product', astName: 'outer' },
                { name: 'Commutator', astName: 'commutator' },
                { name: 'Expectation', astName: 'expectation' },
            ],
            'vector': [
                { name: 'Bold Vector', astName: 'vector_bold' },
                { name: 'Vector Arrow', astName: 'vector_arrow' },
                { name: 'Dot Product', astName: 'dot' },
                { name: 'Cross Product', astName: 'cross' },
                { name: 'Norm', astName: 'norm' },
                { name: 'Absolute Value', astName: 'abs' },
            ],
            'function': [
                { name: 'Sine', astName: 'sin' },
                { name: 'Cosine', astName: 'cos' },
                { name: 'Tangent', astName: 'tan' },
                { name: 'Arcsine', astName: 'arcsin' },
                { name: 'Arccosine', astName: 'arccos' },
                { name: 'Arctangent', astName: 'arctan' },
                { name: 'Natural Log', astName: 'ln' },
                { name: 'Logarithm', astName: 'log' },
                { name: 'Exponential', astName: 'exp' },
            ],
            'accent': [
                { name: 'Dot', astName: 'dot_accent' },
                { name: 'Double Dot', astName: 'ddot_accent' },
                { name: 'Hat', astName: 'hat' },
                { name: 'Bar', astName: 'bar' },
                { name: 'Tilde', astName: 'tilde' },
            ],
            'tensor': [
                { name: 'Christoffel', astName: 'christoffel' },
                { name: 'Riemann', astName: 'riemann' },
            ],
        };
        
        let assessments = {};
        let goodCount = 0;
        let offsetCount = 0;
        let badCount = 0;
        let pendingCount = 54;
        
        async function testTemplate(category, test) {
            const card = document.createElement('div');
            card.className = 'test-card';
            card.id = `test-${test.astName}`;
            
            const nameDiv = document.createElement('div');
            nameDiv.className = 'template-name';
            const indicator = document.createElement('span');
            indicator.className = 'status-indicator pending';
            indicator.id = `indicator-${test.astName}`;
            nameDiv.appendChild(indicator);
            nameDiv.appendChild(document.createTextNode(test.name));
            
            const renderDiv = document.createElement('div');
            renderDiv.className = 'render-container';
            renderDiv.innerHTML = '<div style="color: #999;">Loading...</div>';
            
            const assessmentDiv = document.createElement('div');
            assessmentDiv.className = 'assessment pending';
            assessmentDiv.id = `assessment-${test.astName}`;
            assessmentDiv.textContent = '‚è≥ Awaiting your assessment...';
            
            const ratingDiv = document.createElement('div');
            ratingDiv.className = 'manual-rating';
            
            const goodBtn = document.createElement('button');
            goodBtn.className = 'rating-btn good';
            goodBtn.textContent = '‚úÖ Good';
            goodBtn.onclick = () => rateTemplate(test.astName, 'good');
            
            const offsetBtn = document.createElement('button');
            offsetBtn.className = 'rating-btn offset';
            offsetBtn.textContent = '‚ö†Ô∏è Offset';
            offsetBtn.onclick = () => rateTemplate(test.astName, 'offset');
            
            const badBtn = document.createElement('button');
            badBtn.className = 'rating-btn bad';
            badBtn.textContent = '‚ùå Bad';
            badBtn.onclick = () => rateTemplate(test.astName, 'bad');
            
            ratingDiv.appendChild(goodBtn);
            ratingDiv.appendChild(offsetBtn);
            ratingDiv.appendChild(badBtn);
            
            card.appendChild(nameDiv);
            card.appendChild(renderDiv);
            card.appendChild(assessmentDiv);
            card.appendChild(ratingDiv);
            
            document.getElementById(category + '-tests').appendChild(card);
            
            // Render the template
            try {
                const ast = astTemplates[test.astName];
                if (!ast) {
                    throw new Error('AST template not found');
                }
                
                const response = await fetch(`${API_BASE}/render_typst`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ast })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Inject overlays into SVG (EXACT SAME LOGIC AS MAIN EDITOR)
                    let svg = data.svg;
                    
                    if (data.argument_slots && data.argument_slots.length > 0) {
                        let overlayElements = [];
                        
                        // Helper function for node ID
                        function nodeIdFromPath(pathArray) {
                            const segments = [0];
                            if (Array.isArray(pathArray)) {
                                pathArray.forEach((idx) => segments.push(idx));
                            }
                            return segments.join('.');
                        }
                        
                        data.argument_slots.forEach((slot, index) => {
                            let rectX, rectY, rectWidth, rectHeight;
                            let foundPosition = false;
                            let currentNodeId = null;
                            const role = slot.role || null;
                            
                            // SEMANTIC-FIRST: Try semantic bounding box FIRST (matches main editor)
                            const nodePathId = nodeIdFromPath(slot.path || []);
                            const bbox = data.argument_bounding_boxes && 
                                        data.argument_bounding_boxes.find(b => b.node_id === nodePathId);
                            
                            if (bbox) {
                                rectX = bbox.x - 3;
                                rectY = bbox.y - 3;
                                rectWidth = bbox.width + 6;
                                rectHeight = bbox.height + 6;
                                foundPosition = true;
                                currentNodeId = bbox.node_id;
                            } else {
                                // Fallback to placeholder position
                                const ph = data.placeholders && data.placeholders.find(p => p.id === slot.id);
                                if (ph) {
                                    rectX = ph.x - 3;
                                    rectY = ph.y - 3;
                                    rectWidth = ph.width + 6;
                                    rectHeight = ph.height + 6;
                                    foundPosition = true;
                                }
                            }
                            
                            if (foundPosition) {
                                const widthFactor = role === 'base' ? 0.6 : 0.5;
                                const heightFactor = role === 'base' ? 0.65 : 0.5;

                                const originalWidth = rectWidth;
                                const originalHeight = rectHeight;

                                rectWidth = Math.max(6, rectWidth * widthFactor);
                                rectHeight = Math.max(6, rectHeight * heightFactor);

                                const centerShiftX = (originalWidth - rectWidth) / 2;
                                let centerShiftY = (originalHeight - rectHeight) / 2;

                                rectX += centerShiftX;
                                rectY += centerShiftY;

                                if (role === 'superscript') {
                                    const shift = Math.max(4, rectHeight * 0.4);
                                    rectY -= shift;
                                    rectHeight = Math.max(6, rectHeight * 0.8);
                                } else if (role === 'subscript') {
                                    const shift = Math.max(4, rectHeight * 0.4);
                                    rectY += shift;
                                    rectHeight = Math.max(6, rectHeight * 0.8);
                                } else if (role === 'base') {
                                    const superscriptShift = Math.max(4, rectHeight * 0.4);
                                    rectY -= superscriptShift;
                                    rectHeight = Math.max(6, rectHeight + superscriptShift);
                                }
                                
                                const color = slot.is_placeholder ? '#667eea' : '#28a745';
                                const fillColor = slot.is_placeholder ? 'rgba(102, 126, 234, 0.3)' : 'rgba(40, 167, 69, 0.3)';
                                
                                overlayElements.push(`<rect x="${rectX}" y="${rectY}" width="${rectWidth}" height="${rectHeight}"
                                    fill="${fillColor}" stroke="${color}" stroke-width="2" stroke-dasharray="6,3" rx="3" />`);
                            }
                        });
                        
                        if (overlayElements.length > 0) {
                            svg = svg.replace('</svg>', `<g id="overlays">${overlayElements.join('')}</g></svg>`);
                        }
                    }
                    
                    renderDiv.innerHTML = svg;
                    assessmentDiv.textContent = `üìä ${data.placeholders.length} placeholders, ${data.argument_slots.length} slots - Please rate alignment`;
                } else {
                    renderDiv.innerHTML = `<div style="color: #dc3545;">Error: ${data.error}</div>`;
                    assessmentDiv.textContent = '‚ùå Rendering failed';
                    assessmentDiv.className = 'assessment bad';
                }
            } catch (error) {
                renderDiv.innerHTML = `<div style="color: #dc3545;">Error: ${error.message}</div>`;
                assessmentDiv.textContent = '‚ùå Test failed';
                assessmentDiv.className = 'assessment bad';
            }
        }
        
        function rateTemplate(astName, rating) {
            // Update previous rating if exists
            if (assessments[astName]) {
                const oldRating = assessments[astName];
                if (oldRating === 'good') goodCount--;
                else if (oldRating === 'offset') offsetCount--;
                else if (oldRating === 'bad') badCount--;
                pendingCount++;
            }
            
            // Set new rating
            assessments[astName] = rating;
            pendingCount--;
            
            if (rating === 'good') goodCount++;
            else if (rating === 'offset') offsetCount++;
            else if (rating === 'bad') badCount++;
            
            // Update UI
            const card = document.getElementById(`test-${astName}`);
            const indicator = document.getElementById(`indicator-${astName}`);
            const assessment = document.getElementById(`assessment-${astName}`);
            
            card.className = 'test-card ' + rating;
            indicator.className = 'status-indicator ' + rating;
            assessment.className = 'assessment ' + rating;
            
            if (rating === 'good') {
                assessment.textContent = '‚úÖ Good - Markers perfectly aligned';
            } else if (rating === 'offset') {
                assessment.textContent = '‚ö†Ô∏è Offset - Markers slightly misaligned but usable';
            } else if (rating === 'bad') {
                assessment.textContent = '‚ùå Bad - Markers completely wrong or unusable';
            }
            
            updateSummary();
        }
        
        function updateSummary() {
            document.getElementById('goodCount').textContent = goodCount;
            document.getElementById('offsetCount').textContent = offsetCount;
            document.getElementById('badCount').textContent = badCount;
            document.getElementById('pendingCount').textContent = pendingCount;
        }
        
        async function runAllTests() {
            for (const [category, tests] of Object.entries(testCases)) {
                for (const test of tests) {
                    await testTemplate(category, test);
                    await new Promise(resolve => setTimeout(resolve, 200)); // Delay for server
                }
            }
            
            alert('‚úÖ All templates rendered!\n\nPlease visually inspect each template and rate the marker alignment using the buttons below each one.');
        }
        
        function exportResults() {
            const results = {
                timestamp: new Date().toISOString(),
                total: 54,
                good: goodCount,
                offset: offsetCount,
                bad: badCount,
                pending: pendingCount,
                details: assessments
            };
            
            console.log('=== Edit Marker Positioning Test Results ===');
            console.log(JSON.stringify(results, null, 2));
            
            // Create downloadable report
            const report = `# Edit Marker Positioning Test Results
            
Date: ${new Date().toLocaleString()}

## Summary
- Total Templates: 54
- Good Alignment: ${goodCount} (${(goodCount/54*100).toFixed(1)}%)
- Slight Offset: ${offsetCount} (${(offsetCount/54*100).toFixed(1)}%)
- Poor Alignment: ${badCount} (${(badCount/54*100).toFixed(1)}%)
- Not Rated: ${pendingCount}

## Detailed Assessments
${Object.entries(assessments).map(([name, rating]) => `- ${name}: ${rating}`).join('\n')}

## Recommendations
${badCount > 0 ? `‚ö†Ô∏è ${badCount} templates need coordinate fixes` : ''}
${offsetCount > 5 ? `‚ö†Ô∏è ${offsetCount} templates have minor offset issues` : ''}
${goodCount === 54 ? '‚úÖ All templates have perfect alignment!' : ''}
`;
            
            const blob = new Blob([report], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'edit_marker_test_results.md';
            a.click();
            
            alert(`üìä Results exported!\n\n‚úÖ Good: ${goodCount}\n‚ö†Ô∏è Offset: ${offsetCount}\n‚ùå Bad: ${badCount}\n‚è≥ Pending: ${pendingCount}`);
        }
    </script>
</body>
</html>

