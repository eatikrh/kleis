# Z3 Solver Capabilities
# 
# Follows the common solver schema (see capabilities_schema.md)

[solver]
name = "Z3"
version = "4.12.0"
type = "smt"
description = "SMT solver with arithmetic, boolean logic, quantifiers, and uninterpreted functions"

[capabilities]
# Supported theories
theories = [
    # NATIVE Z3 theories
    "arithmetic",
    "boolean",
    "equality",
    "Int",
    "Real",
    "Bool",
    "String",
    "strings",
    "Regex",
    "regex",
    "BitVec",
    "Array",
    "Datatype",
    "Complex",
    "complex",
    "Rational",
    "rational",
    "Set",
    "sets",
    "uninterpreted_functions"
]

# Native operation support
[capabilities.operations]

# Equality and Inequality
equals = { arity = 2, theory = "Any", native = true }
eq = { arity = 2, theory = "Any", native = true }
neq = { arity = 2, theory = "Any", native = true }
not_equals = { arity = 2, theory = "Any", native = true }

# Comparisons
less_than = { arity = 2, theory = "Int/Real", native = true }
lt = { arity = 2, theory = "Int/Real", native = true }
greater_than = { arity = 2, theory = "Int/Real", native = true }
gt = { arity = 2, theory = "Int/Real", native = true }
leq = { arity = 2, theory = "Int/Real", native = true }
geq = { arity = 2, theory = "Int/Real", native = true }

# Boolean operations
and = { arity = 2, theory = "Bool", native = true }
logical_and = { arity = 2, theory = "Bool", native = true }
or = { arity = 2, theory = "Bool", native = true }
logical_or = { arity = 2, theory = "Bool", native = true }
not = { arity = 1, theory = "Bool", native = true }
logical_not = { arity = 1, theory = "Bool", native = true }
implies = { arity = 2, theory = "Bool", native = true }

# Arithmetic operations
plus = { arity = 2, theory = "Int/Real", native = true }
add = { arity = 2, theory = "Int/Real", native = true }
minus = { arity = 2, theory = "Int/Real", native = true }
subtract = { arity = 2, theory = "Int/Real", native = true }
times = { arity = 2, theory = "Int/Real", native = true }
multiply = { arity = 2, theory = "Int/Real", native = true }
neg = { arity = 1, theory = "Int/Real", native = true }
negate = { arity = 1, theory = "Int/Real", native = true }

# String operations
concat = { arity = 2, theory = "String", native = true }
str_concat = { arity = 2, theory = "String", native = true }
strlen = { arity = 1, theory = "String", native = true }
str_len = { arity = 1, theory = "String", native = true }
length = { arity = 1, theory = "String", native = true }
contains = { arity = 2, theory = "String", native = true }
str_contains = { arity = 2, theory = "String", native = true }
hasPrefix = { arity = 2, theory = "String", native = true }
str_prefix = { arity = 2, theory = "String", native = true }
prefix = { arity = 2, theory = "String", native = true }
hasSuffix = { arity = 2, theory = "String", native = true }
str_suffix = { arity = 2, theory = "String", native = true }
suffix = { arity = 2, theory = "String", native = true }
substr = { arity = 3, theory = "String", native = true }
substring = { arity = 3, theory = "String", native = true }
indexOf = { arity = 3, theory = "String", native = true }
str_indexof = { arity = 3, theory = "String", native = true }
indexof = { arity = 3, theory = "String", native = true }
replace = { arity = 3, theory = "String", native = true }
str_replace = { arity = 3, theory = "String", native = true }
charAt = { arity = 2, theory = "String", native = true }
str_at = { arity = 2, theory = "String", native = true }
strToInt = { arity = 1, theory = "String", native = true }
str_to_int = { arity = 1, theory = "String", native = true }
toInt = { arity = 1, theory = "String", native = true }
intToStr = { arity = 1, theory = "String", native = true }
int_to_str = { arity = 1, theory = "String", native = true }
fromInt = { arity = 1, theory = "String", native = true }
intToString = { arity = 1, theory = "String", native = true }

# Regex operations
matchesRegex = { arity = 2, theory = "Regex", native = true }
matches = { arity = 2, theory = "Regex", native = true }
str_in_re = { arity = 2, theory = "Regex", native = true }
isDigits = { arity = 1, theory = "Regex", native = true }
is_digits = { arity = 1, theory = "Regex", native = true }
isAlpha = { arity = 1, theory = "Regex", native = true }
is_alpha = { arity = 1, theory = "Regex", native = true }
isAlphaNum = { arity = 1, theory = "Regex", native = true }
is_alphanum = { arity = 1, theory = "Regex", native = true }

# Complex number operations (ENCODED as Real pairs)
complex = { arity = 2, theory = "Complex", native = false }
re = { arity = 1, theory = "Complex", native = false }
real_part = { arity = 1, theory = "Complex", native = false }
im = { arity = 1, theory = "Complex", native = false }
imag_part = { arity = 1, theory = "Complex", native = false }
conj = { arity = 1, theory = "Complex", native = false }
conjugate = { arity = 1, theory = "Complex", native = false }
complex_add = { arity = 2, theory = "Complex", native = false }
complex_sub = { arity = 2, theory = "Complex", native = false }
complex_mul = { arity = 2, theory = "Complex", native = false }
complex_div = { arity = 2, theory = "Complex", native = false }
complex_inverse = { arity = 1, theory = "Complex", native = false }
neg_complex = { arity = 1, theory = "Complex", native = false }
abs_squared = { arity = 1, theory = "Complex", native = false }

# Rational number operations (mapped to Z3 Real)
rational = { arity = 2, theory = "Real", native = true }
numer = { arity = 1, theory = "Real", native = false }
denom = { arity = 1, theory = "Real", native = false }
rational_add = { arity = 2, theory = "Real", native = true }
rational_sub = { arity = 2, theory = "Real", native = true }
rational_mul = { arity = 2, theory = "Real", native = true }
rational_div = { arity = 2, theory = "Real", native = true }
neg_rational = { arity = 1, theory = "Real", native = true }
rational_inv = { arity = 1, theory = "Real", native = true }
rational_lt = { arity = 2, theory = "Real", native = true }
rational_le = { arity = 2, theory = "Real", native = true }
rational_gt = { arity = 2, theory = "Real", native = true }
rational_ge = { arity = 2, theory = "Real", native = true }
int_to_rational = { arity = 1, theory = "Real", native = true }
nat_to_rational = { arity = 1, theory = "Real", native = true }
to_real = { arity = 1, theory = "Real", native = true }
abs_rational = { arity = 1, theory = "Real", native = false }
sign_rational = { arity = 1, theory = "Real", native = false }
min_rational = { arity = 2, theory = "Real", native = false }
max_rational = { arity = 2, theory = "Real", native = false }
midpoint = { arity = 2, theory = "Real", native = false }

# Integer operations
int_div = { arity = 2, theory = "Int", native = true }
int_mod = { arity = 2, theory = "Int", native = true }
int_rem = { arity = 2, theory = "Int", native = true }
floor = { arity = 1, theory = "Rational", native = true }
ceil = { arity = 1, theory = "Rational", native = true }
gcd = { arity = 2, theory = "Int", native = false }
power = { arity = 2, theory = "Real", native = true }
pow = { arity = 2, theory = "Real", native = true }
is_int = { arity = 1, theory = "Real", native = true }

# BitVector operations
bvand = { arity = 2, theory = "BitVec", native = true }
bvor = { arity = 2, theory = "BitVec", native = true }
bvxor = { arity = 2, theory = "BitVec", native = true }
bvnot = { arity = 1, theory = "BitVec", native = true }
bvadd = { arity = 2, theory = "BitVec", native = true }
bvsub = { arity = 2, theory = "BitVec", native = true }
bvmul = { arity = 2, theory = "BitVec", native = true }
bvneg = { arity = 1, theory = "BitVec", native = true }
bvudiv = { arity = 2, theory = "BitVec", native = true }
bvsdiv = { arity = 2, theory = "BitVec", native = true }
bvurem = { arity = 2, theory = "BitVec", native = true }
bvshl = { arity = 2, theory = "BitVec", native = true }
bvlshr = { arity = 2, theory = "BitVec", native = true }
bvashr = { arity = 2, theory = "BitVec", native = true }
bvult = { arity = 2, theory = "BitVec", native = true }
bvule = { arity = 2, theory = "BitVec", native = true }
bvugt = { arity = 2, theory = "BitVec", native = true }
bvuge = { arity = 2, theory = "BitVec", native = true }
bvslt = { arity = 2, theory = "BitVec", native = true }
bvsle = { arity = 2, theory = "BitVec", native = true }
bvsgt = { arity = 2, theory = "BitVec", native = true }
bvsge = { arity = 2, theory = "BitVec", native = true }
bvzero = { arity = 1, theory = "BitVec", native = false }
bvones = { arity = 1, theory = "BitVec", native = false }
bvone = { arity = 1, theory = "BitVec", native = false }
extract = { arity = 3, theory = "BitVec", native = true }
bvconcat = { arity = 2, theory = "BitVec", native = true }
zext = { arity = 2, theory = "BitVec", native = true }
sext = { arity = 2, theory = "BitVec", native = true }

# Set operations
empty_set = { arity = 0, theory = "Set", native = true }
set_empty = { arity = 0, theory = "Set", native = true }
singleton = { arity = 1, theory = "Set", native = true }
set_singleton = { arity = 1, theory = "Set", native = true }
insert = { arity = 2, theory = "Set", native = true }
set_add = { arity = 2, theory = "Set", native = true }
remove = { arity = 2, theory = "Set", native = true }
set_del = { arity = 2, theory = "Set", native = true }
in_set = { arity = 2, theory = "Set", native = true }
member = { arity = 2, theory = "Set", native = true }
set_member = { arity = 2, theory = "Set", native = true }
union = { arity = 2, theory = "Set", native = true }
set_union = { arity = 2, theory = "Set", native = true }
intersect = { arity = 2, theory = "Set", native = true }
set_intersect = { arity = 2, theory = "Set", native = true }
intersection = { arity = 2, theory = "Set", native = true }
difference = { arity = 2, theory = "Set", native = true }
set_difference = { arity = 2, theory = "Set", native = true }
set_diff = { arity = 2, theory = "Set", native = true }
complement = { arity = 1, theory = "Set", native = true }
set_complement = { arity = 1, theory = "Set", native = true }
subset = { arity = 2, theory = "Set", native = true }
set_subset = { arity = 2, theory = "Set", native = true }

[capabilities.features]
quantifiers = true
uninterpreted_functions = true
recursive_functions = true
evaluation = true
simplification = false
proof_generation = false

[capabilities.performance]
max_axioms = 10000
timeout_ms = 5000
