# Z3 Solver Capabilities Declaration
# MCP-style capability manifest
# See: docs/session-2024-12-12/SOLVER_MCP_STYLE_CAPABILITIES.md
#
# ============================================
# Z3 REAL (RATIONAL) OPERATORS REFERENCE
# ============================================
# 
# Core Arithmetic (overloaded + methods):
#   +, -, *, /        Real::add, Real::sub, Real::mul, Real::div
#   -x                Real::unary_minus()
#   a^b               Real::power(&b) - NOTE: non-linear, can be slow
#
# Comparison (return Bool AST, not Rust bool):
#   a._eq(&b)         Mathematical equality (NOT == which compares AST)
#   a.distinct(&b)    Inequality
#   a.gt/ge/lt/le(&b) Ordering comparisons
#
# Conversion:
#   x.to_int()        Floor: ℚ → ℤ (truncates toward -∞)
#   Int::to_real(&i)  Embed: ℤ → ℚ
#   x.is_int()        Returns Bool: is this Real an integer?
#
# Special:
#   cond.ite(&a, &b)  If-then-else for piecewise functions
#   Real::from_real(ctx, num, den)  Create rational constant
#
# IMPORTANT:
#   - Division by zero is allowed but result-unspecified (guard it!)
#   - Remainder (mod) is NOT native for Reals, only Int
#   - Non-linear arithmetic (power, x*y) can make solver return "unknown"
#   - Keep constraints linear when possible for best performance
#
# ============================================

[solver]
name = "Z3"
version = "4.12.0"
type = "smt"
description = "Z3 Theorem Prover from Microsoft Research - SMT solver with support for arithmetic, boolean logic, quantifiers, and uninterpreted functions"

[capabilities]
# Supported theories
theories = [
    "arithmetic",      # Int and Real arithmetic
    "boolean",         # Propositional logic
    "equality",        # Equality reasoning
    "strings",         # String theory (QF_SLIA)
    "regex",           # Regular expressions
    "rational",        # Rational numbers (ℚ) - Z3 Real is actually ℚ
    "complex",         # Complex numbers (encoded as Real pairs)
    "uninterpreted_functions"  # Abstract operations
]

# Native operation support (15 operations with Z3 translators)
[capabilities.operations]

# Equality and Inequality (works with any type)
equals = { arity = 2, theory = "Any", native = true }
eq = { arity = 2, theory = "Any", native = true }
neq = { arity = 2, theory = "Any", native = true, description = "Not equal: a ≠ b" }
not_equals = { arity = 2, theory = "Any", native = true }

# Comparisons (Int and Real)
less_than = { arity = 2, theory = "Int/Real", native = true }
lt = { arity = 2, theory = "Int/Real", native = true }
greater_than = { arity = 2, theory = "Int/Real", native = true }
gt = { arity = 2, theory = "Int/Real", native = true }
leq = { arity = 2, theory = "Int/Real", native = true }
geq = { arity = 2, theory = "Int/Real", native = true }

# Boolean operations
and = { arity = 2, theory = "Bool", native = true }
logical_and = { arity = 2, theory = "Bool", native = true }
or = { arity = 2, theory = "Bool", native = true }
logical_or = { arity = 2, theory = "Bool", native = true }
not = { arity = 1, theory = "Bool", native = true }
logical_not = { arity = 1, theory = "Bool", native = true }
implies = { arity = 2, theory = "Bool", native = true }

# Arithmetic operations (Int and Real)
plus = { arity = 2, theory = "Int/Real", native = true }
add = { arity = 2, theory = "Int/Real", native = true }
minus = { arity = 2, theory = "Int/Real", native = true }
subtract = { arity = 2, theory = "Int/Real", native = true }
times = { arity = 2, theory = "Int/Real", native = true }
multiply = { arity = 2, theory = "Int/Real", native = true }
neg = { arity = 1, theory = "Int/Real", native = true }
negate = { arity = 1, theory = "Int/Real", native = true }

# String operations (QF_SLIA theory)
concat = { arity = 2, theory = "String", native = true }
str_concat = { arity = 2, theory = "String", native = true }
strlen = { arity = 1, theory = "String", native = true }
str_len = { arity = 1, theory = "String", native = true }
length = { arity = 1, theory = "String", native = true }
contains = { arity = 2, theory = "String", native = true }
str_contains = { arity = 2, theory = "String", native = true }
hasPrefix = { arity = 2, theory = "String", native = true }
str_prefix = { arity = 2, theory = "String", native = true }
prefix = { arity = 2, theory = "String", native = true }
hasSuffix = { arity = 2, theory = "String", native = true }
str_suffix = { arity = 2, theory = "String", native = true }
suffix = { arity = 2, theory = "String", native = true }

# Substring operations
substr = { arity = 3, theory = "String", native = true }
substring = { arity = 3, theory = "String", native = true }
indexOf = { arity = 3, theory = "String", native = true }
str_indexof = { arity = 3, theory = "String", native = true }
indexof = { arity = 3, theory = "String", native = true }
replace = { arity = 3, theory = "String", native = true }
str_replace = { arity = 3, theory = "String", native = true }
charAt = { arity = 2, theory = "String", native = true }
str_at = { arity = 2, theory = "String", native = true }

# String-Integer conversion
strToInt = { arity = 1, theory = "String", native = true }
str_to_int = { arity = 1, theory = "String", native = true }
toInt = { arity = 1, theory = "String", native = true }
intToStr = { arity = 1, theory = "String", native = true }
int_to_str = { arity = 1, theory = "String", native = true }
fromInt = { arity = 1, theory = "String", native = true }
intToString = { arity = 1, theory = "String", native = true }

# Regular expression operations
matchesRegex = { arity = 2, theory = "Regex", native = true }
matches = { arity = 2, theory = "Regex", native = true }
str_in_re = { arity = 2, theory = "Regex", native = true }
isDigits = { arity = 1, theory = "Regex", native = true }
is_digits = { arity = 1, theory = "Regex", native = true }
isAlpha = { arity = 1, theory = "Regex", native = true }
is_alpha = { arity = 1, theory = "Regex", native = true }
isAlphaNum = { arity = 1, theory = "Regex", native = true }
is_alphanum = { arity = 1, theory = "Regex", native = true }

# Complex number operations (encoded as Real pairs)
# Z3 doesn't have native complex support, so we encode ℂ as (re: Real, im: Real)
# with algebraic translation of operations
complex = { arity = 2, theory = "Complex", native = true, description = "Constructor: complex(re, im) creates re + im*i" }
re = { arity = 1, theory = "Complex", native = true, description = "Extract real part" }
real_part = { arity = 1, theory = "Complex", native = true }
im = { arity = 1, theory = "Complex", native = true, description = "Extract imaginary part" }
imag_part = { arity = 1, theory = "Complex", native = true }
conj = { arity = 1, theory = "Complex", native = true, description = "Complex conjugate: conj(a+bi) = a-bi" }
conjugate = { arity = 1, theory = "Complex", native = true }
complex_add = { arity = 2, theory = "Complex", native = true, description = "Complex addition" }
complex_sub = { arity = 2, theory = "Complex", native = true, description = "Complex subtraction" }
complex_mul = { arity = 2, theory = "Complex", native = true, description = "Complex multiplication" }
complex_div = { arity = 2, theory = "Complex", native = true, description = "Complex division" }
complex_inverse = { arity = 1, theory = "Complex", native = true, description = "Multiplicative inverse: 1/z" }
neg_complex = { arity = 1, theory = "Complex", native = true, description = "Negation: -z" }
abs_squared = { arity = 1, theory = "Complex", native = true, description = "Magnitude squared: |z|² = re² + im²" }

# Rational number operations (ℚ)
# Z3's Real sort is actually ℚ (the rationals), so we use Real directly
# This makes rational arithmetic exact (no floating-point issues)
rational = { arity = 2, theory = "Rational", native = true, description = "Constructor: rational(p, q) = p/q" }
numer = { arity = 1, theory = "Rational", native = false, description = "Numerator accessor (uninterpreted)" }
denom = { arity = 1, theory = "Rational", native = false, description = "Denominator accessor (uninterpreted)" }
rational_add = { arity = 2, theory = "Rational", native = true, description = "Rational addition" }
rational_sub = { arity = 2, theory = "Rational", native = true, description = "Rational subtraction" }
rational_mul = { arity = 2, theory = "Rational", native = true, description = "Rational multiplication" }
rational_div = { arity = 2, theory = "Rational", native = true, description = "Rational division" }
neg_rational = { arity = 1, theory = "Rational", native = true, description = "Negation: -r" }
rational_inv = { arity = 1, theory = "Rational", native = true, description = "Reciprocal: 1/r" }
rational_lt = { arity = 2, theory = "Rational", native = true, description = "Less than: r₁ < r₂" }
rational_le = { arity = 2, theory = "Rational", native = true, description = "Less than or equal: r₁ ≤ r₂" }
rational_gt = { arity = 2, theory = "Rational", native = true, description = "Greater than: r₁ > r₂" }
rational_ge = { arity = 2, theory = "Rational", native = true, description = "Greater than or equal: r₁ ≥ r₂" }
int_to_rational = { arity = 1, theory = "Rational", native = true, description = "Integer to rational: n → n/1" }
nat_to_rational = { arity = 1, theory = "Rational", native = true, description = "Natural to rational: n → n/1" }
to_real = { arity = 1, theory = "Rational", native = true, description = "Rational to real (identity in Z3)" }
abs_rational = { arity = 1, theory = "Rational", native = true, description = "Absolute value: |r|" }
sign_rational = { arity = 1, theory = "Rational", native = false, description = "Sign: -1, 0, or 1 (defined in Kleis)" }
min_rational = { arity = 2, theory = "Rational", native = false, description = "Minimum (defined in Kleis)" }
max_rational = { arity = 2, theory = "Rational", native = false, description = "Maximum (defined in Kleis)" }
midpoint = { arity = 2, theory = "Rational", native = false, description = "Midpoint: (r1 + r2) / 2 (defined in Kleis)" }

# Integer division and modulo
int_div = { arity = 2, theory = "Int", native = true, description = "Integer division: a div b" }
int_mod = { arity = 2, theory = "Int", native = true, description = "Integer modulo: a mod b (non-negative)" }
int_rem = { arity = 2, theory = "Int", native = true, description = "Integer remainder: a rem b (sign follows a)" }

# Floor and ceiling (ℚ → ℤ)
floor = { arity = 1, theory = "Rational", native = true, description = "Floor: largest integer ≤ r" }
ceil = { arity = 1, theory = "Rational", native = true, description = "Ceiling: smallest integer ≥ r" }

# GCD (defined axiomatically)
gcd = { arity = 2, theory = "Int", native = false, description = "GCD: greatest common divisor (axiomatized)" }

# Power (non-linear - may cause "unknown" for complex constraints)
power = { arity = 2, theory = "Real", native = true, description = "Exponentiation: a^b (WARNING: non-linear)" }
pow = { arity = 2, theory = "Real", native = true, description = "Alias for power" }

# Integer check
is_int = { arity = 1, theory = "Real", native = true, description = "Is this Real an integer? Returns Bool" }

# Note: Z3 supports many more operations via its built-in theories,
# but these are the ones explicitly translated in our current implementation.
# Other operations (sin, cos, matrix_multiply, etc.) are treated as
# uninterpreted functions, which is correct for theorem proving!

[capabilities.features]
quantifiers = true
uninterpreted_functions = true
recursive_functions = true
evaluation = true
simplification = false  # Z3 has simplify() but not always reliable
proof_generation = false  # Available in Z3 but not exposed yet
string_theory = true  # QF_SLIA: Quantifier-Free Strings and Linear Integer Arithmetic
regex_support = true  # Regular expression constraints via str.in_re
rational_numbers = true  # ℚ - Z3 Real sort is actually ℚ, exact arithmetic
complex_numbers = true  # ℂ encoded as (Real, Real) pairs with algebraic axioms

[capabilities.performance]
max_axioms = 10000  # Z3 can handle thousands of axioms efficiently
timeout_ms = 5000   # Default timeout for SMT queries

